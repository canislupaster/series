{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,E,Q,C,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,E,a,C,C,G,E,E,O,C,U,I,G,ICEM,E,E,E,SA6xMN,GA7xMM,EAAJ,kBAGF,SAAS,EAAY,CAAC,CAAC,EAIvB,SAAS,IAIP,OAHI,EAAW,MAAA,EAAU,EAAM,MAAA,EAC7B,IAEK,CACT,CACA,SAAS,IAIP,OAHI,EAAW,MAAA,EAAU,EAAM,MAAA,EAC7B,IAEK,CACT,CACA,SAAS,IAIP,OAHI,EAAW,MAAA,EAAU,EAAM,MAAA,EAC7B,IAEK,CACT,CACA,SAAS,IAIP,OAHI,EAAW,MAAA,EAAU,EAAM,MAAA,EAC7B,IAEK,CACT,CACA,SAAS,IAIP,OAHI,EAAW,MAAA,EAAU,EAAM,MAAA,EAC7B,IAEK,CACT,CACA,SAAS,IAIP,OAHI,EAAW,MAAA,EAAU,EAAM,MAAA,EAC7B,IAEK,CACT,CAOA,SAAS,IAIP,OAHI,EAAW,MAAA,EAAU,EAAM,MAAA,EAC7B,IAEK,CACT,CAEA,IAgoB2B,EAUJ,EAxoBnB,EAAqB,EAiDrB,EAAO,EAAW,EAkKlB,EAcA,EAEA,EAIA,EAQM,EAAO,EAAQ,EAAQ,EAAS,EAAQ,EAAS,EAAS,EAmDhE,EA8NA,EA+GA,EAEA,EAmhLA,EAtoMA,EAAS,AAAoB,KAAA,IAAb,EAA2B,EAAY,CAAC,CAI5D,CAAA,EAAO,KAAQ,CAAG,IAAI,QAAQ,SAAS,CAAO,CAAE,CAAM,EACrD,EAAsB,EACtB,EAAqB,CACtB,GAEA,CAAE,QAAS,2BAA4B,2BAA4B,8BAA+B,oCAAqC,wBAAyB,gBAAiB,eAAgB,s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","sources":["<anon>","cas.mjs","node_modules/process/browser.js","node_modules/@parcel/runtime-js/lib/runtime-ff21fd9fb4ebc28a.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-8c78d800028e162f.js","node_modules/@parcel/runtime-js/lib/helpers/get-worker-url.js"],"sourcesContent":["function $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true, configurable: true});\n}\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire94c2\"] = parcelRequire;\n}\nparcelRequire.register(\"9cUbE\", function(module, exports) {\n\n$parcel$defineInteropFlag(module.exports);\n\n$parcel$export(module.exports, \"default\", () => $1624ce41e04aea51$export$2e2bcd8739ae039);\n\nvar $ifEks = parcelRequire(\"ifEks\");\n\n\nvar $1624ce41e04aea51$var$CASModule = (()=>{\n    var _scriptDir = \"file:///cas.mjs\";\n    return function(CASModule = {}) {\n        // Support for growable heap + pthreads, where the buffer may change, so JS views\n        // must be updated.\n        function GROWABLE_HEAP_I8() {\n            if (wasmMemory.buffer != HEAP8.buffer) updateMemoryViews();\n            return HEAP8;\n        }\n        function GROWABLE_HEAP_U8() {\n            if (wasmMemory.buffer != HEAP8.buffer) updateMemoryViews();\n            return HEAPU8;\n        }\n        function GROWABLE_HEAP_I16() {\n            if (wasmMemory.buffer != HEAP8.buffer) updateMemoryViews();\n            return HEAP16;\n        }\n        function GROWABLE_HEAP_U16() {\n            if (wasmMemory.buffer != HEAP8.buffer) updateMemoryViews();\n            return HEAPU16;\n        }\n        function GROWABLE_HEAP_I32() {\n            if (wasmMemory.buffer != HEAP8.buffer) updateMemoryViews();\n            return HEAP32;\n        }\n        function GROWABLE_HEAP_U32() {\n            if (wasmMemory.buffer != HEAP8.buffer) updateMemoryViews();\n            return HEAPU32;\n        }\n        function GROWABLE_HEAP_F32() {\n            if (wasmMemory.buffer != HEAP8.buffer) updateMemoryViews();\n            return HEAPF32;\n        }\n        function GROWABLE_HEAP_F64() {\n            if (wasmMemory.buffer != HEAP8.buffer) updateMemoryViews();\n            return HEAPF64;\n        }\n        var Module = typeof CASModule != \"undefined\" ? CASModule : {};\n        var readyPromiseResolve, readyPromiseReject;\n        Module[\"ready\"] = new Promise(function(resolve, reject) {\n            readyPromiseResolve = resolve;\n            readyPromiseReject = reject;\n        });\n        [\n            \"_main\",\n            \"__emscripten_thread_init\",\n            \"__emscripten_thread_exit\",\n            \"__emscripten_thread_crashed\",\n            \"__emscripten_thread_mailbox_await\",\n            \"__emscripten_tls_init\",\n            \"_pthread_self\",\n            \"checkMailbox\",\n            \"establishStackSpace\",\n            \"invokeEntryPoint\",\n            \"PThread\",\n            \"getExceptionMessage\",\n            \"___get_exception_message\",\n            \"_free\",\n            \"___cpp_exception\",\n            \"___cxa_increment_exception_refcount\",\n            \"___cxa_decrement_exception_refcount\",\n            \"___thrown_object_from_unwind_exception\",\n            \"___getTypeName\",\n            \"__embind_initialize_bindings\",\n            \"_fflush\",\n            \"__emscripten_check_mailbox\",\n            \"onRuntimeInitialized\"\n        ].forEach((prop)=>{\n            if (!Object.getOwnPropertyDescriptor(Module[\"ready\"], prop)) Object.defineProperty(Module[\"ready\"], prop, {\n                get: ()=>abort(\"You are getting \" + prop + \" on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\"),\n                set: ()=>abort(\"You are setting \" + prop + \" on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\")\n            });\n        });\n        var moduleOverrides = Object.assign({}, Module);\n        var arguments_ = [];\n        var thisProgram = \"./this.program\";\n        var quit_ = (status, toThrow)=>{\n            throw toThrow;\n        };\n        var ENVIRONMENT_IS_WEB = typeof window == \"object\";\n        var ENVIRONMENT_IS_WORKER = typeof importScripts == \"function\";\n        var ENVIRONMENT_IS_NODE = typeof $ifEks == \"object\" && typeof $ifEks.versions == \"object\" && typeof $ifEks.versions.node == \"string\";\n        var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n        if (Module[\"ENVIRONMENT\"]) throw new Error(\"Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)\");\n        var ENVIRONMENT_IS_PTHREAD = Module[\"ENVIRONMENT_IS_PTHREAD\"] || false;\n        var scriptDirectory = \"\";\n        function locateFile(path) {\n            if (Module[\"locateFile\"]) return Module[\"locateFile\"](path, scriptDirectory);\n            return scriptDirectory + path;\n        }\n        var read_, readAsync, readBinary, setWindowTitle;\n        if (ENVIRONMENT_IS_SHELL) {\n            if (typeof $ifEks == \"object\" && true || typeof window == \"object\" || typeof importScripts == \"function\") throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\n            if (typeof read != \"undefined\") read_ = function shell_read(f) {\n                return read(f);\n            };\n            readBinary = function readBinary(f) {\n                let data;\n                if (typeof readbuffer == \"function\") return new Uint8Array(readbuffer(f));\n                data = read(f, \"binary\");\n                assert(typeof data == \"object\");\n                return data;\n            };\n            readAsync = function readAsync(f, onload, onerror) {\n                setTimeout(()=>onload(readBinary(f)), 0);\n            };\n            if (typeof clearTimeout == \"undefined\") globalThis.clearTimeout = (id)=>{};\n            if (typeof scriptArgs != \"undefined\") arguments_ = scriptArgs;\n            else if (typeof arguments != \"undefined\") arguments_ = arguments;\n            if (typeof quit == \"function\") quit_ = (status, toThrow)=>{\n                setTimeout(()=>{\n                    if (!(toThrow instanceof ExitStatus)) {\n                        let toLog = toThrow;\n                        if (toThrow && typeof toThrow == \"object\" && toThrow.stack) toLog = [\n                            toThrow,\n                            toThrow.stack\n                        ];\n                        err(\"exiting due to exception: \" + toLog);\n                    }\n                    quit(status);\n                });\n                throw toThrow;\n            };\n            if (typeof print != \"undefined\") {\n                if (typeof console == \"undefined\") console = {};\n                console.log = print;\n                console.warn = console.error = typeof printErr != \"undefined\" ? printErr : print;\n            }\n        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n            if (ENVIRONMENT_IS_WORKER) scriptDirectory = self.location.href;\n            else if (typeof document != \"undefined\" && document.currentScript) scriptDirectory = document.currentScript.src;\n            if (_scriptDir) scriptDirectory = _scriptDir;\n            if (scriptDirectory.indexOf(\"blob:\") !== 0) scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n            else scriptDirectory = \"\";\n            if (!(typeof window == \"object\" || typeof importScripts == \"function\")) throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\n            read_ = (url)=>{\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"GET\", url, false);\n                xhr.send(null);\n                return xhr.responseText;\n            };\n            if (ENVIRONMENT_IS_WORKER) readBinary = (url)=>{\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"GET\", url, false);\n                xhr.responseType = \"arraybuffer\";\n                xhr.send(null);\n                return new Uint8Array(xhr.response);\n            };\n            readAsync = (url, onload, onerror)=>{\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"GET\", url, true);\n                xhr.responseType = \"arraybuffer\";\n                xhr.onload = ()=>{\n                    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n                        onload(xhr.response);\n                        return;\n                    }\n                    onerror();\n                };\n                xhr.onerror = onerror;\n                xhr.send(null);\n            };\n            setWindowTitle = (title)=>document.title = title;\n        } else throw new Error(\"environment detection error\");\n        var out = Module[\"print\"] || console.log.bind(console);\n        var err = Module[\"printErr\"] || console.warn.bind(console);\n        Object.assign(Module, moduleOverrides);\n        moduleOverrides = null;\n        checkIncomingModuleAPI();\n        if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n        legacyModuleProp(\"arguments\", \"arguments_\");\n        if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n        legacyModuleProp(\"thisProgram\", \"thisProgram\");\n        if (Module[\"quit\"]) quit_ = Module[\"quit\"];\n        legacyModuleProp(\"quit\", \"quit_\");\n        assert(typeof Module[\"memoryInitializerPrefixURL\"] == \"undefined\", \"Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead\");\n        assert(typeof Module[\"pthreadMainPrefixURL\"] == \"undefined\", \"Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead\");\n        assert(typeof Module[\"cdInitializerPrefixURL\"] == \"undefined\", \"Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead\");\n        assert(typeof Module[\"filePackagePrefixURL\"] == \"undefined\", \"Module.filePackagePrefixURL option was removed, use Module.locateFile instead\");\n        assert(typeof Module[\"read\"] == \"undefined\", \"Module.read option was removed (modify read_ in JS)\");\n        assert(typeof Module[\"readAsync\"] == \"undefined\", \"Module.readAsync option was removed (modify readAsync in JS)\");\n        assert(typeof Module[\"readBinary\"] == \"undefined\", \"Module.readBinary option was removed (modify readBinary in JS)\");\n        assert(typeof Module[\"setWindowTitle\"] == \"undefined\", \"Module.setWindowTitle option was removed (modify setWindowTitle in JS)\");\n        assert(typeof Module[\"TOTAL_MEMORY\"] == \"undefined\", \"Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY\");\n        legacyModuleProp(\"read\", \"read_\");\n        legacyModuleProp(\"readAsync\", \"readAsync\");\n        legacyModuleProp(\"readBinary\", \"readBinary\");\n        legacyModuleProp(\"setWindowTitle\", \"setWindowTitle\");\n        var IDBFS = \"IDBFS is no longer included by default; build with -lidbfs.js\";\n        var PROXYFS = \"PROXYFS is no longer included by default; build with -lproxyfs.js\";\n        var WORKERFS = \"WORKERFS is no longer included by default; build with -lworkerfs.js\";\n        var NODEFS = \"NODEFS is no longer included by default; build with -lnodefs.js\";\n        assert(ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER || ENVIRONMENT_IS_NODE, \"Pthreads do not work in this environment yet (need Web Workers, or an alternative to them)\");\n        assert(!ENVIRONMENT_IS_NODE, \"node environment detected but not enabled at build time.  Add 'node' to `-sENVIRONMENT` to enable.\");\n        assert(!ENVIRONMENT_IS_SHELL, \"shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.\");\n        var wasmBinary;\n        if (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n        legacyModuleProp(\"wasmBinary\", \"wasmBinary\");\n        var noExitRuntime = Module[\"noExitRuntime\"] || true;\n        legacyModuleProp(\"noExitRuntime\", \"noExitRuntime\");\n        if (typeof WebAssembly != \"object\") abort(\"no native wasm support detected\");\n        var wasmMemory;\n        var wasmModule;\n        var ABORT = false;\n        var EXITSTATUS;\n        function assert(condition, text) {\n            if (!condition) abort(\"Assertion failed\" + (text ? \": \" + text : \"\"));\n        }\n        var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n        function updateMemoryViews() {\n            var b = wasmMemory.buffer;\n            Module[\"HEAP8\"] = HEAP8 = new Int8Array(b);\n            Module[\"HEAP16\"] = HEAP16 = new Int16Array(b);\n            Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\n            Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\n            Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\n            Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\n            Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\n            Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\n        }\n        assert(!Module[\"STACK_SIZE\"], \"STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time\");\n        assert(typeof Int32Array != \"undefined\" && typeof Float64Array !== \"undefined\" && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined, \"JS engine does not provide full typed array support\");\n        var INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 16777216;\n        legacyModuleProp(\"INITIAL_MEMORY\", \"INITIAL_MEMORY\");\n        assert(INITIAL_MEMORY >= 65536, \"INITIAL_MEMORY should be larger than STACK_SIZE, was \" + INITIAL_MEMORY + \"! (STACK_SIZE=\" + 65536 + \")\");\n        if (ENVIRONMENT_IS_PTHREAD) wasmMemory = Module[\"wasmMemory\"];\n        else if (Module[\"wasmMemory\"]) wasmMemory = Module[\"wasmMemory\"];\n        else {\n            wasmMemory = new WebAssembly.Memory({\n                \"initial\": INITIAL_MEMORY / 65536,\n                \"maximum\": 32768,\n                \"shared\": true\n            });\n            if (!(wasmMemory.buffer instanceof SharedArrayBuffer)) {\n                err(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\");\n                if (ENVIRONMENT_IS_NODE) err(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)\");\n                throw Error(\"bad memory\");\n            }\n        }\n        updateMemoryViews();\n        INITIAL_MEMORY = wasmMemory.buffer.byteLength;\n        assert(INITIAL_MEMORY % 65536 === 0);\n        var wasmTable;\n        function writeStackCookie() {\n            var max = _emscripten_stack_get_end();\n            assert((max & 3) == 0);\n            if (max == 0) max += 4;\n            GROWABLE_HEAP_U32()[max >> 2] = 34821223;\n            GROWABLE_HEAP_U32()[max + 4 >> 2] = 2310721022;\n            GROWABLE_HEAP_U32()[0] = 1668509029;\n        }\n        function checkStackCookie() {\n            if (ABORT) return;\n            var max = _emscripten_stack_get_end();\n            if (max == 0) max += 4;\n            var cookie1 = GROWABLE_HEAP_U32()[max >> 2];\n            var cookie2 = GROWABLE_HEAP_U32()[max + 4 >> 2];\n            if (cookie1 != 34821223 || cookie2 != 2310721022) abort(\"Stack overflow! Stack cookie has been overwritten at \" + ptrToString(max) + \", expected hex dwords 0x89BACDFE and 0x2135467, but received \" + ptrToString(cookie2) + \" \" + ptrToString(cookie1));\n            if (GROWABLE_HEAP_U32()[0] !== 1668509029) abort(\"Runtime error: The application has corrupted its heap memory area (address zero)!\");\n        }\n        (function() {\n            var h16 = new Int16Array(1);\n            var h8 = new Int8Array(h16.buffer);\n            h16[0] = 25459;\n            if (h8[0] !== 115 || h8[1] !== 99) throw \"Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)\";\n        })();\n        var __ATPRERUN__ = [];\n        var __ATINIT__ = [];\n        var __ATEXIT__ = [];\n        var __ATPOSTRUN__ = [];\n        var runtimeInitialized = false;\n        var runtimeKeepaliveCounter = 0;\n        function keepRuntimeAlive() {\n            return noExitRuntime || runtimeKeepaliveCounter > 0;\n        }\n        function preRun() {\n            assert(!ENVIRONMENT_IS_PTHREAD);\n            if (Module[\"preRun\"]) {\n                if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [\n                    Module[\"preRun\"]\n                ];\n                while(Module[\"preRun\"].length)addOnPreRun(Module[\"preRun\"].shift());\n            }\n            callRuntimeCallbacks(__ATPRERUN__);\n        }\n        function initRuntime() {\n            assert(!runtimeInitialized);\n            runtimeInitialized = true;\n            if (ENVIRONMENT_IS_PTHREAD) return;\n            checkStackCookie();\n            if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init();\n            FS.ignorePermissions = false;\n            TTY.init();\n            callRuntimeCallbacks(__ATINIT__);\n        }\n        function postRun() {\n            checkStackCookie();\n            if (ENVIRONMENT_IS_PTHREAD) return;\n            if (Module[\"postRun\"]) {\n                if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [\n                    Module[\"postRun\"]\n                ];\n                while(Module[\"postRun\"].length)addOnPostRun(Module[\"postRun\"].shift());\n            }\n            callRuntimeCallbacks(__ATPOSTRUN__);\n        }\n        function addOnPreRun(cb) {\n            __ATPRERUN__.unshift(cb);\n        }\n        function addOnInit(cb) {\n            __ATINIT__.unshift(cb);\n        }\n        function addOnExit(cb) {}\n        function addOnPostRun(cb) {\n            __ATPOSTRUN__.unshift(cb);\n        }\n        assert(Math.imul, \"This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n        assert(Math.fround, \"This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n        assert(Math.clz32, \"This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n        assert(Math.trunc, \"This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n        var runDependencies = 0;\n        var runDependencyWatcher = null;\n        var dependenciesFulfilled = null;\n        var runDependencyTracking = {};\n        function getUniqueRunDependency(id) {\n            var orig = id;\n            while(true){\n                if (!runDependencyTracking[id]) return id;\n                id = orig + Math.random();\n            }\n        }\n        function addRunDependency(id) {\n            runDependencies++;\n            if (Module[\"monitorRunDependencies\"]) Module[\"monitorRunDependencies\"](runDependencies);\n            if (id) {\n                assert(!runDependencyTracking[id]);\n                runDependencyTracking[id] = 1;\n                if (runDependencyWatcher === null && typeof setInterval != \"undefined\") runDependencyWatcher = setInterval(function() {\n                    if (ABORT) {\n                        clearInterval(runDependencyWatcher);\n                        runDependencyWatcher = null;\n                        return;\n                    }\n                    var shown = false;\n                    for(var dep in runDependencyTracking){\n                        if (!shown) {\n                            shown = true;\n                            err(\"still waiting on run dependencies:\");\n                        }\n                        err(\"dependency: \" + dep);\n                    }\n                    if (shown) err(\"(end of list)\");\n                }, 1e4);\n            } else err(\"warning: run dependency added without ID\");\n        }\n        function removeRunDependency(id) {\n            runDependencies--;\n            if (Module[\"monitorRunDependencies\"]) Module[\"monitorRunDependencies\"](runDependencies);\n            if (id) {\n                assert(runDependencyTracking[id]);\n                delete runDependencyTracking[id];\n            } else err(\"warning: run dependency removed without ID\");\n            if (runDependencies == 0) {\n                if (runDependencyWatcher !== null) {\n                    clearInterval(runDependencyWatcher);\n                    runDependencyWatcher = null;\n                }\n                if (dependenciesFulfilled) {\n                    var callback = dependenciesFulfilled;\n                    dependenciesFulfilled = null;\n                    callback();\n                }\n            }\n        }\n        function abort(what) {\n            if (Module[\"onAbort\"]) Module[\"onAbort\"](what);\n            what = \"Aborted(\" + what + \")\";\n            err(what);\n            ABORT = true;\n            EXITSTATUS = 1;\n            if (runtimeInitialized) ___trap();\n            var e = new WebAssembly.RuntimeError(what);\n            readyPromiseReject(e);\n            throw e;\n        }\n        var dataURIPrefix = \"data:application/octet-stream;base64,\";\n        function isDataURI(filename) {\n            return filename.startsWith(dataURIPrefix);\n        }\n        function isFileURI(filename) {\n            return filename.startsWith(\"file://\");\n        }\n        function createExportWrapper(name, fixedasm) {\n            return function() {\n                var displayName = name;\n                var asm = fixedasm;\n                if (!fixedasm) asm = Module[\"asm\"];\n                assert(runtimeInitialized, \"native function `\" + displayName + \"` called before runtime initialization\");\n                if (!asm[name]) assert(asm[name], \"exported native function `\" + displayName + \"` not found\");\n                return asm[name].apply(null, arguments);\n            };\n        }\n        var wasmBinaryFile;\n        if (Module[\"locateFile\"]) {\n            wasmBinaryFile = \"cas.wasm\";\n            if (!isDataURI(wasmBinaryFile)) wasmBinaryFile = locateFile(wasmBinaryFile);\n        } else wasmBinaryFile = new URL((parcelRequire(\"68lLB\"))).href;\n        function getBinary(file) {\n            try {\n                if (file == wasmBinaryFile && wasmBinary) return new Uint8Array(wasmBinary);\n                if (readBinary) return readBinary(file);\n                throw \"both async and sync fetching of the wasm failed\";\n            } catch (err) {\n                abort(err);\n            }\n        }\n        function getBinaryPromise(binaryFile) {\n            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n                if (typeof fetch == \"function\") return fetch(binaryFile, {\n                    credentials: \"same-origin\"\n                }).then(function(response) {\n                    if (!response[\"ok\"]) throw \"failed to load wasm binary file at '\" + binaryFile + \"'\";\n                    return response[\"arrayBuffer\"]();\n                }).catch(function() {\n                    return getBinary(binaryFile);\n                });\n            }\n            return Promise.resolve().then(function() {\n                return getBinary(binaryFile);\n            });\n        }\n        function instantiateArrayBuffer(binaryFile, imports, receiver) {\n            return getBinaryPromise(binaryFile).then(function(binary) {\n                return WebAssembly.instantiate(binary, imports);\n            }).then(function(instance) {\n                return instance;\n            }).then(receiver, function(reason) {\n                err(\"failed to asynchronously prepare wasm: \" + reason);\n                if (isFileURI(wasmBinaryFile)) err(\"warning: Loading from a file URI (\" + wasmBinaryFile + \") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing\");\n                abort(reason);\n            });\n        }\n        function instantiateAsync(binary, binaryFile, imports, callback) {\n            if (!binary && typeof WebAssembly.instantiateStreaming == \"function\" && !isDataURI(binaryFile) && typeof fetch == \"function\") return fetch(binaryFile, {\n                credentials: \"same-origin\"\n            }).then(function(response) {\n                var result = WebAssembly.instantiateStreaming(response, imports);\n                return result.then(callback, function(reason) {\n                    err(\"wasm streaming compile failed: \" + reason);\n                    err(\"falling back to ArrayBuffer instantiation\");\n                    return instantiateArrayBuffer(binaryFile, imports, callback);\n                });\n            });\n            else return instantiateArrayBuffer(binaryFile, imports, callback);\n        }\n        function createWasm() {\n            var info = {\n                \"env\": wasmImports,\n                \"wasi_snapshot_preview1\": wasmImports\n            };\n            function receiveInstance(instance, module) {\n                var exports = instance.exports;\n                Module[\"asm\"] = exports;\n                registerTLSInit(Module[\"asm\"][\"_emscripten_tls_init\"]);\n                wasmTable = Module[\"asm\"][\"__indirect_function_table\"];\n                assert(wasmTable, \"table not found in wasm exports\");\n                addOnInit(Module[\"asm\"][\"__wasm_call_ctors\"]);\n                wasmModule = module;\n                PThread.loadWasmModuleToAllWorkers(()=>removeRunDependency(\"wasm-instantiate\"));\n                return exports;\n            }\n            addRunDependency(\"wasm-instantiate\");\n            var trueModule = Module;\n            function receiveInstantiationResult(result) {\n                assert(Module === trueModule, \"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?\");\n                trueModule = null;\n                receiveInstance(result[\"instance\"], result[\"module\"]);\n            }\n            if (Module[\"instantiateWasm\"]) try {\n                return Module[\"instantiateWasm\"](info, receiveInstance);\n            } catch (e) {\n                err(\"Module.instantiateWasm callback failed with error: \" + e);\n                readyPromiseReject(e);\n            }\n            instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\n            return {};\n        }\n        var tempDouble;\n        var tempI64;\n        function legacyModuleProp(prop, newName) {\n            if (!Object.getOwnPropertyDescriptor(Module, prop)) Object.defineProperty(Module, prop, {\n                configurable: true,\n                get: function() {\n                    abort(\"Module.\" + prop + \" has been replaced with plain \" + newName + \" (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n                }\n            });\n        }\n        function ignoredModuleProp(prop) {\n            if (Object.getOwnPropertyDescriptor(Module, prop)) abort(\"`Module.\" + prop + \"` was supplied but `\" + prop + \"` not included in INCOMING_MODULE_JS_API\");\n        }\n        function isExportedByForceFilesystem(name) {\n            return name === \"FS_createPath\" || name === \"FS_createDataFile\" || name === \"FS_createPreloadedFile\" || name === \"FS_unlink\" || name === \"addRunDependency\" || name === \"FS_createLazyFile\" || name === \"FS_createDevice\" || name === \"removeRunDependency\";\n        }\n        function missingGlobal(sym, msg) {\n            if (typeof globalThis !== \"undefined\") Object.defineProperty(globalThis, sym, {\n                configurable: true,\n                get: function() {\n                    warnOnce(\"`\" + sym + \"` is not longer defined by emscripten. \" + msg);\n                    return undefined;\n                }\n            });\n        }\n        missingGlobal(\"buffer\", \"Please use HEAP8.buffer or wasmMemory.buffer\");\n        function missingLibrarySymbol(sym) {\n            if (typeof globalThis !== \"undefined\" && !Object.getOwnPropertyDescriptor(globalThis, sym)) Object.defineProperty(globalThis, sym, {\n                configurable: true,\n                get: function() {\n                    var msg = \"`\" + sym + \"` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line\";\n                    var librarySymbol = sym;\n                    if (!librarySymbol.startsWith(\"_\")) librarySymbol = \"$\" + sym;\n                    msg += \" (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE=\" + librarySymbol + \")\";\n                    if (isExportedByForceFilesystem(sym)) msg += \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\n                    warnOnce(msg);\n                    return undefined;\n                }\n            });\n            unexportedRuntimeSymbol(sym);\n        }\n        function unexportedRuntimeSymbol(sym) {\n            if (!Object.getOwnPropertyDescriptor(Module, sym)) Object.defineProperty(Module, sym, {\n                configurable: true,\n                get: function() {\n                    var msg = \"'\" + sym + \"' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\";\n                    if (isExportedByForceFilesystem(sym)) msg += \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\n                    abort(msg);\n                }\n            });\n        }\n        function dbg(text) {\n            console.error.apply(console, arguments);\n        }\n        function ExitStatus(status) {\n            this.name = \"ExitStatus\";\n            this.message = \"Program terminated with exit(\" + status + \")\";\n            this.status = status;\n        }\n        function terminateWorker(worker) {\n            worker.terminate();\n            worker.onmessage = (e)=>{\n                var cmd = e[\"data\"][\"cmd\"];\n                err('received \"' + cmd + '\" command from terminated worker: ' + worker.workerID);\n            };\n        }\n        function killThread(pthread_ptr) {\n            assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! killThread() can only ever be called from main application thread!\");\n            assert(pthread_ptr, \"Internal Error! Null pthread_ptr in killThread!\");\n            var worker = PThread.pthreads[pthread_ptr];\n            delete PThread.pthreads[pthread_ptr];\n            terminateWorker(worker);\n            __emscripten_thread_free_data(pthread_ptr);\n            PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker), 1);\n            worker.pthread_ptr = 0;\n        }\n        function cancelThread(pthread_ptr) {\n            assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! cancelThread() can only ever be called from main application thread!\");\n            assert(pthread_ptr, \"Internal Error! Null pthread_ptr in cancelThread!\");\n            var worker = PThread.pthreads[pthread_ptr];\n            worker.postMessage({\n                \"cmd\": \"cancel\"\n            });\n        }\n        function cleanupThread(pthread_ptr) {\n            assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! cleanupThread() can only ever be called from main application thread!\");\n            assert(pthread_ptr, \"Internal Error! Null pthread_ptr in cleanupThread!\");\n            var worker = PThread.pthreads[pthread_ptr];\n            assert(worker);\n            PThread.returnWorkerToPool(worker);\n        }\n        function zeroMemory(address, size) {\n            GROWABLE_HEAP_U8().fill(0, address, address + size);\n            return address;\n        }\n        function spawnThread(threadParams) {\n            assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! spawnThread() can only ever be called from main application thread!\");\n            assert(threadParams.pthread_ptr, \"Internal error, no pthread ptr!\");\n            var worker = PThread.getNewWorker();\n            if (!worker) return 6;\n            assert(!worker.pthread_ptr, \"Internal error!\");\n            PThread.runningWorkers.push(worker);\n            PThread.pthreads[threadParams.pthread_ptr] = worker;\n            worker.pthread_ptr = threadParams.pthread_ptr;\n            var msg = {\n                \"cmd\": \"run\",\n                \"start_routine\": threadParams.startRoutine,\n                \"arg\": threadParams.arg,\n                \"pthread_ptr\": threadParams.pthread_ptr\n            };\n            worker.postMessage(msg, threadParams.transferList);\n            return 0;\n        }\n        var PATH = {\n            isAbs: (path)=>path.charAt(0) === \"/\",\n            splitPath: (filename)=>{\n                var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n                return splitPathRe.exec(filename).slice(1);\n            },\n            normalizeArray: (parts, allowAboveRoot)=>{\n                var up = 0;\n                for(var i = parts.length - 1; i >= 0; i--){\n                    var last = parts[i];\n                    if (last === \".\") parts.splice(i, 1);\n                    else if (last === \"..\") {\n                        parts.splice(i, 1);\n                        up++;\n                    } else if (up) {\n                        parts.splice(i, 1);\n                        up--;\n                    }\n                }\n                if (allowAboveRoot) for(; up; up--)parts.unshift(\"..\");\n                return parts;\n            },\n            normalize: (path)=>{\n                var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === \"/\";\n                path = PATH.normalizeArray(path.split(\"/\").filter((p)=>!!p), !isAbsolute).join(\"/\");\n                if (!path && !isAbsolute) path = \".\";\n                if (path && trailingSlash) path += \"/\";\n                return (isAbsolute ? \"/\" : \"\") + path;\n            },\n            dirname: (path)=>{\n                var result = PATH.splitPath(path), root = result[0], dir = result[1];\n                if (!root && !dir) return \".\";\n                if (dir) dir = dir.substr(0, dir.length - 1);\n                return root + dir;\n            },\n            basename: (path)=>{\n                if (path === \"/\") return \"/\";\n                path = PATH.normalize(path);\n                path = path.replace(/\\/$/, \"\");\n                var lastSlash = path.lastIndexOf(\"/\");\n                if (lastSlash === -1) return path;\n                return path.substr(lastSlash + 1);\n            },\n            join: function() {\n                var paths = Array.prototype.slice.call(arguments);\n                return PATH.normalize(paths.join(\"/\"));\n            },\n            join2: (l, r)=>{\n                return PATH.normalize(l + \"/\" + r);\n            }\n        };\n        function initRandomFill() {\n            if (typeof crypto == \"object\" && typeof crypto[\"getRandomValues\"] == \"function\") return (view)=>(view.set(crypto.getRandomValues(new Uint8Array(view.byteLength))), view);\n            else abort(\"no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };\");\n        }\n        function randomFill(view) {\n            return (randomFill = initRandomFill())(view);\n        }\n        var PATH_FS = {\n            resolve: function() {\n                var resolvedPath = \"\", resolvedAbsolute = false;\n                for(var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--){\n                    var path = i >= 0 ? arguments[i] : FS.cwd();\n                    if (typeof path != \"string\") throw new TypeError(\"Arguments to path.resolve must be strings\");\n                    else if (!path) return \"\";\n                    resolvedPath = path + \"/\" + resolvedPath;\n                    resolvedAbsolute = PATH.isAbs(path);\n                }\n                resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter((p)=>!!p), !resolvedAbsolute).join(\"/\");\n                return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\n            },\n            relative: (from, to)=>{\n                from = PATH_FS.resolve(from).substr(1);\n                to = PATH_FS.resolve(to).substr(1);\n                function trim(arr) {\n                    var start = 0;\n                    for(; start < arr.length; start++){\n                        if (arr[start] !== \"\") break;\n                    }\n                    var end = arr.length - 1;\n                    for(; end >= 0; end--){\n                        if (arr[end] !== \"\") break;\n                    }\n                    if (start > end) return [];\n                    return arr.slice(start, end - start + 1);\n                }\n                var fromParts = trim(from.split(\"/\"));\n                var toParts = trim(to.split(\"/\"));\n                var length = Math.min(fromParts.length, toParts.length);\n                var samePartsLength = length;\n                for(var i = 0; i < length; i++)if (fromParts[i] !== toParts[i]) {\n                    samePartsLength = i;\n                    break;\n                }\n                var outputParts = [];\n                for(var i = samePartsLength; i < fromParts.length; i++)outputParts.push(\"..\");\n                outputParts = outputParts.concat(toParts.slice(samePartsLength));\n                return outputParts.join(\"/\");\n            }\n        };\n        function lengthBytesUTF8(str) {\n            var len = 0;\n            for(var i = 0; i < str.length; ++i){\n                var c = str.charCodeAt(i);\n                if (c <= 127) len++;\n                else if (c <= 2047) len += 2;\n                else if (c >= 55296 && c <= 57343) {\n                    len += 4;\n                    ++i;\n                } else len += 3;\n            }\n            return len;\n        }\n        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n            assert(typeof str === \"string\");\n            if (!(maxBytesToWrite > 0)) return 0;\n            var startIdx = outIdx;\n            var endIdx = outIdx + maxBytesToWrite - 1;\n            for(var i = 0; i < str.length; ++i){\n                var u = str.charCodeAt(i);\n                if (u >= 55296 && u <= 57343) {\n                    var u1 = str.charCodeAt(++i);\n                    u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n                }\n                if (u <= 127) {\n                    if (outIdx >= endIdx) break;\n                    heap[outIdx++] = u;\n                } else if (u <= 2047) {\n                    if (outIdx + 1 >= endIdx) break;\n                    heap[outIdx++] = 192 | u >> 6;\n                    heap[outIdx++] = 128 | u & 63;\n                } else if (u <= 65535) {\n                    if (outIdx + 2 >= endIdx) break;\n                    heap[outIdx++] = 224 | u >> 12;\n                    heap[outIdx++] = 128 | u >> 6 & 63;\n                    heap[outIdx++] = 128 | u & 63;\n                } else {\n                    if (outIdx + 3 >= endIdx) break;\n                    if (u > 1114111) warnOnce(\"Invalid Unicode code point \" + ptrToString(u) + \" encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).\");\n                    heap[outIdx++] = 240 | u >> 18;\n                    heap[outIdx++] = 128 | u >> 12 & 63;\n                    heap[outIdx++] = 128 | u >> 6 & 63;\n                    heap[outIdx++] = 128 | u & 63;\n                }\n            }\n            heap[outIdx] = 0;\n            return outIdx - startIdx;\n        }\n        function intArrayFromString(stringy, dontAddNull, length) {\n            var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n            var u8array = new Array(len);\n            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n            if (dontAddNull) u8array.length = numBytesWritten;\n            return u8array;\n        }\n        var TTY = {\n            ttys: [],\n            init: function() {},\n            shutdown: function() {},\n            register: function(dev, ops) {\n                TTY.ttys[dev] = {\n                    input: [],\n                    output: [],\n                    ops: ops\n                };\n                FS.registerDevice(dev, TTY.stream_ops);\n            },\n            stream_ops: {\n                open: function(stream) {\n                    var tty = TTY.ttys[stream.node.rdev];\n                    if (!tty) throw new FS.ErrnoError(43);\n                    stream.tty = tty;\n                    stream.seekable = false;\n                },\n                close: function(stream) {\n                    stream.tty.ops.fsync(stream.tty);\n                },\n                fsync: function(stream) {\n                    stream.tty.ops.fsync(stream.tty);\n                },\n                read: function(stream, buffer, offset, length, pos) {\n                    if (!stream.tty || !stream.tty.ops.get_char) throw new FS.ErrnoError(60);\n                    var bytesRead = 0;\n                    for(var i = 0; i < length; i++){\n                        var result;\n                        try {\n                            result = stream.tty.ops.get_char(stream.tty);\n                        } catch (e) {\n                            throw new FS.ErrnoError(29);\n                        }\n                        if (result === undefined && bytesRead === 0) throw new FS.ErrnoError(6);\n                        if (result === null || result === undefined) break;\n                        bytesRead++;\n                        buffer[offset + i] = result;\n                    }\n                    if (bytesRead) stream.node.timestamp = Date.now();\n                    return bytesRead;\n                },\n                write: function(stream, buffer, offset, length, pos) {\n                    if (!stream.tty || !stream.tty.ops.put_char) throw new FS.ErrnoError(60);\n                    try {\n                        for(var i = 0; i < length; i++)stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n                    } catch (e) {\n                        throw new FS.ErrnoError(29);\n                    }\n                    if (length) stream.node.timestamp = Date.now();\n                    return i;\n                }\n            },\n            default_tty_ops: {\n                get_char: function(tty) {\n                    if (!tty.input.length) {\n                        var result = null;\n                        if (typeof window != \"undefined\" && typeof window.prompt == \"function\") {\n                            result = window.prompt(\"Input: \");\n                            if (result !== null) result += \"\\n\";\n                        } else if (typeof readline == \"function\") {\n                            result = readline();\n                            if (result !== null) result += \"\\n\";\n                        }\n                        if (!result) return null;\n                        tty.input = intArrayFromString(result, true);\n                    }\n                    return tty.input.shift();\n                },\n                put_char: function(tty, val) {\n                    if (val === null || val === 10) {\n                        out(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    } else if (val != 0) tty.output.push(val);\n                },\n                fsync: function(tty) {\n                    if (tty.output && tty.output.length > 0) {\n                        out(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    }\n                }\n            },\n            default_tty1_ops: {\n                put_char: function(tty, val) {\n                    if (val === null || val === 10) {\n                        err(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    } else if (val != 0) tty.output.push(val);\n                },\n                fsync: function(tty) {\n                    if (tty.output && tty.output.length > 0) {\n                        err(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    }\n                }\n            }\n        };\n        function alignMemory(size, alignment) {\n            assert(alignment, \"alignment argument is required\");\n            return Math.ceil(size / alignment) * alignment;\n        }\n        function mmapAlloc(size) {\n            abort(\"internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported\");\n        }\n        var MEMFS = {\n            ops_table: null,\n            mount: function(mount) {\n                return MEMFS.createNode(null, \"/\", 16895, 0);\n            },\n            createNode: function(parent, name, mode, dev) {\n                if (FS.isBlkdev(mode) || FS.isFIFO(mode)) throw new FS.ErrnoError(63);\n                if (!MEMFS.ops_table) MEMFS.ops_table = {\n                    dir: {\n                        node: {\n                            getattr: MEMFS.node_ops.getattr,\n                            setattr: MEMFS.node_ops.setattr,\n                            lookup: MEMFS.node_ops.lookup,\n                            mknod: MEMFS.node_ops.mknod,\n                            rename: MEMFS.node_ops.rename,\n                            unlink: MEMFS.node_ops.unlink,\n                            rmdir: MEMFS.node_ops.rmdir,\n                            readdir: MEMFS.node_ops.readdir,\n                            symlink: MEMFS.node_ops.symlink\n                        },\n                        stream: {\n                            llseek: MEMFS.stream_ops.llseek\n                        }\n                    },\n                    file: {\n                        node: {\n                            getattr: MEMFS.node_ops.getattr,\n                            setattr: MEMFS.node_ops.setattr\n                        },\n                        stream: {\n                            llseek: MEMFS.stream_ops.llseek,\n                            read: MEMFS.stream_ops.read,\n                            write: MEMFS.stream_ops.write,\n                            allocate: MEMFS.stream_ops.allocate,\n                            mmap: MEMFS.stream_ops.mmap,\n                            msync: MEMFS.stream_ops.msync\n                        }\n                    },\n                    link: {\n                        node: {\n                            getattr: MEMFS.node_ops.getattr,\n                            setattr: MEMFS.node_ops.setattr,\n                            readlink: MEMFS.node_ops.readlink\n                        },\n                        stream: {}\n                    },\n                    chrdev: {\n                        node: {\n                            getattr: MEMFS.node_ops.getattr,\n                            setattr: MEMFS.node_ops.setattr\n                        },\n                        stream: FS.chrdev_stream_ops\n                    }\n                };\n                var node = FS.createNode(parent, name, mode, dev);\n                if (FS.isDir(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.dir.node;\n                    node.stream_ops = MEMFS.ops_table.dir.stream;\n                    node.contents = {};\n                } else if (FS.isFile(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.file.node;\n                    node.stream_ops = MEMFS.ops_table.file.stream;\n                    node.usedBytes = 0;\n                    node.contents = null;\n                } else if (FS.isLink(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.link.node;\n                    node.stream_ops = MEMFS.ops_table.link.stream;\n                } else if (FS.isChrdev(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.chrdev.node;\n                    node.stream_ops = MEMFS.ops_table.chrdev.stream;\n                }\n                node.timestamp = Date.now();\n                if (parent) {\n                    parent.contents[name] = node;\n                    parent.timestamp = node.timestamp;\n                }\n                return node;\n            },\n            getFileDataAsTypedArray: function(node) {\n                if (!node.contents) return new Uint8Array(0);\n                if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\n                return new Uint8Array(node.contents);\n            },\n            expandFileStorage: function(node, newCapacity) {\n                var prevCapacity = node.contents ? node.contents.length : 0;\n                if (prevCapacity >= newCapacity) return;\n                var CAPACITY_DOUBLING_MAX = 1048576;\n                newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);\n                if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n                var oldContents = node.contents;\n                node.contents = new Uint8Array(newCapacity);\n                if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n            },\n            resizeFileStorage: function(node, newSize) {\n                if (node.usedBytes == newSize) return;\n                if (newSize == 0) {\n                    node.contents = null;\n                    node.usedBytes = 0;\n                } else {\n                    var oldContents = node.contents;\n                    node.contents = new Uint8Array(newSize);\n                    if (oldContents) node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n                    node.usedBytes = newSize;\n                }\n            },\n            node_ops: {\n                getattr: function(node) {\n                    var attr = {};\n                    attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n                    attr.ino = node.id;\n                    attr.mode = node.mode;\n                    attr.nlink = 1;\n                    attr.uid = 0;\n                    attr.gid = 0;\n                    attr.rdev = node.rdev;\n                    if (FS.isDir(node.mode)) attr.size = 4096;\n                    else if (FS.isFile(node.mode)) attr.size = node.usedBytes;\n                    else if (FS.isLink(node.mode)) attr.size = node.link.length;\n                    else attr.size = 0;\n                    attr.atime = new Date(node.timestamp);\n                    attr.mtime = new Date(node.timestamp);\n                    attr.ctime = new Date(node.timestamp);\n                    attr.blksize = 4096;\n                    attr.blocks = Math.ceil(attr.size / attr.blksize);\n                    return attr;\n                },\n                setattr: function(node, attr) {\n                    if (attr.mode !== undefined) node.mode = attr.mode;\n                    if (attr.timestamp !== undefined) node.timestamp = attr.timestamp;\n                    if (attr.size !== undefined) MEMFS.resizeFileStorage(node, attr.size);\n                },\n                lookup: function(parent, name) {\n                    throw FS.genericErrors[44];\n                },\n                mknod: function(parent, name, mode, dev) {\n                    return MEMFS.createNode(parent, name, mode, dev);\n                },\n                rename: function(old_node, new_dir, new_name) {\n                    if (FS.isDir(old_node.mode)) {\n                        var new_node;\n                        try {\n                            new_node = FS.lookupNode(new_dir, new_name);\n                        } catch (e) {}\n                        if (new_node) {\n                            for(var i in new_node.contents)throw new FS.ErrnoError(55);\n                        }\n                    }\n                    delete old_node.parent.contents[old_node.name];\n                    old_node.parent.timestamp = Date.now();\n                    old_node.name = new_name;\n                    new_dir.contents[new_name] = old_node;\n                    new_dir.timestamp = old_node.parent.timestamp;\n                    old_node.parent = new_dir;\n                },\n                unlink: function(parent, name) {\n                    delete parent.contents[name];\n                    parent.timestamp = Date.now();\n                },\n                rmdir: function(parent, name) {\n                    var node = FS.lookupNode(parent, name);\n                    for(var i in node.contents)throw new FS.ErrnoError(55);\n                    delete parent.contents[name];\n                    parent.timestamp = Date.now();\n                },\n                readdir: function(node) {\n                    var entries = [\n                        \".\",\n                        \"..\"\n                    ];\n                    for(var key in node.contents){\n                        if (!node.contents.hasOwnProperty(key)) continue;\n                        entries.push(key);\n                    }\n                    return entries;\n                },\n                symlink: function(parent, newname, oldpath) {\n                    var node = MEMFS.createNode(parent, newname, 41471, 0);\n                    node.link = oldpath;\n                    return node;\n                },\n                readlink: function(node) {\n                    if (!FS.isLink(node.mode)) throw new FS.ErrnoError(28);\n                    return node.link;\n                }\n            },\n            stream_ops: {\n                read: function(stream, buffer, offset, length, position) {\n                    var contents = stream.node.contents;\n                    if (position >= stream.node.usedBytes) return 0;\n                    var size = Math.min(stream.node.usedBytes - position, length);\n                    assert(size >= 0);\n                    if (size > 8 && contents.subarray) buffer.set(contents.subarray(position, position + size), offset);\n                    else for(var i = 0; i < size; i++)buffer[offset + i] = contents[position + i];\n                    return size;\n                },\n                write: function(stream, buffer, offset, length, position, canOwn) {\n                    assert(!(buffer instanceof ArrayBuffer));\n                    if (buffer.buffer === GROWABLE_HEAP_I8().buffer) canOwn = false;\n                    if (!length) return 0;\n                    var node = stream.node;\n                    node.timestamp = Date.now();\n                    if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n                        if (canOwn) {\n                            assert(position === 0, \"canOwn must imply no weird position inside the file\");\n                            node.contents = buffer.subarray(offset, offset + length);\n                            node.usedBytes = length;\n                            return length;\n                        } else if (node.usedBytes === 0 && position === 0) {\n                            node.contents = buffer.slice(offset, offset + length);\n                            node.usedBytes = length;\n                            return length;\n                        } else if (position + length <= node.usedBytes) {\n                            node.contents.set(buffer.subarray(offset, offset + length), position);\n                            return length;\n                        }\n                    }\n                    MEMFS.expandFileStorage(node, position + length);\n                    if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position);\n                    else for(var i = 0; i < length; i++)node.contents[position + i] = buffer[offset + i];\n                    node.usedBytes = Math.max(node.usedBytes, position + length);\n                    return length;\n                },\n                llseek: function(stream, offset, whence) {\n                    var position = offset;\n                    if (whence === 1) position += stream.position;\n                    else if (whence === 2) {\n                        if (FS.isFile(stream.node.mode)) position += stream.node.usedBytes;\n                    }\n                    if (position < 0) throw new FS.ErrnoError(28);\n                    return position;\n                },\n                allocate: function(stream, offset, length) {\n                    MEMFS.expandFileStorage(stream.node, offset + length);\n                    stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n                },\n                mmap: function(stream, length, position, prot, flags) {\n                    if (!FS.isFile(stream.node.mode)) throw new FS.ErrnoError(43);\n                    var ptr;\n                    var allocated;\n                    var contents = stream.node.contents;\n                    if (!(flags & 2) && contents.buffer === GROWABLE_HEAP_I8().buffer) {\n                        allocated = false;\n                        ptr = contents.byteOffset;\n                    } else {\n                        if (position > 0 || position + length < contents.length) {\n                            if (contents.subarray) contents = contents.subarray(position, position + length);\n                            else contents = Array.prototype.slice.call(contents, position, position + length);\n                        }\n                        allocated = true;\n                        ptr = mmapAlloc(length);\n                        if (!ptr) throw new FS.ErrnoError(48);\n                        GROWABLE_HEAP_I8().set(contents, ptr);\n                    }\n                    return {\n                        ptr: ptr,\n                        allocated: allocated\n                    };\n                },\n                msync: function(stream, buffer, offset, length, mmapFlags) {\n                    MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n                    return 0;\n                }\n            }\n        };\n        function asyncLoad(url, onload, onerror, noRunDep) {\n            var dep = !noRunDep ? getUniqueRunDependency(\"al \" + url) : \"\";\n            readAsync(url, (arrayBuffer)=>{\n                assert(arrayBuffer, 'Loading data file \"' + url + '\" failed (no arrayBuffer).');\n                onload(new Uint8Array(arrayBuffer));\n                if (dep) removeRunDependency(dep);\n            }, (event)=>{\n                if (onerror) onerror();\n                else throw 'Loading data file \"' + url + '\" failed.';\n            });\n            if (dep) addRunDependency(dep);\n        }\n        var ERRNO_MESSAGES = {\n            0: \"Success\",\n            1: \"Arg list too long\",\n            2: \"Permission denied\",\n            3: \"Address already in use\",\n            4: \"Address not available\",\n            5: \"Address family not supported by protocol family\",\n            6: \"No more processes\",\n            7: \"Socket already connected\",\n            8: \"Bad file number\",\n            9: \"Trying to read unreadable message\",\n            10: \"Mount device busy\",\n            11: \"Operation canceled\",\n            12: \"No children\",\n            13: \"Connection aborted\",\n            14: \"Connection refused\",\n            15: \"Connection reset by peer\",\n            16: \"File locking deadlock error\",\n            17: \"Destination address required\",\n            18: \"Math arg out of domain of func\",\n            19: \"Quota exceeded\",\n            20: \"File exists\",\n            21: \"Bad address\",\n            22: \"File too large\",\n            23: \"Host is unreachable\",\n            24: \"Identifier removed\",\n            25: \"Illegal byte sequence\",\n            26: \"Connection already in progress\",\n            27: \"Interrupted system call\",\n            28: \"Invalid argument\",\n            29: \"I/O error\",\n            30: \"Socket is already connected\",\n            31: \"Is a directory\",\n            32: \"Too many symbolic links\",\n            33: \"Too many open files\",\n            34: \"Too many links\",\n            35: \"Message too long\",\n            36: \"Multihop attempted\",\n            37: \"File or path name too long\",\n            38: \"Network interface is not configured\",\n            39: \"Connection reset by network\",\n            40: \"Network is unreachable\",\n            41: \"Too many open files in system\",\n            42: \"No buffer space available\",\n            43: \"No such device\",\n            44: \"No such file or directory\",\n            45: \"Exec format error\",\n            46: \"No record locks available\",\n            47: \"The link has been severed\",\n            48: \"Not enough core\",\n            49: \"No message of desired type\",\n            50: \"Protocol not available\",\n            51: \"No space left on device\",\n            52: \"Function not implemented\",\n            53: \"Socket is not connected\",\n            54: \"Not a directory\",\n            55: \"Directory not empty\",\n            56: \"State not recoverable\",\n            57: \"Socket operation on non-socket\",\n            59: \"Not a typewriter\",\n            60: \"No such device or address\",\n            61: \"Value too large for defined data type\",\n            62: \"Previous owner died\",\n            63: \"Not super-user\",\n            64: \"Broken pipe\",\n            65: \"Protocol error\",\n            66: \"Unknown protocol\",\n            67: \"Protocol wrong type for socket\",\n            68: \"Math result not representable\",\n            69: \"Read only file system\",\n            70: \"Illegal seek\",\n            71: \"No such process\",\n            72: \"Stale file handle\",\n            73: \"Connection timed out\",\n            74: \"Text file busy\",\n            75: \"Cross-device link\",\n            100: \"Device not a stream\",\n            101: \"Bad font file fmt\",\n            102: \"Invalid slot\",\n            103: \"Invalid request code\",\n            104: \"No anode\",\n            105: \"Block device required\",\n            106: \"Channel number out of range\",\n            107: \"Level 3 halted\",\n            108: \"Level 3 reset\",\n            109: \"Link number out of range\",\n            110: \"Protocol driver not attached\",\n            111: \"No CSI structure available\",\n            112: \"Level 2 halted\",\n            113: \"Invalid exchange\",\n            114: \"Invalid request descriptor\",\n            115: \"Exchange full\",\n            116: \"No data (for no delay io)\",\n            117: \"Timer expired\",\n            118: \"Out of streams resources\",\n            119: \"Machine is not on the network\",\n            120: \"Package not installed\",\n            121: \"The object is remote\",\n            122: \"Advertise error\",\n            123: \"Srmount error\",\n            124: \"Communication error on send\",\n            125: \"Cross mount point (not really error)\",\n            126: \"Given log. name not unique\",\n            127: \"f.d. invalid for this operation\",\n            128: \"Remote address changed\",\n            129: \"Can   access a needed shared lib\",\n            130: \"Accessing a corrupted shared lib\",\n            131: \".lib section in a.out corrupted\",\n            132: \"Attempting to link in too many libs\",\n            133: \"Attempting to exec a shared library\",\n            135: \"Streams pipe error\",\n            136: \"Too many users\",\n            137: \"Socket type not supported\",\n            138: \"Not supported\",\n            139: \"Protocol family not supported\",\n            140: \"Can't send after socket shutdown\",\n            141: \"Too many references\",\n            142: \"Host is down\",\n            148: \"No medium (in tape drive)\",\n            156: \"Level 2 not synchronized\"\n        };\n        var ERRNO_CODES = {};\n        function demangle(func) {\n            warnOnce(\"warning: build with -sDEMANGLE_SUPPORT to link in libcxxabi demangling\");\n            return func;\n        }\n        function demangleAll(text) {\n            var regex = /\\b_Z[\\w\\d_]+/g;\n            return text.replace(regex, function(x) {\n                var y = demangle(x);\n                return x === y ? x : y + \" [\" + x + \"]\";\n            });\n        }\n        var FS = {\n            root: null,\n            mounts: [],\n            devices: {},\n            streams: [],\n            nextInode: 1,\n            nameTable: null,\n            currentPath: \"/\",\n            initialized: false,\n            ignorePermissions: true,\n            ErrnoError: null,\n            genericErrors: {},\n            filesystems: null,\n            syncFSRequests: 0,\n            lookupPath: (path, opts = {})=>{\n                path = PATH_FS.resolve(path);\n                if (!path) return {\n                    path: \"\",\n                    node: null\n                };\n                var defaults = {\n                    follow_mount: true,\n                    recurse_count: 0\n                };\n                opts = Object.assign(defaults, opts);\n                if (opts.recurse_count > 8) throw new FS.ErrnoError(32);\n                var parts = path.split(\"/\").filter((p)=>!!p);\n                var current = FS.root;\n                var current_path = \"/\";\n                for(var i = 0; i < parts.length; i++){\n                    var islast = i === parts.length - 1;\n                    if (islast && opts.parent) break;\n                    current = FS.lookupNode(current, parts[i]);\n                    current_path = PATH.join2(current_path, parts[i]);\n                    if (FS.isMountpoint(current)) {\n                        if (!islast || islast && opts.follow_mount) current = current.mounted.root;\n                    }\n                    if (!islast || opts.follow) {\n                        var count = 0;\n                        while(FS.isLink(current.mode)){\n                            var link = FS.readlink(current_path);\n                            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n                            var lookup = FS.lookupPath(current_path, {\n                                recurse_count: opts.recurse_count + 1\n                            });\n                            current = lookup.node;\n                            if (count++ > 40) throw new FS.ErrnoError(32);\n                        }\n                    }\n                }\n                return {\n                    path: current_path,\n                    node: current\n                };\n            },\n            getPath: (node)=>{\n                var path;\n                while(true){\n                    if (FS.isRoot(node)) {\n                        var mount = node.mount.mountpoint;\n                        if (!path) return mount;\n                        return mount[mount.length - 1] !== \"/\" ? mount + \"/\" + path : mount + path;\n                    }\n                    path = path ? node.name + \"/\" + path : node.name;\n                    node = node.parent;\n                }\n            },\n            hashName: (parentid, name)=>{\n                var hash = 0;\n                for(var i = 0; i < name.length; i++)hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n                return (parentid + hash >>> 0) % FS.nameTable.length;\n            },\n            hashAddNode: (node)=>{\n                var hash = FS.hashName(node.parent.id, node.name);\n                node.name_next = FS.nameTable[hash];\n                FS.nameTable[hash] = node;\n            },\n            hashRemoveNode: (node)=>{\n                var hash = FS.hashName(node.parent.id, node.name);\n                if (FS.nameTable[hash] === node) FS.nameTable[hash] = node.name_next;\n                else {\n                    var current = FS.nameTable[hash];\n                    while(current){\n                        if (current.name_next === node) {\n                            current.name_next = node.name_next;\n                            break;\n                        }\n                        current = current.name_next;\n                    }\n                }\n            },\n            lookupNode: (parent, name)=>{\n                var errCode = FS.mayLookup(parent);\n                if (errCode) throw new FS.ErrnoError(errCode, parent);\n                var hash = FS.hashName(parent.id, name);\n                for(var node = FS.nameTable[hash]; node; node = node.name_next){\n                    var nodeName = node.name;\n                    if (node.parent.id === parent.id && nodeName === name) return node;\n                }\n                return FS.lookup(parent, name);\n            },\n            createNode: (parent, name, mode, rdev)=>{\n                assert(typeof parent == \"object\");\n                var node = new FS.FSNode(parent, name, mode, rdev);\n                FS.hashAddNode(node);\n                return node;\n            },\n            destroyNode: (node)=>{\n                FS.hashRemoveNode(node);\n            },\n            isRoot: (node)=>{\n                return node === node.parent;\n            },\n            isMountpoint: (node)=>{\n                return !!node.mounted;\n            },\n            isFile: (mode)=>{\n                return (mode & 61440) === 32768;\n            },\n            isDir: (mode)=>{\n                return (mode & 61440) === 16384;\n            },\n            isLink: (mode)=>{\n                return (mode & 61440) === 40960;\n            },\n            isChrdev: (mode)=>{\n                return (mode & 61440) === 8192;\n            },\n            isBlkdev: (mode)=>{\n                return (mode & 61440) === 24576;\n            },\n            isFIFO: (mode)=>{\n                return (mode & 61440) === 4096;\n            },\n            isSocket: (mode)=>{\n                return (mode & 49152) === 49152;\n            },\n            flagModes: {\n                \"r\": 0,\n                \"r+\": 2,\n                \"w\": 577,\n                \"w+\": 578,\n                \"a\": 1089,\n                \"a+\": 1090\n            },\n            modeStringToFlags: (str)=>{\n                var flags = FS.flagModes[str];\n                if (typeof flags == \"undefined\") throw new Error(\"Unknown file open mode: \" + str);\n                return flags;\n            },\n            flagsToPermissionString: (flag)=>{\n                var perms = [\n                    \"r\",\n                    \"w\",\n                    \"rw\"\n                ][flag & 3];\n                if (flag & 512) perms += \"w\";\n                return perms;\n            },\n            nodePermissions: (node, perms)=>{\n                if (FS.ignorePermissions) return 0;\n                if (perms.includes(\"r\") && !(node.mode & 292)) return 2;\n                else if (perms.includes(\"w\") && !(node.mode & 146)) return 2;\n                else if (perms.includes(\"x\") && !(node.mode & 73)) return 2;\n                return 0;\n            },\n            mayLookup: (dir)=>{\n                var errCode = FS.nodePermissions(dir, \"x\");\n                if (errCode) return errCode;\n                if (!dir.node_ops.lookup) return 2;\n                return 0;\n            },\n            mayCreate: (dir, name)=>{\n                try {\n                    var node = FS.lookupNode(dir, name);\n                    return 20;\n                } catch (e) {}\n                return FS.nodePermissions(dir, \"wx\");\n            },\n            mayDelete: (dir, name, isdir)=>{\n                var node;\n                try {\n                    node = FS.lookupNode(dir, name);\n                } catch (e) {\n                    return e.errno;\n                }\n                var errCode = FS.nodePermissions(dir, \"wx\");\n                if (errCode) return errCode;\n                if (isdir) {\n                    if (!FS.isDir(node.mode)) return 54;\n                    if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) return 10;\n                } else {\n                    if (FS.isDir(node.mode)) return 31;\n                }\n                return 0;\n            },\n            mayOpen: (node, flags)=>{\n                if (!node) return 44;\n                if (FS.isLink(node.mode)) return 32;\n                else if (FS.isDir(node.mode)) {\n                    if (FS.flagsToPermissionString(flags) !== \"r\" || flags & 512) return 31;\n                }\n                return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n            },\n            MAX_OPEN_FDS: 4096,\n            nextfd: (fd_start = 0, fd_end = FS.MAX_OPEN_FDS)=>{\n                for(var fd = fd_start; fd <= fd_end; fd++){\n                    if (!FS.streams[fd]) return fd;\n                }\n                throw new FS.ErrnoError(33);\n            },\n            getStream: (fd)=>FS.streams[fd],\n            createStream: (stream, fd_start, fd_end)=>{\n                if (!FS.FSStream) {\n                    FS.FSStream = function() {\n                        this.shared = {};\n                    };\n                    FS.FSStream.prototype = {};\n                    Object.defineProperties(FS.FSStream.prototype, {\n                        object: {\n                            get: function() {\n                                return this.node;\n                            },\n                            set: function(val) {\n                                this.node = val;\n                            }\n                        },\n                        isRead: {\n                            get: function() {\n                                return (this.flags & 2097155) !== 1;\n                            }\n                        },\n                        isWrite: {\n                            get: function() {\n                                return (this.flags & 2097155) !== 0;\n                            }\n                        },\n                        isAppend: {\n                            get: function() {\n                                return this.flags & 1024;\n                            }\n                        },\n                        flags: {\n                            get: function() {\n                                return this.shared.flags;\n                            },\n                            set: function(val) {\n                                this.shared.flags = val;\n                            }\n                        },\n                        position: {\n                            get: function() {\n                                return this.shared.position;\n                            },\n                            set: function(val) {\n                                this.shared.position = val;\n                            }\n                        }\n                    });\n                }\n                stream = Object.assign(new FS.FSStream(), stream);\n                var fd = FS.nextfd(fd_start, fd_end);\n                stream.fd = fd;\n                FS.streams[fd] = stream;\n                return stream;\n            },\n            closeStream: (fd)=>{\n                FS.streams[fd] = null;\n            },\n            chrdev_stream_ops: {\n                open: (stream)=>{\n                    var device = FS.getDevice(stream.node.rdev);\n                    stream.stream_ops = device.stream_ops;\n                    if (stream.stream_ops.open) stream.stream_ops.open(stream);\n                },\n                llseek: ()=>{\n                    throw new FS.ErrnoError(70);\n                }\n            },\n            major: (dev)=>dev >> 8,\n            minor: (dev)=>dev & 255,\n            makedev: (ma, mi)=>ma << 8 | mi,\n            registerDevice: (dev, ops)=>{\n                FS.devices[dev] = {\n                    stream_ops: ops\n                };\n            },\n            getDevice: (dev)=>FS.devices[dev],\n            getMounts: (mount)=>{\n                var mounts = [];\n                var check = [\n                    mount\n                ];\n                while(check.length){\n                    var m = check.pop();\n                    mounts.push(m);\n                    check.push.apply(check, m.mounts);\n                }\n                return mounts;\n            },\n            syncfs: (populate, callback)=>{\n                if (typeof populate == \"function\") {\n                    callback = populate;\n                    populate = false;\n                }\n                FS.syncFSRequests++;\n                if (FS.syncFSRequests > 1) err(\"warning: \" + FS.syncFSRequests + \" FS.syncfs operations in flight at once, probably just doing extra work\");\n                var mounts = FS.getMounts(FS.root.mount);\n                var completed = 0;\n                function doCallback(errCode) {\n                    assert(FS.syncFSRequests > 0);\n                    FS.syncFSRequests--;\n                    return callback(errCode);\n                }\n                function done(errCode) {\n                    if (errCode) {\n                        if (!done.errored) {\n                            done.errored = true;\n                            return doCallback(errCode);\n                        }\n                        return;\n                    }\n                    if (++completed >= mounts.length) doCallback(null);\n                }\n                mounts.forEach((mount)=>{\n                    if (!mount.type.syncfs) return done(null);\n                    mount.type.syncfs(mount, populate, done);\n                });\n            },\n            mount: (type, opts, mountpoint)=>{\n                if (typeof type == \"string\") throw type;\n                var root = mountpoint === \"/\";\n                var pseudo = !mountpoint;\n                var node;\n                if (root && FS.root) throw new FS.ErrnoError(10);\n                else if (!root && !pseudo) {\n                    var lookup = FS.lookupPath(mountpoint, {\n                        follow_mount: false\n                    });\n                    mountpoint = lookup.path;\n                    node = lookup.node;\n                    if (FS.isMountpoint(node)) throw new FS.ErrnoError(10);\n                    if (!FS.isDir(node.mode)) throw new FS.ErrnoError(54);\n                }\n                var mount = {\n                    type: type,\n                    opts: opts,\n                    mountpoint: mountpoint,\n                    mounts: []\n                };\n                var mountRoot = type.mount(mount);\n                mountRoot.mount = mount;\n                mount.root = mountRoot;\n                if (root) FS.root = mountRoot;\n                else if (node) {\n                    node.mounted = mount;\n                    if (node.mount) node.mount.mounts.push(mount);\n                }\n                return mountRoot;\n            },\n            unmount: (mountpoint)=>{\n                var lookup = FS.lookupPath(mountpoint, {\n                    follow_mount: false\n                });\n                if (!FS.isMountpoint(lookup.node)) throw new FS.ErrnoError(28);\n                var node = lookup.node;\n                var mount = node.mounted;\n                var mounts = FS.getMounts(mount);\n                Object.keys(FS.nameTable).forEach((hash)=>{\n                    var current = FS.nameTable[hash];\n                    while(current){\n                        var next = current.name_next;\n                        if (mounts.includes(current.mount)) FS.destroyNode(current);\n                        current = next;\n                    }\n                });\n                node.mounted = null;\n                var idx = node.mount.mounts.indexOf(mount);\n                assert(idx !== -1);\n                node.mount.mounts.splice(idx, 1);\n            },\n            lookup: (parent, name)=>{\n                return parent.node_ops.lookup(parent, name);\n            },\n            mknod: (path, mode, dev)=>{\n                var lookup = FS.lookupPath(path, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                var name = PATH.basename(path);\n                if (!name || name === \".\" || name === \"..\") throw new FS.ErrnoError(28);\n                var errCode = FS.mayCreate(parent, name);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                if (!parent.node_ops.mknod) throw new FS.ErrnoError(63);\n                return parent.node_ops.mknod(parent, name, mode, dev);\n            },\n            create: (path, mode)=>{\n                mode = mode !== undefined ? mode : 438;\n                mode &= 4095;\n                mode |= 32768;\n                return FS.mknod(path, mode, 0);\n            },\n            mkdir: (path, mode)=>{\n                mode = mode !== undefined ? mode : 511;\n                mode &= 1023;\n                mode |= 16384;\n                return FS.mknod(path, mode, 0);\n            },\n            mkdirTree: (path, mode)=>{\n                var dirs = path.split(\"/\");\n                var d = \"\";\n                for(var i = 0; i < dirs.length; ++i){\n                    if (!dirs[i]) continue;\n                    d += \"/\" + dirs[i];\n                    try {\n                        FS.mkdir(d, mode);\n                    } catch (e) {\n                        if (e.errno != 20) throw e;\n                    }\n                }\n            },\n            mkdev: (path, mode, dev)=>{\n                if (typeof dev == \"undefined\") {\n                    dev = mode;\n                    mode = 438;\n                }\n                mode |= 8192;\n                return FS.mknod(path, mode, dev);\n            },\n            symlink: (oldpath, newpath)=>{\n                if (!PATH_FS.resolve(oldpath)) throw new FS.ErrnoError(44);\n                var lookup = FS.lookupPath(newpath, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                if (!parent) throw new FS.ErrnoError(44);\n                var newname = PATH.basename(newpath);\n                var errCode = FS.mayCreate(parent, newname);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                if (!parent.node_ops.symlink) throw new FS.ErrnoError(63);\n                return parent.node_ops.symlink(parent, newname, oldpath);\n            },\n            rename: (old_path, new_path)=>{\n                var old_dirname = PATH.dirname(old_path);\n                var new_dirname = PATH.dirname(new_path);\n                var old_name = PATH.basename(old_path);\n                var new_name = PATH.basename(new_path);\n                var lookup, old_dir, new_dir;\n                lookup = FS.lookupPath(old_path, {\n                    parent: true\n                });\n                old_dir = lookup.node;\n                lookup = FS.lookupPath(new_path, {\n                    parent: true\n                });\n                new_dir = lookup.node;\n                if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n                if (old_dir.mount !== new_dir.mount) throw new FS.ErrnoError(75);\n                var old_node = FS.lookupNode(old_dir, old_name);\n                var relative = PATH_FS.relative(old_path, new_dirname);\n                if (relative.charAt(0) !== \".\") throw new FS.ErrnoError(28);\n                relative = PATH_FS.relative(new_path, old_dirname);\n                if (relative.charAt(0) !== \".\") throw new FS.ErrnoError(55);\n                var new_node;\n                try {\n                    new_node = FS.lookupNode(new_dir, new_name);\n                } catch (e) {}\n                if (old_node === new_node) return;\n                var isdir = FS.isDir(old_node.mode);\n                var errCode = FS.mayDelete(old_dir, old_name, isdir);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                if (!old_dir.node_ops.rename) throw new FS.ErrnoError(63);\n                if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) throw new FS.ErrnoError(10);\n                if (new_dir !== old_dir) {\n                    errCode = FS.nodePermissions(old_dir, \"w\");\n                    if (errCode) throw new FS.ErrnoError(errCode);\n                }\n                FS.hashRemoveNode(old_node);\n                try {\n                    old_dir.node_ops.rename(old_node, new_dir, new_name);\n                } catch (e) {\n                    throw e;\n                } finally{\n                    FS.hashAddNode(old_node);\n                }\n            },\n            rmdir: (path)=>{\n                var lookup = FS.lookupPath(path, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                var name = PATH.basename(path);\n                var node = FS.lookupNode(parent, name);\n                var errCode = FS.mayDelete(parent, name, true);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                if (!parent.node_ops.rmdir) throw new FS.ErrnoError(63);\n                if (FS.isMountpoint(node)) throw new FS.ErrnoError(10);\n                parent.node_ops.rmdir(parent, name);\n                FS.destroyNode(node);\n            },\n            readdir: (path)=>{\n                var lookup = FS.lookupPath(path, {\n                    follow: true\n                });\n                var node = lookup.node;\n                if (!node.node_ops.readdir) throw new FS.ErrnoError(54);\n                return node.node_ops.readdir(node);\n            },\n            unlink: (path)=>{\n                var lookup = FS.lookupPath(path, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                if (!parent) throw new FS.ErrnoError(44);\n                var name = PATH.basename(path);\n                var node = FS.lookupNode(parent, name);\n                var errCode = FS.mayDelete(parent, name, false);\n                if (errCode) throw new FS.ErrnoError(errCode);\n                if (!parent.node_ops.unlink) throw new FS.ErrnoError(63);\n                if (FS.isMountpoint(node)) throw new FS.ErrnoError(10);\n                parent.node_ops.unlink(parent, name);\n                FS.destroyNode(node);\n            },\n            readlink: (path)=>{\n                var lookup = FS.lookupPath(path);\n                var link = lookup.node;\n                if (!link) throw new FS.ErrnoError(44);\n                if (!link.node_ops.readlink) throw new FS.ErrnoError(28);\n                return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n            },\n            stat: (path, dontFollow)=>{\n                var lookup = FS.lookupPath(path, {\n                    follow: !dontFollow\n                });\n                var node = lookup.node;\n                if (!node) throw new FS.ErrnoError(44);\n                if (!node.node_ops.getattr) throw new FS.ErrnoError(63);\n                return node.node_ops.getattr(node);\n            },\n            lstat: (path)=>{\n                return FS.stat(path, true);\n            },\n            chmod: (path, mode, dontFollow)=>{\n                var node;\n                if (typeof path == \"string\") {\n                    var lookup = FS.lookupPath(path, {\n                        follow: !dontFollow\n                    });\n                    node = lookup.node;\n                } else node = path;\n                if (!node.node_ops.setattr) throw new FS.ErrnoError(63);\n                node.node_ops.setattr(node, {\n                    mode: mode & 4095 | node.mode & -4096,\n                    timestamp: Date.now()\n                });\n            },\n            lchmod: (path, mode)=>{\n                FS.chmod(path, mode, true);\n            },\n            fchmod: (fd, mode)=>{\n                var stream = FS.getStream(fd);\n                if (!stream) throw new FS.ErrnoError(8);\n                FS.chmod(stream.node, mode);\n            },\n            chown: (path, uid, gid, dontFollow)=>{\n                var node;\n                if (typeof path == \"string\") {\n                    var lookup = FS.lookupPath(path, {\n                        follow: !dontFollow\n                    });\n                    node = lookup.node;\n                } else node = path;\n                if (!node.node_ops.setattr) throw new FS.ErrnoError(63);\n                node.node_ops.setattr(node, {\n                    timestamp: Date.now()\n                });\n            },\n            lchown: (path, uid, gid)=>{\n                FS.chown(path, uid, gid, true);\n            },\n            fchown: (fd, uid, gid)=>{\n                var stream = FS.getStream(fd);\n                if (!stream) throw new FS.ErrnoError(8);\n                FS.chown(stream.node, uid, gid);\n            },\n            truncate: (path, len)=>{\n                if (len < 0) throw new FS.ErrnoError(28);\n                var node;\n                if (typeof path == \"string\") {\n                    var lookup = FS.lookupPath(path, {\n                        follow: true\n                    });\n                    node = lookup.node;\n                } else node = path;\n                if (!node.node_ops.setattr) throw new FS.ErrnoError(63);\n                if (FS.isDir(node.mode)) throw new FS.ErrnoError(31);\n                if (!FS.isFile(node.mode)) throw new FS.ErrnoError(28);\n                var errCode = FS.nodePermissions(node, \"w\");\n                if (errCode) throw new FS.ErrnoError(errCode);\n                node.node_ops.setattr(node, {\n                    size: len,\n                    timestamp: Date.now()\n                });\n            },\n            ftruncate: (fd, len)=>{\n                var stream = FS.getStream(fd);\n                if (!stream) throw new FS.ErrnoError(8);\n                if ((stream.flags & 2097155) === 0) throw new FS.ErrnoError(28);\n                FS.truncate(stream.node, len);\n            },\n            utime: (path, atime, mtime)=>{\n                var lookup = FS.lookupPath(path, {\n                    follow: true\n                });\n                var node = lookup.node;\n                node.node_ops.setattr(node, {\n                    timestamp: Math.max(atime, mtime)\n                });\n            },\n            open: (path, flags, mode)=>{\n                if (path === \"\") throw new FS.ErrnoError(44);\n                flags = typeof flags == \"string\" ? FS.modeStringToFlags(flags) : flags;\n                mode = typeof mode == \"undefined\" ? 438 : mode;\n                if (flags & 64) mode = mode & 4095 | 32768;\n                else mode = 0;\n                var node;\n                if (typeof path == \"object\") node = path;\n                else {\n                    path = PATH.normalize(path);\n                    try {\n                        var lookup = FS.lookupPath(path, {\n                            follow: !(flags & 131072)\n                        });\n                        node = lookup.node;\n                    } catch (e) {}\n                }\n                var created = false;\n                if (flags & 64) {\n                    if (node) {\n                        if (flags & 128) throw new FS.ErrnoError(20);\n                    } else {\n                        node = FS.mknod(path, mode, 0);\n                        created = true;\n                    }\n                }\n                if (!node) throw new FS.ErrnoError(44);\n                if (FS.isChrdev(node.mode)) flags &= -513;\n                if (flags & 65536 && !FS.isDir(node.mode)) throw new FS.ErrnoError(54);\n                if (!created) {\n                    var errCode = FS.mayOpen(node, flags);\n                    if (errCode) throw new FS.ErrnoError(errCode);\n                }\n                if (flags & 512 && !created) FS.truncate(node, 0);\n                flags &= -131713;\n                var stream = FS.createStream({\n                    node: node,\n                    path: FS.getPath(node),\n                    flags: flags,\n                    seekable: true,\n                    position: 0,\n                    stream_ops: node.stream_ops,\n                    ungotten: [],\n                    error: false\n                });\n                if (stream.stream_ops.open) stream.stream_ops.open(stream);\n                if (Module[\"logReadFiles\"] && !(flags & 1)) {\n                    if (!FS.readFiles) FS.readFiles = {};\n                    if (!(path in FS.readFiles)) FS.readFiles[path] = 1;\n                }\n                return stream;\n            },\n            close: (stream)=>{\n                if (FS.isClosed(stream)) throw new FS.ErrnoError(8);\n                if (stream.getdents) stream.getdents = null;\n                try {\n                    if (stream.stream_ops.close) stream.stream_ops.close(stream);\n                } catch (e) {\n                    throw e;\n                } finally{\n                    FS.closeStream(stream.fd);\n                }\n                stream.fd = null;\n            },\n            isClosed: (stream)=>{\n                return stream.fd === null;\n            },\n            llseek: (stream, offset, whence)=>{\n                if (FS.isClosed(stream)) throw new FS.ErrnoError(8);\n                if (!stream.seekable || !stream.stream_ops.llseek) throw new FS.ErrnoError(70);\n                if (whence != 0 && whence != 1 && whence != 2) throw new FS.ErrnoError(28);\n                stream.position = stream.stream_ops.llseek(stream, offset, whence);\n                stream.ungotten = [];\n                return stream.position;\n            },\n            read: (stream, buffer, offset, length, position)=>{\n                if (length < 0 || position < 0) throw new FS.ErrnoError(28);\n                if (FS.isClosed(stream)) throw new FS.ErrnoError(8);\n                if ((stream.flags & 2097155) === 1) throw new FS.ErrnoError(8);\n                if (FS.isDir(stream.node.mode)) throw new FS.ErrnoError(31);\n                if (!stream.stream_ops.read) throw new FS.ErrnoError(28);\n                var seeking = typeof position != \"undefined\";\n                if (!seeking) position = stream.position;\n                else if (!stream.seekable) throw new FS.ErrnoError(70);\n                var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n                if (!seeking) stream.position += bytesRead;\n                return bytesRead;\n            },\n            write: (stream, buffer, offset, length, position, canOwn)=>{\n                if (length < 0 || position < 0) throw new FS.ErrnoError(28);\n                if (FS.isClosed(stream)) throw new FS.ErrnoError(8);\n                if ((stream.flags & 2097155) === 0) throw new FS.ErrnoError(8);\n                if (FS.isDir(stream.node.mode)) throw new FS.ErrnoError(31);\n                if (!stream.stream_ops.write) throw new FS.ErrnoError(28);\n                if (stream.seekable && stream.flags & 1024) FS.llseek(stream, 0, 2);\n                var seeking = typeof position != \"undefined\";\n                if (!seeking) position = stream.position;\n                else if (!stream.seekable) throw new FS.ErrnoError(70);\n                var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n                if (!seeking) stream.position += bytesWritten;\n                return bytesWritten;\n            },\n            allocate: (stream, offset, length)=>{\n                if (FS.isClosed(stream)) throw new FS.ErrnoError(8);\n                if (offset < 0 || length <= 0) throw new FS.ErrnoError(28);\n                if ((stream.flags & 2097155) === 0) throw new FS.ErrnoError(8);\n                if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) throw new FS.ErrnoError(43);\n                if (!stream.stream_ops.allocate) throw new FS.ErrnoError(138);\n                stream.stream_ops.allocate(stream, offset, length);\n            },\n            mmap: (stream, length, position, prot, flags)=>{\n                if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) throw new FS.ErrnoError(2);\n                if ((stream.flags & 2097155) === 1) throw new FS.ErrnoError(2);\n                if (!stream.stream_ops.mmap) throw new FS.ErrnoError(43);\n                return stream.stream_ops.mmap(stream, length, position, prot, flags);\n            },\n            msync: (stream, buffer, offset, length, mmapFlags)=>{\n                if (!stream.stream_ops.msync) return 0;\n                return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n            },\n            munmap: (stream)=>0,\n            ioctl: (stream, cmd, arg)=>{\n                if (!stream.stream_ops.ioctl) throw new FS.ErrnoError(59);\n                return stream.stream_ops.ioctl(stream, cmd, arg);\n            },\n            readFile: (path, opts = {})=>{\n                opts.flags = opts.flags || 0;\n                opts.encoding = opts.encoding || \"binary\";\n                if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\n                var ret;\n                var stream = FS.open(path, opts.flags);\n                var stat = FS.stat(path);\n                var length = stat.size;\n                var buf = new Uint8Array(length);\n                FS.read(stream, buf, 0, length, 0);\n                if (opts.encoding === \"utf8\") ret = UTF8ArrayToString(buf, 0);\n                else if (opts.encoding === \"binary\") ret = buf;\n                FS.close(stream);\n                return ret;\n            },\n            writeFile: (path, data, opts = {})=>{\n                opts.flags = opts.flags || 577;\n                var stream = FS.open(path, opts.flags, opts.mode);\n                if (typeof data == \"string\") {\n                    var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n                    var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n                    FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n                } else if (ArrayBuffer.isView(data)) FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n                else throw new Error(\"Unsupported data type\");\n                FS.close(stream);\n            },\n            cwd: ()=>FS.currentPath,\n            chdir: (path)=>{\n                var lookup = FS.lookupPath(path, {\n                    follow: true\n                });\n                if (lookup.node === null) throw new FS.ErrnoError(44);\n                if (!FS.isDir(lookup.node.mode)) throw new FS.ErrnoError(54);\n                var errCode = FS.nodePermissions(lookup.node, \"x\");\n                if (errCode) throw new FS.ErrnoError(errCode);\n                FS.currentPath = lookup.path;\n            },\n            createDefaultDirectories: ()=>{\n                FS.mkdir(\"/tmp\");\n                FS.mkdir(\"/home\");\n                FS.mkdir(\"/home/web_user\");\n            },\n            createDefaultDevices: ()=>{\n                FS.mkdir(\"/dev\");\n                FS.registerDevice(FS.makedev(1, 3), {\n                    read: ()=>0,\n                    write: (stream, buffer, offset, length, pos)=>length\n                });\n                FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\n                TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n                TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n                FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\n                FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\n                var randomBuffer = new Uint8Array(1024), randomLeft = 0;\n                var randomByte = ()=>{\n                    if (randomLeft === 0) randomLeft = randomFill(randomBuffer).byteLength;\n                    return randomBuffer[--randomLeft];\n                };\n                FS.createDevice(\"/dev\", \"random\", randomByte);\n                FS.createDevice(\"/dev\", \"urandom\", randomByte);\n                FS.mkdir(\"/dev/shm\");\n                FS.mkdir(\"/dev/shm/tmp\");\n            },\n            createSpecialDirectories: ()=>{\n                FS.mkdir(\"/proc\");\n                var proc_self = FS.mkdir(\"/proc/self\");\n                FS.mkdir(\"/proc/self/fd\");\n                FS.mount({\n                    mount: ()=>{\n                        var node = FS.createNode(proc_self, \"fd\", 16895, 73);\n                        node.node_ops = {\n                            lookup: (parent, name)=>{\n                                var fd = +name;\n                                var stream = FS.getStream(fd);\n                                if (!stream) throw new FS.ErrnoError(8);\n                                var ret = {\n                                    parent: null,\n                                    mount: {\n                                        mountpoint: \"fake\"\n                                    },\n                                    node_ops: {\n                                        readlink: ()=>stream.path\n                                    }\n                                };\n                                ret.parent = ret;\n                                return ret;\n                            }\n                        };\n                        return node;\n                    }\n                }, {}, \"/proc/self/fd\");\n            },\n            createStandardStreams: ()=>{\n                if (Module[\"stdin\"]) FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"]);\n                else FS.symlink(\"/dev/tty\", \"/dev/stdin\");\n                if (Module[\"stdout\"]) FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"]);\n                else FS.symlink(\"/dev/tty\", \"/dev/stdout\");\n                if (Module[\"stderr\"]) FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"]);\n                else FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\n                var stdin = FS.open(\"/dev/stdin\", 0);\n                var stdout = FS.open(\"/dev/stdout\", 1);\n                var stderr = FS.open(\"/dev/stderr\", 1);\n                assert(stdin.fd === 0, \"invalid handle for stdin (\" + stdin.fd + \")\");\n                assert(stdout.fd === 1, \"invalid handle for stdout (\" + stdout.fd + \")\");\n                assert(stderr.fd === 2, \"invalid handle for stderr (\" + stderr.fd + \")\");\n            },\n            ensureErrnoError: ()=>{\n                if (FS.ErrnoError) return;\n                FS.ErrnoError = function ErrnoError(errno, node) {\n                    this.name = \"ErrnoError\";\n                    this.node = node;\n                    this.setErrno = function(errno) {\n                        this.errno = errno;\n                        for(var key in ERRNO_CODES)if (ERRNO_CODES[key] === errno) {\n                            this.code = key;\n                            break;\n                        }\n                    };\n                    this.setErrno(errno);\n                    this.message = ERRNO_MESSAGES[errno];\n                    if (this.stack) {\n                        Object.defineProperty(this, \"stack\", {\n                            value: new Error().stack,\n                            writable: true\n                        });\n                        this.stack = demangleAll(this.stack);\n                    }\n                };\n                FS.ErrnoError.prototype = new Error();\n                FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n                [\n                    44\n                ].forEach((code)=>{\n                    FS.genericErrors[code] = new FS.ErrnoError(code);\n                    FS.genericErrors[code].stack = \"<generic error, no stack>\";\n                });\n            },\n            staticInit: ()=>{\n                FS.ensureErrnoError();\n                FS.nameTable = new Array(4096);\n                FS.mount(MEMFS, {}, \"/\");\n                FS.createDefaultDirectories();\n                FS.createDefaultDevices();\n                FS.createSpecialDirectories();\n                FS.filesystems = {\n                    \"MEMFS\": MEMFS\n                };\n            },\n            init: (input, output, error)=>{\n                assert(!FS.init.initialized, \"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)\");\n                FS.init.initialized = true;\n                FS.ensureErrnoError();\n                Module[\"stdin\"] = input || Module[\"stdin\"];\n                Module[\"stdout\"] = output || Module[\"stdout\"];\n                Module[\"stderr\"] = error || Module[\"stderr\"];\n                FS.createStandardStreams();\n            },\n            quit: ()=>{\n                FS.init.initialized = false;\n                _fflush(0);\n                for(var i = 0; i < FS.streams.length; i++){\n                    var stream = FS.streams[i];\n                    if (!stream) continue;\n                    FS.close(stream);\n                }\n            },\n            getMode: (canRead, canWrite)=>{\n                var mode = 0;\n                if (canRead) mode |= 365;\n                if (canWrite) mode |= 146;\n                return mode;\n            },\n            findObject: (path, dontResolveLastLink)=>{\n                var ret = FS.analyzePath(path, dontResolveLastLink);\n                if (!ret.exists) return null;\n                return ret.object;\n            },\n            analyzePath: (path, dontResolveLastLink)=>{\n                try {\n                    var lookup = FS.lookupPath(path, {\n                        follow: !dontResolveLastLink\n                    });\n                    path = lookup.path;\n                } catch (e) {}\n                var ret = {\n                    isRoot: false,\n                    exists: false,\n                    error: 0,\n                    name: null,\n                    path: null,\n                    object: null,\n                    parentExists: false,\n                    parentPath: null,\n                    parentObject: null\n                };\n                try {\n                    var lookup = FS.lookupPath(path, {\n                        parent: true\n                    });\n                    ret.parentExists = true;\n                    ret.parentPath = lookup.path;\n                    ret.parentObject = lookup.node;\n                    ret.name = PATH.basename(path);\n                    lookup = FS.lookupPath(path, {\n                        follow: !dontResolveLastLink\n                    });\n                    ret.exists = true;\n                    ret.path = lookup.path;\n                    ret.object = lookup.node;\n                    ret.name = lookup.node.name;\n                    ret.isRoot = lookup.path === \"/\";\n                } catch (e) {\n                    ret.error = e.errno;\n                }\n                return ret;\n            },\n            createPath: (parent, path, canRead, canWrite)=>{\n                parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\n                var parts = path.split(\"/\").reverse();\n                while(parts.length){\n                    var part = parts.pop();\n                    if (!part) continue;\n                    var current = PATH.join2(parent, part);\n                    try {\n                        FS.mkdir(current);\n                    } catch (e) {}\n                    parent = current;\n                }\n                return current;\n            },\n            createFile: (parent, name, properties, canRead, canWrite)=>{\n                var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name);\n                var mode = FS.getMode(canRead, canWrite);\n                return FS.create(path, mode);\n            },\n            createDataFile: (parent, name, data, canRead, canWrite, canOwn)=>{\n                var path = name;\n                if (parent) {\n                    parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\n                    path = name ? PATH.join2(parent, name) : parent;\n                }\n                var mode = FS.getMode(canRead, canWrite);\n                var node = FS.create(path, mode);\n                if (data) {\n                    if (typeof data == \"string\") {\n                        var arr = new Array(data.length);\n                        for(var i = 0, len = data.length; i < len; ++i)arr[i] = data.charCodeAt(i);\n                        data = arr;\n                    }\n                    FS.chmod(node, mode | 146);\n                    var stream = FS.open(node, 577);\n                    FS.write(stream, data, 0, data.length, 0, canOwn);\n                    FS.close(stream);\n                    FS.chmod(node, mode);\n                }\n                return node;\n            },\n            createDevice: (parent, name, input, output)=>{\n                var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name);\n                var mode = FS.getMode(!!input, !!output);\n                if (!FS.createDevice.major) FS.createDevice.major = 64;\n                var dev = FS.makedev(FS.createDevice.major++, 0);\n                FS.registerDevice(dev, {\n                    open: (stream)=>{\n                        stream.seekable = false;\n                    },\n                    close: (stream)=>{\n                        if (output && output.buffer && output.buffer.length) output(10);\n                    },\n                    read: (stream, buffer, offset, length, pos)=>{\n                        var bytesRead = 0;\n                        for(var i = 0; i < length; i++){\n                            var result;\n                            try {\n                                result = input();\n                            } catch (e) {\n                                throw new FS.ErrnoError(29);\n                            }\n                            if (result === undefined && bytesRead === 0) throw new FS.ErrnoError(6);\n                            if (result === null || result === undefined) break;\n                            bytesRead++;\n                            buffer[offset + i] = result;\n                        }\n                        if (bytesRead) stream.node.timestamp = Date.now();\n                        return bytesRead;\n                    },\n                    write: (stream, buffer, offset, length, pos)=>{\n                        for(var i = 0; i < length; i++)try {\n                            output(buffer[offset + i]);\n                        } catch (e) {\n                            throw new FS.ErrnoError(29);\n                        }\n                        if (length) stream.node.timestamp = Date.now();\n                        return i;\n                    }\n                });\n                return FS.mkdev(path, mode, dev);\n            },\n            forceLoadFile: (obj)=>{\n                if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n                if (typeof XMLHttpRequest != \"undefined\") throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n                else if (read_) try {\n                    obj.contents = intArrayFromString(read_(obj.url), true);\n                    obj.usedBytes = obj.contents.length;\n                } catch (e) {\n                    throw new FS.ErrnoError(29);\n                }\n                else throw new Error(\"Cannot load without read() or XMLHttpRequest.\");\n            },\n            createLazyFile: (parent, name, url, canRead, canWrite)=>{\n                function LazyUint8Array() {\n                    this.lengthKnown = false;\n                    this.chunks = [];\n                }\n                LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n                    if (idx > this.length - 1 || idx < 0) return undefined;\n                    var chunkOffset = idx % this.chunkSize;\n                    var chunkNum = idx / this.chunkSize | 0;\n                    return this.getter(chunkNum)[chunkOffset];\n                };\n                LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n                    this.getter = getter;\n                };\n                LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n                    var xhr = new XMLHttpRequest();\n                    xhr.open(\"HEAD\", url, false);\n                    xhr.send(null);\n                    if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n                    var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n                    var header;\n                    var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n                    var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n                    var chunkSize = 1048576;\n                    if (!hasByteServing) chunkSize = datalength;\n                    var doXHR = (from, to)=>{\n                        if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n                        if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n                        var xhr = new XMLHttpRequest();\n                        xhr.open(\"GET\", url, false);\n                        if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n                        xhr.responseType = \"arraybuffer\";\n                        if (xhr.overrideMimeType) xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n                        xhr.send(null);\n                        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n                        if (xhr.response !== undefined) return new Uint8Array(xhr.response || []);\n                        return intArrayFromString(xhr.responseText || \"\", true);\n                    };\n                    var lazyArray = this;\n                    lazyArray.setDataGetter((chunkNum)=>{\n                        var start = chunkNum * chunkSize;\n                        var end = (chunkNum + 1) * chunkSize - 1;\n                        end = Math.min(end, datalength - 1);\n                        if (typeof lazyArray.chunks[chunkNum] == \"undefined\") lazyArray.chunks[chunkNum] = doXHR(start, end);\n                        if (typeof lazyArray.chunks[chunkNum] == \"undefined\") throw new Error(\"doXHR failed!\");\n                        return lazyArray.chunks[chunkNum];\n                    });\n                    if (usesGzip || !datalength) {\n                        chunkSize = datalength = 1;\n                        datalength = this.getter(0).length;\n                        chunkSize = datalength;\n                        out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n                    }\n                    this._length = datalength;\n                    this._chunkSize = chunkSize;\n                    this.lengthKnown = true;\n                };\n                if (typeof XMLHttpRequest != \"undefined\") {\n                    if (!ENVIRONMENT_IS_WORKER) throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\n                    var lazyArray = new LazyUint8Array();\n                    Object.defineProperties(lazyArray, {\n                        length: {\n                            get: function() {\n                                if (!this.lengthKnown) this.cacheLength();\n                                return this._length;\n                            }\n                        },\n                        chunkSize: {\n                            get: function() {\n                                if (!this.lengthKnown) this.cacheLength();\n                                return this._chunkSize;\n                            }\n                        }\n                    });\n                    var properties = {\n                        isDevice: false,\n                        contents: lazyArray\n                    };\n                } else var properties = {\n                    isDevice: false,\n                    url: url\n                };\n                var node = FS.createFile(parent, name, properties, canRead, canWrite);\n                if (properties.contents) node.contents = properties.contents;\n                else if (properties.url) {\n                    node.contents = null;\n                    node.url = properties.url;\n                }\n                Object.defineProperties(node, {\n                    usedBytes: {\n                        get: function() {\n                            return this.contents.length;\n                        }\n                    }\n                });\n                var stream_ops = {};\n                var keys = Object.keys(node.stream_ops);\n                keys.forEach((key)=>{\n                    var fn = node.stream_ops[key];\n                    stream_ops[key] = function forceLoadLazyFile() {\n                        FS.forceLoadFile(node);\n                        return fn.apply(null, arguments);\n                    };\n                });\n                function writeChunks(stream, buffer, offset, length, position) {\n                    var contents = stream.node.contents;\n                    if (position >= contents.length) return 0;\n                    var size = Math.min(contents.length - position, length);\n                    assert(size >= 0);\n                    if (contents.slice) for(var i = 0; i < size; i++)buffer[offset + i] = contents[position + i];\n                    else for(var i = 0; i < size; i++)buffer[offset + i] = contents.get(position + i);\n                    return size;\n                }\n                stream_ops.read = (stream, buffer, offset, length, position)=>{\n                    FS.forceLoadFile(node);\n                    return writeChunks(stream, buffer, offset, length, position);\n                };\n                stream_ops.mmap = (stream, length, position, prot, flags)=>{\n                    FS.forceLoadFile(node);\n                    var ptr = mmapAlloc(length);\n                    if (!ptr) throw new FS.ErrnoError(48);\n                    writeChunks(stream, GROWABLE_HEAP_I8(), ptr, length, position);\n                    return {\n                        ptr: ptr,\n                        allocated: true\n                    };\n                };\n                node.stream_ops = stream_ops;\n                return node;\n            },\n            createPreloadedFile: (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish)=>{\n                var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n                var dep = getUniqueRunDependency(\"cp \" + fullname);\n                function processData(byteArray) {\n                    function finish(byteArray) {\n                        if (preFinish) preFinish();\n                        if (!dontCreateFile) FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n                        if (onload) onload();\n                        removeRunDependency(dep);\n                    }\n                    if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, ()=>{\n                        if (onerror) onerror();\n                        removeRunDependency(dep);\n                    })) return;\n                    finish(byteArray);\n                }\n                addRunDependency(dep);\n                if (typeof url == \"string\") asyncLoad(url, (byteArray)=>processData(byteArray), onerror);\n                else processData(url);\n            },\n            absolutePath: ()=>{\n                abort(\"FS.absolutePath has been removed; use PATH_FS.resolve instead\");\n            },\n            createFolder: ()=>{\n                abort(\"FS.createFolder has been removed; use FS.mkdir instead\");\n            },\n            createLink: ()=>{\n                abort(\"FS.createLink has been removed; use FS.symlink instead\");\n            },\n            joinPath: ()=>{\n                abort(\"FS.joinPath has been removed; use PATH.join instead\");\n            },\n            mmapAlloc: ()=>{\n                abort(\"FS.mmapAlloc has been replaced by the top level function mmapAlloc\");\n            },\n            standardizePath: ()=>{\n                abort(\"FS.standardizePath has been removed; use PATH.normalize instead\");\n            }\n        };\n        var UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n        function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\n            var endIdx = idx + maxBytesToRead;\n            var endPtr = idx;\n            while(heapOrArray[endPtr] && !(endPtr >= endIdx))++endPtr;\n            if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) return UTF8Decoder.decode(heapOrArray.buffer instanceof SharedArrayBuffer ? heapOrArray.slice(idx, endPtr) : heapOrArray.subarray(idx, endPtr));\n            var str = \"\";\n            while(idx < endPtr){\n                var u0 = heapOrArray[idx++];\n                if (!(u0 & 128)) {\n                    str += String.fromCharCode(u0);\n                    continue;\n                }\n                var u1 = heapOrArray[idx++] & 63;\n                if ((u0 & 224) == 192) {\n                    str += String.fromCharCode((u0 & 31) << 6 | u1);\n                    continue;\n                }\n                var u2 = heapOrArray[idx++] & 63;\n                if ((u0 & 240) == 224) u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n                else {\n                    if ((u0 & 248) != 240) warnOnce(\"Invalid UTF-8 leading byte \" + ptrToString(u0) + \" encountered when deserializing a UTF-8 string in wasm memory to a JS string!\");\n                    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n                }\n                if (u0 < 65536) str += String.fromCharCode(u0);\n                else {\n                    var ch = u0 - 65536;\n                    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n                }\n            }\n            return str;\n        }\n        function UTF8ToString(ptr, maxBytesToRead) {\n            assert(typeof ptr == \"number\");\n            return ptr ? UTF8ArrayToString(GROWABLE_HEAP_U8(), ptr, maxBytesToRead) : \"\";\n        }\n        var SYSCALLS = {\n            DEFAULT_POLLMASK: 5,\n            calculateAt: function(dirfd, path, allowEmpty) {\n                if (PATH.isAbs(path)) return path;\n                var dir;\n                if (dirfd === -100) dir = FS.cwd();\n                else {\n                    var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n                    dir = dirstream.path;\n                }\n                if (path.length == 0) {\n                    if (!allowEmpty) throw new FS.ErrnoError(44);\n                    return dir;\n                }\n                return PATH.join2(dir, path);\n            },\n            doStat: function(func, path, buf) {\n                try {\n                    var stat = func(path);\n                } catch (e) {\n                    if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) return -54;\n                    throw e;\n                }\n                GROWABLE_HEAP_I32()[buf >> 2] = stat.dev;\n                GROWABLE_HEAP_I32()[buf + 8 >> 2] = stat.ino;\n                GROWABLE_HEAP_I32()[buf + 12 >> 2] = stat.mode;\n                GROWABLE_HEAP_U32()[buf + 16 >> 2] = stat.nlink;\n                GROWABLE_HEAP_I32()[buf + 20 >> 2] = stat.uid;\n                GROWABLE_HEAP_I32()[buf + 24 >> 2] = stat.gid;\n                GROWABLE_HEAP_I32()[buf + 28 >> 2] = stat.rdev;\n                tempI64 = [\n                    stat.size >>> 0,\n                    (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], GROWABLE_HEAP_I32()[buf + 40 >> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 44 >> 2] = tempI64[1];\n                GROWABLE_HEAP_I32()[buf + 48 >> 2] = 4096;\n                GROWABLE_HEAP_I32()[buf + 52 >> 2] = stat.blocks;\n                var atime = stat.atime.getTime();\n                var mtime = stat.mtime.getTime();\n                var ctime = stat.ctime.getTime();\n                tempI64 = [\n                    Math.floor(atime / 1e3) >>> 0,\n                    (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], GROWABLE_HEAP_I32()[buf + 56 >> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 60 >> 2] = tempI64[1];\n                GROWABLE_HEAP_U32()[buf + 64 >> 2] = atime % 1e3 * 1e3;\n                tempI64 = [\n                    Math.floor(mtime / 1e3) >>> 0,\n                    (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], GROWABLE_HEAP_I32()[buf + 72 >> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 76 >> 2] = tempI64[1];\n                GROWABLE_HEAP_U32()[buf + 80 >> 2] = mtime % 1e3 * 1e3;\n                tempI64 = [\n                    Math.floor(ctime / 1e3) >>> 0,\n                    (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], GROWABLE_HEAP_I32()[buf + 88 >> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 92 >> 2] = tempI64[1];\n                GROWABLE_HEAP_U32()[buf + 96 >> 2] = ctime % 1e3 * 1e3;\n                tempI64 = [\n                    stat.ino >>> 0,\n                    (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], GROWABLE_HEAP_I32()[buf + 104 >> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 108 >> 2] = tempI64[1];\n                return 0;\n            },\n            doMsync: function(addr, stream, len, flags, offset) {\n                if (!FS.isFile(stream.node.mode)) throw new FS.ErrnoError(43);\n                if (flags & 2) return 0;\n                var buffer = GROWABLE_HEAP_U8().slice(addr, addr + len);\n                FS.msync(stream, buffer, offset, len, flags);\n            },\n            varargs: undefined,\n            get: function() {\n                assert(SYSCALLS.varargs != undefined);\n                SYSCALLS.varargs += 4;\n                var ret = GROWABLE_HEAP_I32()[SYSCALLS.varargs - 4 >> 2];\n                return ret;\n            },\n            getStr: function(ptr) {\n                var ret = UTF8ToString(ptr);\n                return ret;\n            },\n            getStreamFromFD: function(fd) {\n                var stream = FS.getStream(fd);\n                if (!stream) throw new FS.ErrnoError(8);\n                return stream;\n            }\n        };\n        function _proc_exit(code) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(1, 1, code);\n            EXITSTATUS = code;\n            if (!keepRuntimeAlive()) {\n                PThread.terminateAllThreads();\n                if (Module[\"onExit\"]) Module[\"onExit\"](code);\n                ABORT = true;\n            }\n            quit_(code, new ExitStatus(code));\n        }\n        function exitJS(status, implicit) {\n            EXITSTATUS = status;\n            checkUnflushedContent();\n            if (ENVIRONMENT_IS_PTHREAD) {\n                assert(!implicit);\n                exitOnMainThread(status);\n                throw \"unwind\";\n            }\n            if (keepRuntimeAlive() && !implicit) {\n                var msg = \"program exited (with status: \" + status + \"), but keepRuntimeAlive() is set (counter=\" + runtimeKeepaliveCounter + \") due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)\";\n                readyPromiseReject(msg);\n                err(msg);\n            }\n            _proc_exit(status);\n        }\n        var _exit = exitJS;\n        function ptrToString(ptr) {\n            assert(typeof ptr === \"number\");\n            return \"0x\" + ptr.toString(16).padStart(8, \"0\");\n        }\n        function handleException(e) {\n            if (e instanceof ExitStatus || e == \"unwind\") return EXITSTATUS;\n            checkStackCookie();\n            if (e instanceof WebAssembly.RuntimeError) {\n                if (_emscripten_stack_get_current() <= 0) err(\"Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to 65536)\");\n            }\n            quit_(1, e);\n        }\n        var PThread = {\n            unusedWorkers: [],\n            runningWorkers: [],\n            tlsInitFunctions: [],\n            pthreads: {},\n            nextWorkerID: 1,\n            debugInit: function() {\n                function pthreadLogPrefix() {\n                    var t = 0;\n                    if (runtimeInitialized && typeof _pthread_self != \"undefined\") t = _pthread_self();\n                    return \"w:\" + (Module[\"workerID\"] || 0) + \",t:\" + ptrToString(t) + \": \";\n                }\n                var origDbg = dbg;\n                dbg = (message)=>origDbg(pthreadLogPrefix() + message);\n            },\n            init: function() {\n                PThread.debugInit();\n                if (ENVIRONMENT_IS_PTHREAD) PThread.initWorker();\n                else PThread.initMainThread();\n            },\n            initMainThread: function() {\n                var pthreadPoolSize = navigator.hardwareConcurrency;\n                while(pthreadPoolSize--)PThread.allocateUnusedWorker();\n            },\n            initWorker: function() {\n                noExitRuntime = false;\n            },\n            setExitStatus: function(status) {\n                EXITSTATUS = status;\n            },\n            terminateAllThreads__deps: [\n                \"$terminateWorker\"\n            ],\n            terminateAllThreads: function() {\n                assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! terminateAllThreads() can only ever be called from main application thread!\");\n                for (var worker of PThread.runningWorkers)terminateWorker(worker);\n                for (var worker of PThread.unusedWorkers)terminateWorker(worker);\n                PThread.unusedWorkers = [];\n                PThread.runningWorkers = [];\n                PThread.pthreads = [];\n            },\n            returnWorkerToPool: function(worker) {\n                var pthread_ptr = worker.pthread_ptr;\n                delete PThread.pthreads[pthread_ptr];\n                PThread.unusedWorkers.push(worker);\n                PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker), 1);\n                worker.pthread_ptr = 0;\n                __emscripten_thread_free_data(pthread_ptr);\n            },\n            receiveObjectTransfer: function(data) {},\n            threadInitTLS: function() {\n                PThread.tlsInitFunctions.forEach((f)=>f());\n            },\n            loadWasmModuleToWorker: (worker)=>new Promise((onFinishedLoading)=>{\n                    worker.onmessage = (e)=>{\n                        var d = e[\"data\"];\n                        var cmd = d[\"cmd\"];\n                        if (worker.pthread_ptr) PThread.currentProxiedOperationCallerThread = worker.pthread_ptr;\n                        if (d[\"targetThread\"] && d[\"targetThread\"] != _pthread_self()) {\n                            var targetWorker = PThread.pthreads[d.targetThread];\n                            if (targetWorker) targetWorker.postMessage(d, d[\"transferList\"]);\n                            else err('Internal error! Worker sent a message \"' + cmd + '\" to target pthread ' + d[\"targetThread\"] + \", but that thread no longer exists!\");\n                            PThread.currentProxiedOperationCallerThread = undefined;\n                            return;\n                        }\n                        if (cmd === \"checkMailbox\") checkMailbox();\n                        else if (cmd === \"spawnThread\") spawnThread(d);\n                        else if (cmd === \"cleanupThread\") cleanupThread(d[\"thread\"]);\n                        else if (cmd === \"killThread\") killThread(d[\"thread\"]);\n                        else if (cmd === \"cancelThread\") cancelThread(d[\"thread\"]);\n                        else if (cmd === \"loaded\") {\n                            worker.loaded = true;\n                            onFinishedLoading(worker);\n                        } else if (cmd === \"print\") out(\"Thread \" + d[\"threadId\"] + \": \" + d[\"text\"]);\n                        else if (cmd === \"printErr\") err(\"Thread \" + d[\"threadId\"] + \": \" + d[\"text\"]);\n                        else if (cmd === \"alert\") alert(\"Thread \" + d[\"threadId\"] + \": \" + d[\"text\"]);\n                        else if (d.target === \"setimmediate\") worker.postMessage(d);\n                        else if (cmd === \"callHandler\") Module[d[\"handler\"]](...d[\"args\"]);\n                        else if (cmd) err(\"worker sent an unknown command \" + cmd);\n                        PThread.currentProxiedOperationCallerThread = undefined;\n                    };\n                    worker.onerror = (e)=>{\n                        var message = \"worker sent an error!\";\n                        if (worker.pthread_ptr) message = \"Pthread \" + ptrToString(worker.pthread_ptr) + \" sent an error!\";\n                        err(message + \" \" + e.filename + \":\" + e.lineno + \": \" + e.message);\n                        throw e;\n                    };\n                    assert(wasmMemory instanceof WebAssembly.Memory, \"WebAssembly memory should have been loaded by now!\");\n                    assert(wasmModule instanceof WebAssembly.Module, \"WebAssembly Module should have been loaded by now!\");\n                    var handlers = [];\n                    var knownHandlers = [\n                        \"onExit\",\n                        \"onAbort\",\n                        \"print\",\n                        \"printErr\"\n                    ];\n                    for (var handler of knownHandlers)if (Module.hasOwnProperty(handler)) handlers.push(handler);\n                    worker.workerID = PThread.nextWorkerID++;\n                    worker.postMessage({\n                        \"cmd\": \"load\",\n                        \"handlers\": handlers,\n                        \"urlOrBlob\": Module[\"mainScriptUrlOrBlob\"],\n                        \"wasmMemory\": wasmMemory,\n                        \"wasmModule\": wasmModule,\n                        \"workerID\": worker.workerID\n                    });\n                }),\n            loadWasmModuleToAllWorkers: function(onMaybeReady) {\n                if (ENVIRONMENT_IS_PTHREAD) return onMaybeReady();\n                let pthreadPoolReady = Promise.all(PThread.unusedWorkers.map(PThread.loadWasmModuleToWorker));\n                pthreadPoolReady.then(onMaybeReady);\n            },\n            allocateUnusedWorker: function() {\n                var worker;\n                if (!Module[\"locateFile\"]) worker = new Worker((parcelRequire(\"elYs7\")));\n                else {\n                    var pthreadMainJs = locateFile(\"cas.worker.js\");\n                    worker = new Worker(pthreadMainJs);\n                }\n                PThread.unusedWorkers.push(worker);\n            },\n            getNewWorker: function() {\n                if (PThread.unusedWorkers.length == 0) {\n                    err(\"Tried to spawn a new thread, but the thread pool is exhausted.\\nThis might result in a deadlock unless some threads eventually exit or the code explicitly breaks out to the event loop.\\nIf you want to increase the pool size, use setting `-sPTHREAD_POOL_SIZE=...`.\\nIf you want to throw an explicit error instead of the risk of deadlocking in those cases, use setting `-sPTHREAD_POOL_SIZE_STRICT=2`.\");\n                    PThread.allocateUnusedWorker();\n                    PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0]);\n                }\n                return PThread.unusedWorkers.pop();\n            }\n        };\n        Module[\"PThread\"] = PThread;\n        function callRuntimeCallbacks(callbacks) {\n            while(callbacks.length > 0)callbacks.shift()(Module);\n        }\n        function getCppExceptionTag() {\n            return Module[\"asm\"][\"__cpp_exception\"];\n        }\n        function getCppExceptionThrownObjectFromWebAssemblyException(ex) {\n            var unwind_header = ex.getArg(getCppExceptionTag(), 0);\n            return ___thrown_object_from_unwind_exception(unwind_header);\n        }\n        function decrementExceptionRefcount(ex) {\n            var ptr = getCppExceptionThrownObjectFromWebAssemblyException(ex);\n            ___cxa_decrement_exception_refcount(ptr);\n        }\n        function establishStackSpace() {\n            var pthread_ptr = _pthread_self();\n            var stackTop = GROWABLE_HEAP_I32()[pthread_ptr + 52 >> 2];\n            var stackSize = GROWABLE_HEAP_I32()[pthread_ptr + 56 >> 2];\n            var stackMax = stackTop - stackSize;\n            assert(stackTop != 0);\n            assert(stackMax != 0);\n            assert(stackTop > stackMax, \"stackTop must be higher then stackMax\");\n            _emscripten_stack_set_limits(stackTop, stackMax);\n            stackRestore(stackTop);\n            writeStackCookie();\n        }\n        Module[\"establishStackSpace\"] = establishStackSpace;\n        function exitOnMainThread(returnCode) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(2, 0, returnCode);\n            _exit(returnCode);\n        }\n        function withStackSave(f) {\n            var stack = stackSave();\n            var ret = f();\n            stackRestore(stack);\n            return ret;\n        }\n        function getExceptionMessageCommon(ptr) {\n            return withStackSave(function() {\n                var type_addr_addr = stackAlloc(4);\n                var message_addr_addr = stackAlloc(4);\n                ___get_exception_message(ptr, type_addr_addr, message_addr_addr);\n                var type_addr = GROWABLE_HEAP_U32()[type_addr_addr >> 2];\n                var message_addr = GROWABLE_HEAP_U32()[message_addr_addr >> 2];\n                var type = UTF8ToString(type_addr);\n                _free(type_addr);\n                var message;\n                if (message_addr) {\n                    message = UTF8ToString(message_addr);\n                    _free(message_addr);\n                }\n                return [\n                    type,\n                    message\n                ];\n            });\n        }\n        function getExceptionMessage(ex) {\n            var ptr = getCppExceptionThrownObjectFromWebAssemblyException(ex);\n            return getExceptionMessageCommon(ptr);\n        }\n        Module[\"getExceptionMessage\"] = getExceptionMessage;\n        function getValue(ptr, type = \"i8\") {\n            if (type.endsWith(\"*\")) type = \"*\";\n            switch(type){\n                case \"i1\":\n                    return GROWABLE_HEAP_I8()[ptr >> 0];\n                case \"i8\":\n                    return GROWABLE_HEAP_I8()[ptr >> 0];\n                case \"i16\":\n                    return GROWABLE_HEAP_I16()[ptr >> 1];\n                case \"i32\":\n                    return GROWABLE_HEAP_I32()[ptr >> 2];\n                case \"i64\":\n                    return GROWABLE_HEAP_I32()[ptr >> 2];\n                case \"float\":\n                    return GROWABLE_HEAP_F32()[ptr >> 2];\n                case \"double\":\n                    return GROWABLE_HEAP_F64()[ptr >> 3];\n                case \"*\":\n                    return GROWABLE_HEAP_U32()[ptr >> 2];\n                default:\n                    abort(\"invalid type for getValue: \" + type);\n            }\n        }\n        function incrementExceptionRefcount(ex) {\n            var ptr = getCppExceptionThrownObjectFromWebAssemblyException(ex);\n            ___cxa_increment_exception_refcount(ptr);\n        }\n        var wasmTableMirror = [];\n        function getWasmTableEntry(funcPtr) {\n            var func = wasmTableMirror[funcPtr];\n            if (!func) {\n                if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n                wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n            }\n            assert(wasmTable.get(funcPtr) == func, \"JavaScript-side Wasm function table mirror is out of date!\");\n            return func;\n        }\n        function invokeEntryPoint(ptr, arg) {\n            var result = getWasmTableEntry(ptr)(arg);\n            checkStackCookie();\n            if (keepRuntimeAlive()) PThread.setExitStatus(result);\n            else __emscripten_thread_exit(result);\n        }\n        Module[\"invokeEntryPoint\"] = invokeEntryPoint;\n        function registerTLSInit(tlsInitFunc) {\n            PThread.tlsInitFunctions.push(tlsInitFunc);\n        }\n        function setValue(ptr, value, type = \"i8\") {\n            if (type.endsWith(\"*\")) type = \"*\";\n            switch(type){\n                case \"i1\":\n                    GROWABLE_HEAP_I8()[ptr >> 0] = value;\n                    break;\n                case \"i8\":\n                    GROWABLE_HEAP_I8()[ptr >> 0] = value;\n                    break;\n                case \"i16\":\n                    GROWABLE_HEAP_I16()[ptr >> 1] = value;\n                    break;\n                case \"i32\":\n                    GROWABLE_HEAP_I32()[ptr >> 2] = value;\n                    break;\n                case \"i64\":\n                    tempI64 = [\n                        value >>> 0,\n                        (tempDouble = value, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                    ], GROWABLE_HEAP_I32()[ptr >> 2] = tempI64[0], GROWABLE_HEAP_I32()[ptr + 4 >> 2] = tempI64[1];\n                    break;\n                case \"float\":\n                    GROWABLE_HEAP_F32()[ptr >> 2] = value;\n                    break;\n                case \"double\":\n                    GROWABLE_HEAP_F64()[ptr >> 3] = value;\n                    break;\n                case \"*\":\n                    GROWABLE_HEAP_U32()[ptr >> 2] = value;\n                    break;\n                default:\n                    abort(\"invalid type for setValue: \" + type);\n            }\n        }\n        function warnOnce(text) {\n            if (!warnOnce.shown) warnOnce.shown = {};\n            if (!warnOnce.shown[text]) {\n                warnOnce.shown[text] = 1;\n                err(text);\n            }\n        }\n        function ___assert_fail(condition, filename, line, func) {\n            abort(\"Assertion failed: \" + UTF8ToString(condition) + \", at: \" + [\n                filename ? UTF8ToString(filename) : \"unknown filename\",\n                line,\n                func ? UTF8ToString(func) : \"unknown function\"\n            ]);\n        }\n        function ___call_sighandler(fp, sig) {\n            getWasmTableEntry(fp)(sig);\n        }\n        function ___emscripten_init_main_thread_js(tb) {\n            __emscripten_thread_init(tb, !ENVIRONMENT_IS_WORKER, 1, !ENVIRONMENT_IS_WEB);\n            PThread.threadInitTLS();\n        }\n        function ___emscripten_thread_cleanup(thread) {\n            if (!ENVIRONMENT_IS_PTHREAD) cleanupThread(thread);\n            else postMessage({\n                \"cmd\": \"cleanupThread\",\n                \"thread\": thread\n            });\n        }\n        function pthreadCreateProxied(pthread_ptr, attr, startRoutine, arg) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(3, 1, pthread_ptr, attr, startRoutine, arg);\n            return ___pthread_create_js(pthread_ptr, attr, startRoutine, arg);\n        }\n        function ___pthread_create_js(pthread_ptr, attr, startRoutine, arg) {\n            if (typeof SharedArrayBuffer == \"undefined\") {\n                err(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\");\n                return 6;\n            }\n            var transferList = [];\n            var error = 0;\n            if (ENVIRONMENT_IS_PTHREAD && (transferList.length === 0 || error)) return pthreadCreateProxied(pthread_ptr, attr, startRoutine, arg);\n            if (error) return error;\n            var threadParams = {\n                startRoutine: startRoutine,\n                pthread_ptr: pthread_ptr,\n                arg: arg,\n                transferList: transferList\n            };\n            if (ENVIRONMENT_IS_PTHREAD) {\n                threadParams.cmd = \"spawnThread\";\n                postMessage(threadParams, transferList);\n                return 0;\n            }\n            return spawnThread(threadParams);\n        }\n        function ___throw_exception_with_stack_trace(ex) {\n            var e = new WebAssembly.Exception(getCppExceptionTag(), [\n                ex\n            ], {\n                traceStack: true\n            });\n            e.message = getExceptionMessage(e);\n            if (e.stack) {\n                var arr = e.stack.split(\"\\n\");\n                arr.splice(1, 1);\n                e.stack = arr.join(\"\\n\");\n            }\n            throw e;\n        }\n        function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}\n        function getShiftFromSize(size) {\n            switch(size){\n                case 1:\n                    return 0;\n                case 2:\n                    return 1;\n                case 4:\n                    return 2;\n                case 8:\n                    return 3;\n                default:\n                    throw new TypeError(\"Unknown type size: \" + size);\n            }\n        }\n        function embind_init_charCodes() {\n            var codes = new Array(256);\n            for(var i = 0; i < 256; ++i)codes[i] = String.fromCharCode(i);\n            embind_charCodes = codes;\n        }\n        var embind_charCodes = undefined;\n        function readLatin1String(ptr) {\n            var ret = \"\";\n            var c = ptr;\n            while(GROWABLE_HEAP_U8()[c])ret += embind_charCodes[GROWABLE_HEAP_U8()[c++]];\n            return ret;\n        }\n        var awaitingDependencies = {};\n        var registeredTypes = {};\n        var typeDependencies = {};\n        var char_0 = 48;\n        var char_9 = 57;\n        function makeLegalFunctionName(name) {\n            if (undefined === name) return \"_unknown\";\n            name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\n            var f = name.charCodeAt(0);\n            if (f >= char_0 && f <= char_9) return \"_\" + name;\n            return name;\n        }\n        function createNamedFunction(name, body) {\n            name = makeLegalFunctionName(name);\n            return ({\n                [name]: function() {\n                    return body.apply(this, arguments);\n                }\n            })[name];\n        }\n        function extendError(baseErrorType, errorName) {\n            var errorClass = createNamedFunction(errorName, function(message) {\n                this.name = errorName;\n                this.message = message;\n                var stack = new Error(message).stack;\n                if (stack !== undefined) this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n            });\n            errorClass.prototype = Object.create(baseErrorType.prototype);\n            errorClass.prototype.constructor = errorClass;\n            errorClass.prototype.toString = function() {\n                if (this.message === undefined) return this.name;\n                else return this.name + \": \" + this.message;\n            };\n            return errorClass;\n        }\n        var BindingError = undefined;\n        function throwBindingError(message) {\n            throw new BindingError(message);\n        }\n        var InternalError = undefined;\n        function throwInternalError(message) {\n            throw new InternalError(message);\n        }\n        function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\n            myTypes.forEach(function(type) {\n                typeDependencies[type] = dependentTypes;\n            });\n            function onComplete(typeConverters) {\n                var myTypeConverters = getTypeConverters(typeConverters);\n                if (myTypeConverters.length !== myTypes.length) throwInternalError(\"Mismatched type converter count\");\n                for(var i = 0; i < myTypes.length; ++i)registerType(myTypes[i], myTypeConverters[i]);\n            }\n            var typeConverters = new Array(dependentTypes.length);\n            var unregisteredTypes = [];\n            var registered = 0;\n            dependentTypes.forEach((dt, i)=>{\n                if (registeredTypes.hasOwnProperty(dt)) typeConverters[i] = registeredTypes[dt];\n                else {\n                    unregisteredTypes.push(dt);\n                    if (!awaitingDependencies.hasOwnProperty(dt)) awaitingDependencies[dt] = [];\n                    awaitingDependencies[dt].push(()=>{\n                        typeConverters[i] = registeredTypes[dt];\n                        ++registered;\n                        if (registered === unregisteredTypes.length) onComplete(typeConverters);\n                    });\n                }\n            });\n            if (0 === unregisteredTypes.length) onComplete(typeConverters);\n        }\n        function registerType(rawType, registeredInstance, options = {}) {\n            if (!(\"argPackAdvance\" in registeredInstance)) throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n            var name = registeredInstance.name;\n            if (!rawType) throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer');\n            if (registeredTypes.hasOwnProperty(rawType)) {\n                if (options.ignoreDuplicateRegistrations) return;\n                else throwBindingError(\"Cannot register type '\" + name + \"' twice\");\n            }\n            registeredTypes[rawType] = registeredInstance;\n            delete typeDependencies[rawType];\n            if (awaitingDependencies.hasOwnProperty(rawType)) {\n                var callbacks = awaitingDependencies[rawType];\n                delete awaitingDependencies[rawType];\n                callbacks.forEach((cb)=>cb());\n            }\n        }\n        function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n            var shift = getShiftFromSize(size);\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": function(wt) {\n                    return !!wt;\n                },\n                \"toWireType\": function(destructors, o) {\n                    return o ? trueValue : falseValue;\n                },\n                \"argPackAdvance\": 8,\n                \"readValueFromPointer\": function(pointer) {\n                    var heap;\n                    if (size === 1) heap = GROWABLE_HEAP_I8();\n                    else if (size === 2) heap = GROWABLE_HEAP_I16();\n                    else if (size === 4) heap = GROWABLE_HEAP_I32();\n                    else throw new TypeError(\"Unknown boolean type size: \" + name);\n                    return this[\"fromWireType\"](heap[pointer >> shift]);\n                },\n                destructorFunction: null\n            });\n        }\n        function ClassHandle_isAliasOf(other) {\n            if (!(this instanceof ClassHandle)) return false;\n            if (!(other instanceof ClassHandle)) return false;\n            var leftClass = this.$$.ptrType.registeredClass;\n            var left = this.$$.ptr;\n            var rightClass = other.$$.ptrType.registeredClass;\n            var right = other.$$.ptr;\n            while(leftClass.baseClass){\n                left = leftClass.upcast(left);\n                leftClass = leftClass.baseClass;\n            }\n            while(rightClass.baseClass){\n                right = rightClass.upcast(right);\n                rightClass = rightClass.baseClass;\n            }\n            return leftClass === rightClass && left === right;\n        }\n        function shallowCopyInternalPointer(o) {\n            return {\n                count: o.count,\n                deleteScheduled: o.deleteScheduled,\n                preservePointerOnDelete: o.preservePointerOnDelete,\n                ptr: o.ptr,\n                ptrType: o.ptrType,\n                smartPtr: o.smartPtr,\n                smartPtrType: o.smartPtrType\n            };\n        }\n        function throwInstanceAlreadyDeleted(obj) {\n            function getInstanceTypeName(handle) {\n                return handle.$$.ptrType.registeredClass.name;\n            }\n            throwBindingError(getInstanceTypeName(obj) + \" instance already deleted\");\n        }\n        var finalizationRegistry = false;\n        function detachFinalizer(handle) {}\n        function runDestructor($$) {\n            if ($$.smartPtr) $$.smartPtrType.rawDestructor($$.smartPtr);\n            else $$.ptrType.registeredClass.rawDestructor($$.ptr);\n        }\n        function releaseClassHandle($$) {\n            $$.count.value -= 1;\n            var toDelete = 0 === $$.count.value;\n            if (toDelete) runDestructor($$);\n        }\n        function downcastPointer(ptr, ptrClass, desiredClass) {\n            if (ptrClass === desiredClass) return ptr;\n            if (undefined === desiredClass.baseClass) return null;\n            var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n            if (rv === null) return null;\n            return desiredClass.downcast(rv);\n        }\n        var registeredPointers = {};\n        function getInheritedInstanceCount() {\n            return Object.keys(registeredInstances).length;\n        }\n        function getLiveInheritedInstances() {\n            var rv = [];\n            for(var k in registeredInstances)if (registeredInstances.hasOwnProperty(k)) rv.push(registeredInstances[k]);\n            return rv;\n        }\n        var deletionQueue = [];\n        function flushPendingDeletes() {\n            while(deletionQueue.length){\n                var obj = deletionQueue.pop();\n                obj.$$.deleteScheduled = false;\n                obj[\"delete\"]();\n            }\n        }\n        var delayFunction = undefined;\n        function setDelayFunction(fn) {\n            delayFunction = fn;\n            if (deletionQueue.length && delayFunction) delayFunction(flushPendingDeletes);\n        }\n        function init_embind() {\n            Module[\"getInheritedInstanceCount\"] = getInheritedInstanceCount;\n            Module[\"getLiveInheritedInstances\"] = getLiveInheritedInstances;\n            Module[\"flushPendingDeletes\"] = flushPendingDeletes;\n            Module[\"setDelayFunction\"] = setDelayFunction;\n        }\n        var registeredInstances = {};\n        function getBasestPointer(class_, ptr) {\n            if (ptr === undefined) throwBindingError(\"ptr should not be undefined\");\n            while(class_.baseClass){\n                ptr = class_.upcast(ptr);\n                class_ = class_.baseClass;\n            }\n            return ptr;\n        }\n        function getInheritedInstance(class_, ptr) {\n            ptr = getBasestPointer(class_, ptr);\n            return registeredInstances[ptr];\n        }\n        function makeClassHandle(prototype, record) {\n            if (!record.ptrType || !record.ptr) throwInternalError(\"makeClassHandle requires ptr and ptrType\");\n            var hasSmartPtrType = !!record.smartPtrType;\n            var hasSmartPtr = !!record.smartPtr;\n            if (hasSmartPtrType !== hasSmartPtr) throwInternalError(\"Both smartPtrType and smartPtr must be specified\");\n            record.count = {\n                value: 1\n            };\n            return attachFinalizer(Object.create(prototype, {\n                $$: {\n                    value: record\n                }\n            }));\n        }\n        function RegisteredPointer_fromWireType(ptr) {\n            var rawPointer = this.getPointee(ptr);\n            if (!rawPointer) {\n                this.destructor(ptr);\n                return null;\n            }\n            var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n            if (undefined !== registeredInstance) {\n                if (0 === registeredInstance.$$.count.value) {\n                    registeredInstance.$$.ptr = rawPointer;\n                    registeredInstance.$$.smartPtr = ptr;\n                    return registeredInstance[\"clone\"]();\n                } else {\n                    var rv = registeredInstance[\"clone\"]();\n                    this.destructor(ptr);\n                    return rv;\n                }\n            }\n            function makeDefaultHandle() {\n                if (this.isSmartPointer) return makeClassHandle(this.registeredClass.instancePrototype, {\n                    ptrType: this.pointeeType,\n                    ptr: rawPointer,\n                    smartPtrType: this,\n                    smartPtr: ptr\n                });\n                else return makeClassHandle(this.registeredClass.instancePrototype, {\n                    ptrType: this,\n                    ptr: ptr\n                });\n            }\n            var actualType = this.registeredClass.getActualType(rawPointer);\n            var registeredPointerRecord = registeredPointers[actualType];\n            if (!registeredPointerRecord) return makeDefaultHandle.call(this);\n            var toType;\n            if (this.isConst) toType = registeredPointerRecord.constPointerType;\n            else toType = registeredPointerRecord.pointerType;\n            var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n            if (dp === null) return makeDefaultHandle.call(this);\n            if (this.isSmartPointer) return makeClassHandle(toType.registeredClass.instancePrototype, {\n                ptrType: toType,\n                ptr: dp,\n                smartPtrType: this,\n                smartPtr: ptr\n            });\n            else return makeClassHandle(toType.registeredClass.instancePrototype, {\n                ptrType: toType,\n                ptr: dp\n            });\n        }\n        function attachFinalizer(handle) {\n            if (\"undefined\" === typeof FinalizationRegistry) {\n                attachFinalizer = (handle)=>handle;\n                return handle;\n            }\n            finalizationRegistry = new FinalizationRegistry((info)=>{\n                console.warn(info.leakWarning.stack.replace(/^Error: /, \"\"));\n                releaseClassHandle(info.$$);\n            });\n            attachFinalizer = (handle)=>{\n                var $$ = handle.$$;\n                var hasSmartPtr = !!$$.smartPtr;\n                if (hasSmartPtr) {\n                    var info = {\n                        $$: $$\n                    };\n                    var cls = $$.ptrType.registeredClass;\n                    info.leakWarning = new Error(\"Embind found a leaked C++ instance \" + cls.name + \" <\" + ptrToString($$.ptr) + \">.\\n\" + \"We'll free it automatically in this case, but this functionality is not reliable across various environments.\\n\" + \"Make sure to invoke .delete() manually once you're done with the instance instead.\\n\" + \"Originally allocated\");\n                    if (\"captureStackTrace\" in Error) Error.captureStackTrace(info.leakWarning, RegisteredPointer_fromWireType);\n                    finalizationRegistry.register(handle, info, handle);\n                }\n                return handle;\n            };\n            detachFinalizer = (handle)=>finalizationRegistry.unregister(handle);\n            return attachFinalizer(handle);\n        }\n        function ClassHandle_clone() {\n            if (!this.$$.ptr) throwInstanceAlreadyDeleted(this);\n            if (this.$$.preservePointerOnDelete) {\n                this.$$.count.value += 1;\n                return this;\n            } else {\n                var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n                    $$: {\n                        value: shallowCopyInternalPointer(this.$$)\n                    }\n                }));\n                clone.$$.count.value += 1;\n                clone.$$.deleteScheduled = false;\n                return clone;\n            }\n        }\n        function ClassHandle_delete() {\n            if (!this.$$.ptr) throwInstanceAlreadyDeleted(this);\n            if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) throwBindingError(\"Object already scheduled for deletion\");\n            detachFinalizer(this);\n            releaseClassHandle(this.$$);\n            if (!this.$$.preservePointerOnDelete) {\n                this.$$.smartPtr = undefined;\n                this.$$.ptr = undefined;\n            }\n        }\n        function ClassHandle_isDeleted() {\n            return !this.$$.ptr;\n        }\n        function ClassHandle_deleteLater() {\n            if (!this.$$.ptr) throwInstanceAlreadyDeleted(this);\n            if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) throwBindingError(\"Object already scheduled for deletion\");\n            deletionQueue.push(this);\n            if (deletionQueue.length === 1 && delayFunction) delayFunction(flushPendingDeletes);\n            this.$$.deleteScheduled = true;\n            return this;\n        }\n        function init_ClassHandle() {\n            ClassHandle.prototype[\"isAliasOf\"] = ClassHandle_isAliasOf;\n            ClassHandle.prototype[\"clone\"] = ClassHandle_clone;\n            ClassHandle.prototype[\"delete\"] = ClassHandle_delete;\n            ClassHandle.prototype[\"isDeleted\"] = ClassHandle_isDeleted;\n            ClassHandle.prototype[\"deleteLater\"] = ClassHandle_deleteLater;\n        }\n        function ClassHandle() {}\n        function ensureOverloadTable(proto, methodName, humanName) {\n            if (undefined === proto[methodName].overloadTable) {\n                var prevFunc = proto[methodName];\n                proto[methodName] = function() {\n                    if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) throwBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\");\n                    return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n                };\n                proto[methodName].overloadTable = [];\n                proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n            }\n        }\n        function exposePublicSymbol(name, value, numArguments) {\n            if (Module.hasOwnProperty(name)) {\n                if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\n                ensureOverloadTable(Module, name, name);\n                if (Module.hasOwnProperty(numArguments)) throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\");\n                Module[name].overloadTable[numArguments] = value;\n            } else {\n                Module[name] = value;\n                if (undefined !== numArguments) Module[name].numArguments = numArguments;\n            }\n        }\n        function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\n            this.name = name;\n            this.constructor = constructor;\n            this.instancePrototype = instancePrototype;\n            this.rawDestructor = rawDestructor;\n            this.baseClass = baseClass;\n            this.getActualType = getActualType;\n            this.upcast = upcast;\n            this.downcast = downcast;\n            this.pureVirtualFunctions = [];\n        }\n        function upcastPointer(ptr, ptrClass, desiredClass) {\n            while(ptrClass !== desiredClass){\n                if (!ptrClass.upcast) throwBindingError(\"Expected null or instance of \" + desiredClass.name + \", got an instance of \" + ptrClass.name);\n                ptr = ptrClass.upcast(ptr);\n                ptrClass = ptrClass.baseClass;\n            }\n            return ptr;\n        }\n        function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n            if (handle === null) {\n                if (this.isReference) throwBindingError(\"null is not a valid \" + this.name);\n                return 0;\n            }\n            if (!handle.$$) throwBindingError('Cannot pass \"' + embindRepr(handle) + '\" as a ' + this.name);\n            if (!handle.$$.ptr) throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n            var handleClass = handle.$$.ptrType.registeredClass;\n            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n            return ptr;\n        }\n        function genericPointerToWireType(destructors, handle) {\n            var ptr;\n            if (handle === null) {\n                if (this.isReference) throwBindingError(\"null is not a valid \" + this.name);\n                if (this.isSmartPointer) {\n                    ptr = this.rawConstructor();\n                    if (destructors !== null) destructors.push(this.rawDestructor, ptr);\n                    return ptr;\n                } else return 0;\n            }\n            if (!handle.$$) throwBindingError('Cannot pass \"' + embindRepr(handle) + '\" as a ' + this.name);\n            if (!handle.$$.ptr) throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n            if (!this.isConst && handle.$$.ptrType.isConst) throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n            var handleClass = handle.$$.ptrType.registeredClass;\n            ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n            if (this.isSmartPointer) {\n                if (undefined === handle.$$.smartPtr) throwBindingError(\"Passing raw pointer to smart pointer is illegal\");\n                switch(this.sharingPolicy){\n                    case 0:\n                        if (handle.$$.smartPtrType === this) ptr = handle.$$.smartPtr;\n                        else throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n                        break;\n                    case 1:\n                        ptr = handle.$$.smartPtr;\n                        break;\n                    case 2:\n                        if (handle.$$.smartPtrType === this) ptr = handle.$$.smartPtr;\n                        else {\n                            var clonedHandle = handle[\"clone\"]();\n                            ptr = this.rawShare(ptr, Emval.toHandle(function() {\n                                clonedHandle[\"delete\"]();\n                            }));\n                            if (destructors !== null) destructors.push(this.rawDestructor, ptr);\n                        }\n                        break;\n                    default:\n                        throwBindingError(\"Unsupporting sharing policy\");\n                }\n            }\n            return ptr;\n        }\n        function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n            if (handle === null) {\n                if (this.isReference) throwBindingError(\"null is not a valid \" + this.name);\n                return 0;\n            }\n            if (!handle.$$) throwBindingError('Cannot pass \"' + embindRepr(handle) + '\" as a ' + this.name);\n            if (!handle.$$.ptr) throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n            if (handle.$$.ptrType.isConst) throwBindingError(\"Cannot convert argument of type \" + handle.$$.ptrType.name + \" to parameter type \" + this.name);\n            var handleClass = handle.$$.ptrType.registeredClass;\n            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n            return ptr;\n        }\n        function simpleReadValueFromPointer(pointer) {\n            return this[\"fromWireType\"](GROWABLE_HEAP_I32()[pointer >> 2]);\n        }\n        function RegisteredPointer_getPointee(ptr) {\n            if (this.rawGetPointee) ptr = this.rawGetPointee(ptr);\n            return ptr;\n        }\n        function RegisteredPointer_destructor(ptr) {\n            if (this.rawDestructor) this.rawDestructor(ptr);\n        }\n        function RegisteredPointer_deleteObject(handle) {\n            if (handle !== null) handle[\"delete\"]();\n        }\n        function init_RegisteredPointer() {\n            RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\n            RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\n            RegisteredPointer.prototype[\"argPackAdvance\"] = 8;\n            RegisteredPointer.prototype[\"readValueFromPointer\"] = simpleReadValueFromPointer;\n            RegisteredPointer.prototype[\"deleteObject\"] = RegisteredPointer_deleteObject;\n            RegisteredPointer.prototype[\"fromWireType\"] = RegisteredPointer_fromWireType;\n        }\n        function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\n            this.name = name;\n            this.registeredClass = registeredClass;\n            this.isReference = isReference;\n            this.isConst = isConst;\n            this.isSmartPointer = isSmartPointer;\n            this.pointeeType = pointeeType;\n            this.sharingPolicy = sharingPolicy;\n            this.rawGetPointee = rawGetPointee;\n            this.rawConstructor = rawConstructor;\n            this.rawShare = rawShare;\n            this.rawDestructor = rawDestructor;\n            if (!isSmartPointer && registeredClass.baseClass === undefined) {\n                if (isConst) {\n                    this[\"toWireType\"] = constNoSmartPtrRawPointerToWireType;\n                    this.destructorFunction = null;\n                } else {\n                    this[\"toWireType\"] = nonConstNoSmartPtrRawPointerToWireType;\n                    this.destructorFunction = null;\n                }\n            } else this[\"toWireType\"] = genericPointerToWireType;\n        }\n        function replacePublicSymbol(name, value, numArguments) {\n            if (!Module.hasOwnProperty(name)) throwInternalError(\"Replacing nonexistant public symbol\");\n            if (undefined !== Module[name].overloadTable && undefined !== numArguments) Module[name].overloadTable[numArguments] = value;\n            else {\n                Module[name] = value;\n                Module[name].argCount = numArguments;\n            }\n        }\n        function dynCallLegacy(sig, ptr, args) {\n            assert(\"dynCall_\" + sig in Module, \"bad function pointer type - dynCall function not found for sig '\" + sig + \"'\");\n            if (args && args.length) assert(args.length === sig.substring(1).replace(/j/g, \"--\").length);\n            else assert(sig.length == 1);\n            var f = Module[\"dynCall_\" + sig];\n            return args && args.length ? f.apply(null, [\n                ptr\n            ].concat(args)) : f.call(null, ptr);\n        }\n        function dynCall(sig, ptr, args) {\n            if (sig.includes(\"j\")) return dynCallLegacy(sig, ptr, args);\n            assert(getWasmTableEntry(ptr), \"missing table entry in dynCall: \" + ptr);\n            var rtn = getWasmTableEntry(ptr).apply(null, args);\n            return rtn;\n        }\n        function getDynCaller(sig, ptr) {\n            assert(sig.includes(\"j\") || sig.includes(\"p\"), \"getDynCaller should only be called with i64 sigs\");\n            var argCache = [];\n            return function() {\n                argCache.length = 0;\n                Object.assign(argCache, arguments);\n                return dynCall(sig, ptr, argCache);\n            };\n        }\n        function embind__requireFunction(signature, rawFunction) {\n            signature = readLatin1String(signature);\n            function makeDynCaller() {\n                if (signature.includes(\"j\")) return getDynCaller(signature, rawFunction);\n                return getWasmTableEntry(rawFunction);\n            }\n            var fp = makeDynCaller();\n            if (typeof fp != \"function\") throwBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction);\n            return fp;\n        }\n        var UnboundTypeError = undefined;\n        function getTypeName(type) {\n            var ptr = ___getTypeName(type);\n            var rv = readLatin1String(ptr);\n            _free(ptr);\n            return rv;\n        }\n        function throwUnboundTypeError(message, types) {\n            var unboundTypes = [];\n            var seen = {};\n            function visit(type) {\n                if (seen[type]) return;\n                if (registeredTypes[type]) return;\n                if (typeDependencies[type]) {\n                    typeDependencies[type].forEach(visit);\n                    return;\n                }\n                unboundTypes.push(type);\n                seen[type] = true;\n            }\n            types.forEach(visit);\n            throw new UnboundTypeError(message + \": \" + unboundTypes.map(getTypeName).join([\n                \", \"\n            ]));\n        }\n        function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {\n            name = readLatin1String(name);\n            getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n            if (upcast) upcast = embind__requireFunction(upcastSignature, upcast);\n            if (downcast) downcast = embind__requireFunction(downcastSignature, downcast);\n            rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n            var legalFunctionName = makeLegalFunctionName(name);\n            exposePublicSymbol(legalFunctionName, function() {\n                throwUnboundTypeError(\"Cannot construct \" + name + \" due to unbound types\", [\n                    baseClassRawType\n                ]);\n            });\n            whenDependentTypesAreResolved([\n                rawType,\n                rawPointerType,\n                rawConstPointerType\n            ], baseClassRawType ? [\n                baseClassRawType\n            ] : [], function(base) {\n                base = base[0];\n                var baseClass;\n                var basePrototype;\n                if (baseClassRawType) {\n                    baseClass = base.registeredClass;\n                    basePrototype = baseClass.instancePrototype;\n                } else basePrototype = ClassHandle.prototype;\n                var constructor = createNamedFunction(legalFunctionName, function() {\n                    if (Object.getPrototypeOf(this) !== instancePrototype) throw new BindingError(\"Use 'new' to construct \" + name);\n                    if (undefined === registeredClass.constructor_body) throw new BindingError(name + \" has no accessible constructor\");\n                    var body = registeredClass.constructor_body[arguments.length];\n                    if (undefined === body) throw new BindingError(\"Tried to invoke ctor of \" + name + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(registeredClass.constructor_body).toString() + \") parameters instead!\");\n                    return body.apply(this, arguments);\n                });\n                var instancePrototype = Object.create(basePrototype, {\n                    constructor: {\n                        value: constructor\n                    }\n                });\n                constructor.prototype = instancePrototype;\n                var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\n                var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n                var pointerConverter = new RegisteredPointer(name + \"*\", registeredClass, false, false, false);\n                var constPointerConverter = new RegisteredPointer(name + \" const*\", registeredClass, false, true, false);\n                registeredPointers[rawType] = {\n                    pointerType: pointerConverter,\n                    constPointerType: constPointerConverter\n                };\n                replacePublicSymbol(legalFunctionName, constructor);\n                return [\n                    referenceConverter,\n                    pointerConverter,\n                    constPointerConverter\n                ];\n            });\n        }\n        function heap32VectorToArray(count, firstElement) {\n            var array = [];\n            for(var i = 0; i < count; i++)array.push(GROWABLE_HEAP_U32()[firstElement + i * 4 >> 2]);\n            return array;\n        }\n        function runDestructors(destructors) {\n            while(destructors.length){\n                var ptr = destructors.pop();\n                var del = destructors.pop();\n                del(ptr);\n            }\n        }\n        function newFunc(constructor, argumentList) {\n            if (!(constructor instanceof Function)) throw new TypeError(\"new_ called with constructor type \" + typeof constructor + \" which is not a function\");\n            var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function() {});\n            dummy.prototype = constructor.prototype;\n            var obj = new dummy();\n            var r = constructor.apply(obj, argumentList);\n            return r instanceof Object ? r : obj;\n        }\n        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {\n            var argCount = argTypes.length;\n            if (argCount < 2) throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n            assert(!isAsync, \"Async bindings are only supported with JSPI.\");\n            var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n            var needsDestructorStack = false;\n            for(var i = 1; i < argTypes.length; ++i)if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n                needsDestructorStack = true;\n                break;\n            }\n            var returns = argTypes[0].name !== \"void\";\n            var argsList = \"\";\n            var argsListWired = \"\";\n            for(var i = 0; i < argCount - 2; ++i){\n                argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n                argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\n            }\n            var invokerFnBody = \"return function \" + makeLegalFunctionName(humanName) + \"(\" + argsList + \") {\\n\" + \"if (arguments.length !== \" + (argCount - 2) + \") {\\n\" + \"throwBindingError('function \" + humanName + \" called with ' + arguments.length + ' arguments, expected \" + (argCount - 2) + \" args!');\\n\" + \"}\\n\";\n            if (needsDestructorStack) invokerFnBody += \"var destructors = [];\\n\";\n            var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n            var args1 = [\n                \"throwBindingError\",\n                \"invoker\",\n                \"fn\",\n                \"runDestructors\",\n                \"retType\",\n                \"classParam\"\n            ];\n            var args2 = [\n                throwBindingError,\n                cppInvokerFunc,\n                cppTargetFunc,\n                runDestructors,\n                argTypes[0],\n                argTypes[1]\n            ];\n            if (isClassMethodFunc) invokerFnBody += \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\";\n            for(var i = 0; i < argCount - 2; ++i){\n                invokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \".toWireType(\" + dtorStack + \", arg\" + i + \"); // \" + argTypes[i + 2].name + \"\\n\";\n                args1.push(\"argType\" + i);\n                args2.push(argTypes[i + 2]);\n            }\n            if (isClassMethodFunc) argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n            invokerFnBody += (returns || isAsync ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\n            if (needsDestructorStack) invokerFnBody += \"runDestructors(destructors);\\n\";\n            else for(var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i){\n                var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n                if (argTypes[i].destructorFunction !== null) {\n                    invokerFnBody += paramName + \"_dtor(\" + paramName + \"); // \" + argTypes[i].name + \"\\n\";\n                    args1.push(paramName + \"_dtor\");\n                    args2.push(argTypes[i].destructorFunction);\n                }\n            }\n            if (returns) invokerFnBody += \"var ret = retType.fromWireType(rv);\\nreturn ret;\\n\";\n            invokerFnBody += \"}\\n\";\n            args1.push(invokerFnBody);\n            return newFunc(Function, args1).apply(null, args2);\n        }\n        function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {\n            assert(argCount > 0);\n            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n            invoker = embind__requireFunction(invokerSignature, invoker);\n            var args = [\n                rawConstructor\n            ];\n            var destructors = [];\n            whenDependentTypesAreResolved([], [\n                rawClassType\n            ], function(classType) {\n                classType = classType[0];\n                var humanName = \"constructor \" + classType.name;\n                if (undefined === classType.registeredClass.constructor_body) classType.registeredClass.constructor_body = [];\n                if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\" + (argCount - 1) + \") for class '\" + classType.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\n                classType.registeredClass.constructor_body[argCount - 1] = ()=>{\n                    throwUnboundTypeError(\"Cannot construct \" + classType.name + \" due to unbound types\", rawArgTypes);\n                };\n                whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n                    argTypes.splice(1, 0, null);\n                    classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\n                    return [];\n                });\n                return [];\n            });\n        }\n        function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync) {\n            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n            methodName = readLatin1String(methodName);\n            rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n            whenDependentTypesAreResolved([], [\n                rawClassType\n            ], function(classType) {\n                classType = classType[0];\n                var humanName = classType.name + \".\" + methodName;\n                if (methodName.startsWith(\"@@\")) methodName = Symbol[methodName.substring(2)];\n                if (isPureVirtual) classType.registeredClass.pureVirtualFunctions.push(methodName);\n                function unboundTypesHandler() {\n                    throwUnboundTypeError(\"Cannot call \" + humanName + \" due to unbound types\", rawArgTypes);\n                }\n                var proto = classType.registeredClass.instancePrototype;\n                var method = proto[methodName];\n                if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {\n                    unboundTypesHandler.argCount = argCount - 2;\n                    unboundTypesHandler.className = classType.name;\n                    proto[methodName] = unboundTypesHandler;\n                } else {\n                    ensureOverloadTable(proto, methodName, humanName);\n                    proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n                }\n                whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n                    var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);\n                    if (undefined === proto[methodName].overloadTable) {\n                        memberFunction.argCount = argCount - 2;\n                        proto[methodName] = memberFunction;\n                    } else proto[methodName].overloadTable[argCount - 2] = memberFunction;\n                    return [];\n                });\n                return [];\n            });\n        }\n        function HandleAllocator() {\n            this.allocated = [\n                undefined\n            ];\n            this.freelist = [];\n            this.get = function(id) {\n                assert(this.allocated[id] !== undefined, \"invalid handle: \" + id);\n                return this.allocated[id];\n            };\n            this.allocate = function(handle) {\n                let id = this.freelist.pop() || this.allocated.length;\n                this.allocated[id] = handle;\n                return id;\n            };\n            this.free = function(id) {\n                assert(this.allocated[id] !== undefined);\n                this.allocated[id] = undefined;\n                this.freelist.push(id);\n            };\n        }\n        var emval_handles = new HandleAllocator();\n        function __emval_decref(handle) {\n            if (handle >= emval_handles.reserved && 0 === --emval_handles.get(handle).refcount) emval_handles.free(handle);\n        }\n        function count_emval_handles() {\n            var count = 0;\n            for(var i = emval_handles.reserved; i < emval_handles.allocated.length; ++i)if (emval_handles.allocated[i] !== undefined) ++count;\n            return count;\n        }\n        function init_emval() {\n            emval_handles.allocated.push({\n                value: undefined\n            }, {\n                value: null\n            }, {\n                value: true\n            }, {\n                value: false\n            });\n            emval_handles.reserved = emval_handles.allocated.length;\n            Module[\"count_emval_handles\"] = count_emval_handles;\n        }\n        var Emval = {\n            toValue: (handle)=>{\n                if (!handle) throwBindingError(\"Cannot use deleted val. handle = \" + handle);\n                return emval_handles.get(handle).value;\n            },\n            toHandle: (value)=>{\n                switch(value){\n                    case undefined:\n                        return 1;\n                    case null:\n                        return 2;\n                    case true:\n                        return 3;\n                    case false:\n                        return 4;\n                    default:\n                        return emval_handles.allocate({\n                            refcount: 1,\n                            value: value\n                        });\n                }\n            }\n        };\n        function __embind_register_emval(rawType, name) {\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": function(handle) {\n                    var rv = Emval.toValue(handle);\n                    __emval_decref(handle);\n                    return rv;\n                },\n                \"toWireType\": function(destructors, value) {\n                    return Emval.toHandle(value);\n                },\n                \"argPackAdvance\": 8,\n                \"readValueFromPointer\": simpleReadValueFromPointer,\n                destructorFunction: null\n            });\n        }\n        function enumReadValueFromPointer(name, shift, signed) {\n            switch(shift){\n                case 0:\n                    return function(pointer) {\n                        var heap = signed ? GROWABLE_HEAP_I8() : GROWABLE_HEAP_U8();\n                        return this[\"fromWireType\"](heap[pointer]);\n                    };\n                case 1:\n                    return function(pointer) {\n                        var heap = signed ? GROWABLE_HEAP_I16() : GROWABLE_HEAP_U16();\n                        return this[\"fromWireType\"](heap[pointer >> 1]);\n                    };\n                case 2:\n                    return function(pointer) {\n                        var heap = signed ? GROWABLE_HEAP_I32() : GROWABLE_HEAP_U32();\n                        return this[\"fromWireType\"](heap[pointer >> 2]);\n                    };\n                default:\n                    throw new TypeError(\"Unknown integer type: \" + name);\n            }\n        }\n        function __embind_register_enum(rawType, name, size, isSigned) {\n            var shift = getShiftFromSize(size);\n            name = readLatin1String(name);\n            function ctor() {}\n            ctor.values = {};\n            registerType(rawType, {\n                name: name,\n                constructor: ctor,\n                \"fromWireType\": function(c) {\n                    return this.constructor.values[c];\n                },\n                \"toWireType\": function(destructors, c) {\n                    return c.value;\n                },\n                \"argPackAdvance\": 8,\n                \"readValueFromPointer\": enumReadValueFromPointer(name, shift, isSigned),\n                destructorFunction: null\n            });\n            exposePublicSymbol(name, ctor);\n        }\n        function requireRegisteredType(rawType, humanName) {\n            var impl = registeredTypes[rawType];\n            if (undefined === impl) throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\n            return impl;\n        }\n        function __embind_register_enum_value(rawEnumType, name, enumValue) {\n            var enumType = requireRegisteredType(rawEnumType, \"enum\");\n            name = readLatin1String(name);\n            var Enum = enumType.constructor;\n            var Value = Object.create(enumType.constructor.prototype, {\n                value: {\n                    value: enumValue\n                },\n                constructor: {\n                    value: createNamedFunction(enumType.name + \"_\" + name, function() {})\n                }\n            });\n            Enum.values[enumValue] = Value;\n            Enum[name] = Value;\n        }\n        function embindRepr(v) {\n            if (v === null) return \"null\";\n            var t = typeof v;\n            if (t === \"object\" || t === \"array\" || t === \"function\") return v.toString();\n            else return \"\" + v;\n        }\n        function floatReadValueFromPointer(name, shift) {\n            switch(shift){\n                case 2:\n                    return function(pointer) {\n                        return this[\"fromWireType\"](GROWABLE_HEAP_F32()[pointer >> 2]);\n                    };\n                case 3:\n                    return function(pointer) {\n                        return this[\"fromWireType\"](GROWABLE_HEAP_F64()[pointer >> 3]);\n                    };\n                default:\n                    throw new TypeError(\"Unknown float type: \" + name);\n            }\n        }\n        function __embind_register_float(rawType, name, size) {\n            var shift = getShiftFromSize(size);\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": function(value) {\n                    return value;\n                },\n                \"toWireType\": function(destructors, value) {\n                    if (typeof value != \"number\" && typeof value != \"boolean\") throw new TypeError('Cannot convert \"' + embindRepr(value) + '\" to ' + this.name);\n                    return value;\n                },\n                \"argPackAdvance\": 8,\n                \"readValueFromPointer\": floatReadValueFromPointer(name, shift),\n                destructorFunction: null\n            });\n        }\n        function integerReadValueFromPointer(name, shift, signed) {\n            switch(shift){\n                case 0:\n                    return signed ? function readS8FromPointer(pointer) {\n                        return GROWABLE_HEAP_I8()[pointer];\n                    } : function readU8FromPointer(pointer) {\n                        return GROWABLE_HEAP_U8()[pointer];\n                    };\n                case 1:\n                    return signed ? function readS16FromPointer(pointer) {\n                        return GROWABLE_HEAP_I16()[pointer >> 1];\n                    } : function readU16FromPointer(pointer) {\n                        return GROWABLE_HEAP_U16()[pointer >> 1];\n                    };\n                case 2:\n                    return signed ? function readS32FromPointer(pointer) {\n                        return GROWABLE_HEAP_I32()[pointer >> 2];\n                    } : function readU32FromPointer(pointer) {\n                        return GROWABLE_HEAP_U32()[pointer >> 2];\n                    };\n                default:\n                    throw new TypeError(\"Unknown integer type: \" + name);\n            }\n        }\n        function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n            name = readLatin1String(name);\n            if (maxRange === -1) maxRange = 4294967295;\n            var shift = getShiftFromSize(size);\n            var fromWireType = (value)=>value;\n            if (minRange === 0) {\n                var bitshift = 32 - 8 * size;\n                fromWireType = (value)=>value << bitshift >>> bitshift;\n            }\n            var isUnsignedType = name.includes(\"unsigned\");\n            var checkAssertions = (value, toTypeName)=>{\n                if (typeof value != \"number\" && typeof value != \"boolean\") throw new TypeError('Cannot convert \"' + embindRepr(value) + '\" to ' + toTypeName);\n                if (value < minRange || value > maxRange) throw new TypeError('Passing a number \"' + embindRepr(value) + '\" from JS side to C/C++ side to an argument of type \"' + name + '\", which is outside the valid range [' + minRange + \", \" + maxRange + \"]!\");\n            };\n            var toWireType;\n            if (isUnsignedType) toWireType = function(destructors, value) {\n                checkAssertions(value, this.name);\n                return value >>> 0;\n            };\n            else toWireType = function(destructors, value) {\n                checkAssertions(value, this.name);\n                return value;\n            };\n            registerType(primitiveType, {\n                name: name,\n                \"fromWireType\": fromWireType,\n                \"toWireType\": toWireType,\n                \"argPackAdvance\": 8,\n                \"readValueFromPointer\": integerReadValueFromPointer(name, shift, minRange !== 0),\n                destructorFunction: null\n            });\n        }\n        function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n            var typeMapping = [\n                Int8Array,\n                Uint8Array,\n                Int16Array,\n                Uint16Array,\n                Int32Array,\n                Uint32Array,\n                Float32Array,\n                Float64Array\n            ];\n            var TA = typeMapping[dataTypeIndex];\n            function decodeMemoryView(handle) {\n                handle = handle >> 2;\n                var heap = GROWABLE_HEAP_U32();\n                var size = heap[handle];\n                var data = heap[handle + 1];\n                return new TA(heap.buffer, data, size);\n            }\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": decodeMemoryView,\n                \"argPackAdvance\": 8,\n                \"readValueFromPointer\": decodeMemoryView\n            }, {\n                ignoreDuplicateRegistrations: true\n            });\n        }\n        function __embind_register_smart_ptr(rawType, rawPointeeType, name, sharingPolicy, getPointeeSignature, rawGetPointee, constructorSignature, rawConstructor, shareSignature, rawShare, destructorSignature, rawDestructor) {\n            name = readLatin1String(name);\n            rawGetPointee = embind__requireFunction(getPointeeSignature, rawGetPointee);\n            rawConstructor = embind__requireFunction(constructorSignature, rawConstructor);\n            rawShare = embind__requireFunction(shareSignature, rawShare);\n            rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n            whenDependentTypesAreResolved([\n                rawType\n            ], [\n                rawPointeeType\n            ], function(pointeeType) {\n                pointeeType = pointeeType[0];\n                var registeredPointer = new RegisteredPointer(name, pointeeType.registeredClass, false, false, true, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor);\n                return [\n                    registeredPointer\n                ];\n            });\n        }\n        function stringToUTF8(str, outPtr, maxBytesToWrite) {\n            assert(typeof maxBytesToWrite == \"number\", \"stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n            return stringToUTF8Array(str, GROWABLE_HEAP_U8(), outPtr, maxBytesToWrite);\n        }\n        function __embind_register_std_string(rawType, name) {\n            name = readLatin1String(name);\n            var stdStringIsUTF8 = name === \"std::string\";\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": function(value) {\n                    var length = GROWABLE_HEAP_U32()[value >> 2];\n                    var payload = value + 4;\n                    var str;\n                    if (stdStringIsUTF8) {\n                        var decodeStartPtr = payload;\n                        for(var i = 0; i <= length; ++i){\n                            var currentBytePtr = payload + i;\n                            if (i == length || GROWABLE_HEAP_U8()[currentBytePtr] == 0) {\n                                var maxRead = currentBytePtr - decodeStartPtr;\n                                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                                if (str === undefined) str = stringSegment;\n                                else {\n                                    str += String.fromCharCode(0);\n                                    str += stringSegment;\n                                }\n                                decodeStartPtr = currentBytePtr + 1;\n                            }\n                        }\n                    } else {\n                        var a = new Array(length);\n                        for(var i = 0; i < length; ++i)a[i] = String.fromCharCode(GROWABLE_HEAP_U8()[payload + i]);\n                        str = a.join(\"\");\n                    }\n                    _free(value);\n                    return str;\n                },\n                \"toWireType\": function(destructors, value) {\n                    if (value instanceof ArrayBuffer) value = new Uint8Array(value);\n                    var length;\n                    var valueIsOfTypeString = typeof value == \"string\";\n                    if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) throwBindingError(\"Cannot pass non-string to std::string\");\n                    if (stdStringIsUTF8 && valueIsOfTypeString) length = lengthBytesUTF8(value);\n                    else length = value.length;\n                    var base = _malloc(4 + length + 1);\n                    var ptr = base + 4;\n                    GROWABLE_HEAP_U32()[base >> 2] = length;\n                    if (stdStringIsUTF8 && valueIsOfTypeString) stringToUTF8(value, ptr, length + 1);\n                    else {\n                        if (valueIsOfTypeString) for(var i = 0; i < length; ++i){\n                            var charCode = value.charCodeAt(i);\n                            if (charCode > 255) {\n                                _free(ptr);\n                                throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\n                            }\n                            GROWABLE_HEAP_U8()[ptr + i] = charCode;\n                        }\n                        else for(var i = 0; i < length; ++i)GROWABLE_HEAP_U8()[ptr + i] = value[i];\n                    }\n                    if (destructors !== null) destructors.push(_free, base);\n                    return base;\n                },\n                \"argPackAdvance\": 8,\n                \"readValueFromPointer\": simpleReadValueFromPointer,\n                destructorFunction: function(ptr) {\n                    _free(ptr);\n                }\n            });\n        }\n        var UTF16Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n        function UTF16ToString(ptr, maxBytesToRead) {\n            assert(ptr % 2 == 0, \"Pointer passed to UTF16ToString must be aligned to two bytes!\");\n            var endPtr = ptr;\n            var idx = endPtr >> 1;\n            var maxIdx = idx + maxBytesToRead / 2;\n            while(!(idx >= maxIdx) && GROWABLE_HEAP_U16()[idx])++idx;\n            endPtr = idx << 1;\n            if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(GROWABLE_HEAP_U8().slice(ptr, endPtr));\n            var str = \"\";\n            for(var i = 0; !(i >= maxBytesToRead / 2); ++i){\n                var codeUnit = GROWABLE_HEAP_I16()[ptr + i * 2 >> 1];\n                if (codeUnit == 0) break;\n                str += String.fromCharCode(codeUnit);\n            }\n            return str;\n        }\n        function stringToUTF16(str, outPtr, maxBytesToWrite) {\n            assert(outPtr % 2 == 0, \"Pointer passed to stringToUTF16 must be aligned to two bytes!\");\n            assert(typeof maxBytesToWrite == \"number\", \"stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n            if (maxBytesToWrite === undefined) maxBytesToWrite = 2147483647;\n            if (maxBytesToWrite < 2) return 0;\n            maxBytesToWrite -= 2;\n            var startPtr = outPtr;\n            var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n            for(var i = 0; i < numCharsToWrite; ++i){\n                var codeUnit = str.charCodeAt(i);\n                GROWABLE_HEAP_I16()[outPtr >> 1] = codeUnit;\n                outPtr += 2;\n            }\n            GROWABLE_HEAP_I16()[outPtr >> 1] = 0;\n            return outPtr - startPtr;\n        }\n        function lengthBytesUTF16(str) {\n            return str.length * 2;\n        }\n        function UTF32ToString(ptr, maxBytesToRead) {\n            assert(ptr % 4 == 0, \"Pointer passed to UTF32ToString must be aligned to four bytes!\");\n            var i = 0;\n            var str = \"\";\n            while(!(i >= maxBytesToRead / 4)){\n                var utf32 = GROWABLE_HEAP_I32()[ptr + i * 4 >> 2];\n                if (utf32 == 0) break;\n                ++i;\n                if (utf32 >= 65536) {\n                    var ch = utf32 - 65536;\n                    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n                } else str += String.fromCharCode(utf32);\n            }\n            return str;\n        }\n        function stringToUTF32(str, outPtr, maxBytesToWrite) {\n            assert(outPtr % 4 == 0, \"Pointer passed to stringToUTF32 must be aligned to four bytes!\");\n            assert(typeof maxBytesToWrite == \"number\", \"stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n            if (maxBytesToWrite === undefined) maxBytesToWrite = 2147483647;\n            if (maxBytesToWrite < 4) return 0;\n            var startPtr = outPtr;\n            var endPtr = startPtr + maxBytesToWrite - 4;\n            for(var i = 0; i < str.length; ++i){\n                var codeUnit = str.charCodeAt(i);\n                if (codeUnit >= 55296 && codeUnit <= 57343) {\n                    var trailSurrogate = str.charCodeAt(++i);\n                    codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n                }\n                GROWABLE_HEAP_I32()[outPtr >> 2] = codeUnit;\n                outPtr += 4;\n                if (outPtr + 4 > endPtr) break;\n            }\n            GROWABLE_HEAP_I32()[outPtr >> 2] = 0;\n            return outPtr - startPtr;\n        }\n        function lengthBytesUTF32(str) {\n            var len = 0;\n            for(var i = 0; i < str.length; ++i){\n                var codeUnit = str.charCodeAt(i);\n                if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n                len += 4;\n            }\n            return len;\n        }\n        function __embind_register_std_wstring(rawType, charSize, name) {\n            name = readLatin1String(name);\n            var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n            if (charSize === 2) {\n                decodeString = UTF16ToString;\n                encodeString = stringToUTF16;\n                lengthBytesUTF = lengthBytesUTF16;\n                getHeap = ()=>GROWABLE_HEAP_U16();\n                shift = 1;\n            } else if (charSize === 4) {\n                decodeString = UTF32ToString;\n                encodeString = stringToUTF32;\n                lengthBytesUTF = lengthBytesUTF32;\n                getHeap = ()=>GROWABLE_HEAP_U32();\n                shift = 2;\n            }\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": function(value) {\n                    var length = GROWABLE_HEAP_U32()[value >> 2];\n                    var HEAP = getHeap();\n                    var str;\n                    var decodeStartPtr = value + 4;\n                    for(var i = 0; i <= length; ++i){\n                        var currentBytePtr = value + 4 + i * charSize;\n                        if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n                            var maxReadBytes = currentBytePtr - decodeStartPtr;\n                            var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n                            if (str === undefined) str = stringSegment;\n                            else {\n                                str += String.fromCharCode(0);\n                                str += stringSegment;\n                            }\n                            decodeStartPtr = currentBytePtr + charSize;\n                        }\n                    }\n                    _free(value);\n                    return str;\n                },\n                \"toWireType\": function(destructors, value) {\n                    if (!(typeof value == \"string\")) throwBindingError(\"Cannot pass non-string to C++ string type \" + name);\n                    var length = lengthBytesUTF(value);\n                    var ptr = _malloc(4 + length + charSize);\n                    GROWABLE_HEAP_U32()[ptr >> 2] = length >> shift;\n                    encodeString(value, ptr + 4, length + charSize);\n                    if (destructors !== null) destructors.push(_free, ptr);\n                    return ptr;\n                },\n                \"argPackAdvance\": 8,\n                \"readValueFromPointer\": simpleReadValueFromPointer,\n                destructorFunction: function(ptr) {\n                    _free(ptr);\n                }\n            });\n        }\n        function __embind_register_void(rawType, name) {\n            name = readLatin1String(name);\n            registerType(rawType, {\n                isVoid: true,\n                name: name,\n                \"argPackAdvance\": 0,\n                \"fromWireType\": function() {\n                    return undefined;\n                },\n                \"toWireType\": function(destructors, o) {\n                    return undefined;\n                }\n            });\n        }\n        function __emscripten_default_pthread_stack_size() {\n            return 65536;\n        }\n        var nowIsMonotonic = true;\n        function __emscripten_get_now_is_monotonic() {\n            return nowIsMonotonic;\n        }\n        function maybeExit() {\n            if (!keepRuntimeAlive()) try {\n                if (ENVIRONMENT_IS_PTHREAD) __emscripten_thread_exit(EXITSTATUS);\n                else _exit(EXITSTATUS);\n            } catch (e) {\n                handleException(e);\n            }\n        }\n        function callUserCallback(func) {\n            if (ABORT) {\n                err(\"user callback triggered after runtime exited or application aborted.  Ignoring.\");\n                return;\n            }\n            try {\n                func();\n                maybeExit();\n            } catch (e) {\n                handleException(e);\n            }\n        }\n        function __emscripten_thread_mailbox_await(pthread_ptr) {\n            if (typeof Atomics.waitAsync === \"function\") {\n                var wait = Atomics.waitAsync(GROWABLE_HEAP_I32(), pthread_ptr >> 2, pthread_ptr);\n                assert(wait.async);\n                wait.value.then(checkMailbox);\n                var waitingAsync = pthread_ptr + 128;\n                Atomics.store(GROWABLE_HEAP_I32(), waitingAsync >> 2, 1);\n            }\n        }\n        Module[\"__emscripten_thread_mailbox_await\"] = __emscripten_thread_mailbox_await;\n        function checkMailbox() {\n            var pthread_ptr = _pthread_self();\n            if (pthread_ptr) {\n                __emscripten_thread_mailbox_await(pthread_ptr);\n                callUserCallback(()=>__emscripten_check_mailbox());\n            }\n        }\n        Module[\"checkMailbox\"] = checkMailbox;\n        function __emscripten_notify_mailbox_postmessage(targetThreadId, currThreadId, mainThreadId) {\n            if (targetThreadId == currThreadId) setTimeout(()=>checkMailbox());\n            else if (ENVIRONMENT_IS_PTHREAD) postMessage({\n                \"targetThread\": targetThreadId,\n                \"cmd\": \"checkMailbox\"\n            });\n            else {\n                var worker = PThread.pthreads[targetThreadId];\n                if (!worker) {\n                    err(\"Cannot send message to thread with ID \" + targetThreadId + \", unknown thread ID!\");\n                    return;\n                }\n                worker.postMessage({\n                    \"cmd\": \"checkMailbox\"\n                });\n            }\n        }\n        function __emscripten_set_offscreencanvas_size(target, width, height) {\n            err(\"emscripten_set_offscreencanvas_size: Build with -sOFFSCREENCANVAS_SUPPORT=1 to enable transferring canvases to pthreads.\");\n            return -1;\n        }\n        function emval_lookupTypes(argCount, argTypes) {\n            var a = new Array(argCount);\n            for(var i = 0; i < argCount; ++i)a[i] = requireRegisteredType(GROWABLE_HEAP_U32()[argTypes + i * 4 >> 2], \"parameter \" + i);\n            return a;\n        }\n        function __emval_call(handle, argCount, argTypes, argv) {\n            handle = Emval.toValue(handle);\n            var types = emval_lookupTypes(argCount, argTypes);\n            var args = new Array(argCount);\n            for(var i = 0; i < argCount; ++i){\n                var type = types[i];\n                args[i] = type[\"readValueFromPointer\"](argv);\n                argv += type[\"argPackAdvance\"];\n            }\n            var rv = handle.apply(undefined, args);\n            return Emval.toHandle(rv);\n        }\n        function __emval_incref(handle) {\n            if (handle > 4) emval_handles.get(handle).refcount += 1;\n        }\n        function __emval_take_value(type, arg) {\n            type = requireRegisteredType(type, \"_emval_take_value\");\n            var v = type[\"readValueFromPointer\"](arg);\n            return Emval.toHandle(v);\n        }\n        function _abort() {\n            abort(\"native code called abort()\");\n        }\n        function _emscripten_check_blocking_allowed() {\n            if (ENVIRONMENT_IS_WORKER) return;\n            warnOnce(\"Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread\");\n        }\n        function _emscripten_date_now() {\n            return Date.now();\n        }\n        function runtimeKeepalivePush() {\n            runtimeKeepaliveCounter += 1;\n        }\n        function _emscripten_exit_with_live_runtime() {\n            runtimeKeepalivePush();\n            throw \"unwind\";\n        }\n        function getHeapMax() {\n            return 2147483648;\n        }\n        function _emscripten_get_heap_max() {\n            return getHeapMax();\n        }\n        var _emscripten_get_now;\n        _emscripten_get_now = ()=>performance.timeOrigin + performance.now();\n        function _emscripten_num_logical_cores() {\n            return navigator[\"hardwareConcurrency\"];\n        }\n        function proxyToMainThread(index, sync) {\n            var numCallArgs = arguments.length - 2;\n            var outerArgs = arguments;\n            var maxArgs = 19;\n            if (numCallArgs > maxArgs) throw \"proxyToMainThread: Too many arguments \" + numCallArgs + \" to proxied function idx=\" + index + \", maximum supported is \" + maxArgs;\n            return withStackSave(()=>{\n                var serializedNumCallArgs = numCallArgs;\n                var args = stackAlloc(serializedNumCallArgs * 8);\n                var b = args >> 3;\n                for(var i = 0; i < numCallArgs; i++){\n                    var arg = outerArgs[2 + i];\n                    GROWABLE_HEAP_F64()[b + i] = arg;\n                }\n                return __emscripten_run_in_main_runtime_thread_js(index, serializedNumCallArgs, args, sync);\n            });\n        }\n        var emscripten_receive_on_main_thread_js_callArgs = [];\n        function _emscripten_receive_on_main_thread_js(index, numCallArgs, args) {\n            emscripten_receive_on_main_thread_js_callArgs.length = numCallArgs;\n            var b = args >> 3;\n            for(var i = 0; i < numCallArgs; i++)emscripten_receive_on_main_thread_js_callArgs[i] = GROWABLE_HEAP_F64()[b + i];\n            var func = proxiedFunctionTable[index];\n            assert(func.length == numCallArgs, \"Call args mismatch in emscripten_receive_on_main_thread_js\");\n            return func.apply(null, emscripten_receive_on_main_thread_js_callArgs);\n        }\n        function emscripten_realloc_buffer(size) {\n            var b = wasmMemory.buffer;\n            try {\n                wasmMemory.grow(size - b.byteLength + 65535 >>> 16);\n                updateMemoryViews();\n                return 1;\n            } catch (e) {\n                err(\"emscripten_realloc_buffer: Attempted to grow heap from \" + b.byteLength + \" bytes to \" + size + \" bytes, but got error: \" + e);\n            }\n        }\n        function _emscripten_resize_heap(requestedSize) {\n            var oldSize = GROWABLE_HEAP_U8().length;\n            requestedSize = requestedSize >>> 0;\n            if (requestedSize <= oldSize) return false;\n            var maxHeapSize = getHeapMax();\n            if (requestedSize > maxHeapSize) {\n                err(\"Cannot enlarge memory, asked to go up to \" + requestedSize + \" bytes, but the limit is \" + maxHeapSize + \" bytes!\");\n                return false;\n            }\n            let alignUp = (x, multiple)=>x + (multiple - x % multiple) % multiple;\n            for(var cutDown = 1; cutDown <= 4; cutDown *= 2){\n                var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n                overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n                var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n                var replacement = emscripten_realloc_buffer(newSize);\n                if (replacement) return true;\n            }\n            err(\"Failed to grow the heap from \" + oldSize + \" bytes to \" + newSize + \" bytes, not enough memory!\");\n            return false;\n        }\n        var ENV = {};\n        function getExecutableName() {\n            return thisProgram || \"./this.program\";\n        }\n        function getEnvStrings() {\n            if (!getEnvStrings.strings) {\n                var lang = (typeof navigator == \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\";\n                var env = {\n                    \"USER\": \"web_user\",\n                    \"LOGNAME\": \"web_user\",\n                    \"PATH\": \"/\",\n                    \"PWD\": \"/\",\n                    \"HOME\": \"/home/web_user\",\n                    \"LANG\": lang,\n                    \"_\": getExecutableName()\n                };\n                for(var x in ENV)if (ENV[x] === undefined) delete env[x];\n                else env[x] = ENV[x];\n                var strings = [];\n                for(var x in env)strings.push(x + \"=\" + env[x]);\n                getEnvStrings.strings = strings;\n            }\n            return getEnvStrings.strings;\n        }\n        function stringToAscii(str, buffer) {\n            for(var i = 0; i < str.length; ++i){\n                assert(str.charCodeAt(i) === (str.charCodeAt(i) & 255));\n                GROWABLE_HEAP_I8()[buffer++ >> 0] = str.charCodeAt(i);\n            }\n            GROWABLE_HEAP_I8()[buffer >> 0] = 0;\n        }\n        function _environ_get(__environ, environ_buf) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(4, 1, __environ, environ_buf);\n            var bufSize = 0;\n            getEnvStrings().forEach(function(string, i) {\n                var ptr = environ_buf + bufSize;\n                GROWABLE_HEAP_U32()[__environ + i * 4 >> 2] = ptr;\n                stringToAscii(string, ptr);\n                bufSize += string.length + 1;\n            });\n            return 0;\n        }\n        function _environ_sizes_get(penviron_count, penviron_buf_size) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(5, 1, penviron_count, penviron_buf_size);\n            var strings = getEnvStrings();\n            GROWABLE_HEAP_U32()[penviron_count >> 2] = strings.length;\n            var bufSize = 0;\n            strings.forEach(function(string) {\n                bufSize += string.length + 1;\n            });\n            GROWABLE_HEAP_U32()[penviron_buf_size >> 2] = bufSize;\n            return 0;\n        }\n        function _fd_close(fd) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(6, 1, fd);\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                FS.close(stream);\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        function doReadv(stream, iov, iovcnt, offset) {\n            var ret = 0;\n            for(var i = 0; i < iovcnt; i++){\n                var ptr = GROWABLE_HEAP_U32()[iov >> 2];\n                var len = GROWABLE_HEAP_U32()[iov + 4 >> 2];\n                iov += 8;\n                var curr = FS.read(stream, GROWABLE_HEAP_I8(), ptr, len, offset);\n                if (curr < 0) return -1;\n                ret += curr;\n                if (curr < len) break;\n                if (typeof offset !== \"undefined\") offset += curr;\n            }\n            return ret;\n        }\n        function _fd_read(fd, iov, iovcnt, pnum) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(7, 1, fd, iov, iovcnt, pnum);\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                var num = doReadv(stream, iov, iovcnt);\n                GROWABLE_HEAP_U32()[pnum >> 2] = num;\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        function convertI32PairToI53Checked(lo, hi) {\n            assert(lo == lo >>> 0 || lo == (lo | 0));\n            assert(hi === (hi | 0));\n            return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;\n        }\n        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(8, 1, fd, offset_low, offset_high, whence, newOffset);\n            try {\n                var offset = convertI32PairToI53Checked(offset_low, offset_high);\n                if (isNaN(offset)) return 61;\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                FS.llseek(stream, offset, whence);\n                tempI64 = [\n                    stream.position >>> 0,\n                    (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], GROWABLE_HEAP_I32()[newOffset >> 2] = tempI64[0], GROWABLE_HEAP_I32()[newOffset + 4 >> 2] = tempI64[1];\n                if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        function doWritev(stream, iov, iovcnt, offset) {\n            var ret = 0;\n            for(var i = 0; i < iovcnt; i++){\n                var ptr = GROWABLE_HEAP_U32()[iov >> 2];\n                var len = GROWABLE_HEAP_U32()[iov + 4 >> 2];\n                iov += 8;\n                var curr = FS.write(stream, GROWABLE_HEAP_I8(), ptr, len, offset);\n                if (curr < 0) return -1;\n                ret += curr;\n                if (typeof offset !== \"undefined\") offset += curr;\n            }\n            return ret;\n        }\n        function _fd_write(fd, iov, iovcnt, pnum) {\n            if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(9, 1, fd, iov, iovcnt, pnum);\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                var num = doWritev(stream, iov, iovcnt);\n                GROWABLE_HEAP_U32()[pnum >> 2] = num;\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        function isLeapYear(year) {\n            return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n        }\n        function arraySum(array, index) {\n            var sum = 0;\n            for(var i = 0; i <= index; sum += array[i++]);\n            return sum;\n        }\n        var MONTH_DAYS_LEAP = [\n            31,\n            29,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ];\n        var MONTH_DAYS_REGULAR = [\n            31,\n            28,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ];\n        function addDays(date, days) {\n            var newDate = new Date(date.getTime());\n            while(days > 0){\n                var leap = isLeapYear(newDate.getFullYear());\n                var currentMonth = newDate.getMonth();\n                var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];\n                if (days > daysInCurrentMonth - newDate.getDate()) {\n                    days -= daysInCurrentMonth - newDate.getDate() + 1;\n                    newDate.setDate(1);\n                    if (currentMonth < 11) newDate.setMonth(currentMonth + 1);\n                    else {\n                        newDate.setMonth(0);\n                        newDate.setFullYear(newDate.getFullYear() + 1);\n                    }\n                } else {\n                    newDate.setDate(newDate.getDate() + days);\n                    return newDate;\n                }\n            }\n            return newDate;\n        }\n        function writeArrayToMemory(array, buffer) {\n            assert(array.length >= 0, \"writeArrayToMemory array must have a length (should be an array or typed array)\");\n            GROWABLE_HEAP_I8().set(array, buffer);\n        }\n        function _strftime(s, maxsize, format, tm) {\n            var tm_zone = GROWABLE_HEAP_I32()[tm + 40 >> 2];\n            var date = {\n                tm_sec: GROWABLE_HEAP_I32()[tm >> 2],\n                tm_min: GROWABLE_HEAP_I32()[tm + 4 >> 2],\n                tm_hour: GROWABLE_HEAP_I32()[tm + 8 >> 2],\n                tm_mday: GROWABLE_HEAP_I32()[tm + 12 >> 2],\n                tm_mon: GROWABLE_HEAP_I32()[tm + 16 >> 2],\n                tm_year: GROWABLE_HEAP_I32()[tm + 20 >> 2],\n                tm_wday: GROWABLE_HEAP_I32()[tm + 24 >> 2],\n                tm_yday: GROWABLE_HEAP_I32()[tm + 28 >> 2],\n                tm_isdst: GROWABLE_HEAP_I32()[tm + 32 >> 2],\n                tm_gmtoff: GROWABLE_HEAP_I32()[tm + 36 >> 2],\n                tm_zone: tm_zone ? UTF8ToString(tm_zone) : \"\"\n            };\n            var pattern = UTF8ToString(format);\n            var EXPANSION_RULES_1 = {\n                \"%c\": \"%a %b %d %H:%M:%S %Y\",\n                \"%D\": \"%m/%d/%y\",\n                \"%F\": \"%Y-%m-%d\",\n                \"%h\": \"%b\",\n                \"%r\": \"%I:%M:%S %p\",\n                \"%R\": \"%H:%M\",\n                \"%T\": \"%H:%M:%S\",\n                \"%x\": \"%m/%d/%y\",\n                \"%X\": \"%H:%M:%S\",\n                \"%Ec\": \"%c\",\n                \"%EC\": \"%C\",\n                \"%Ex\": \"%m/%d/%y\",\n                \"%EX\": \"%H:%M:%S\",\n                \"%Ey\": \"%y\",\n                \"%EY\": \"%Y\",\n                \"%Od\": \"%d\",\n                \"%Oe\": \"%e\",\n                \"%OH\": \"%H\",\n                \"%OI\": \"%I\",\n                \"%Om\": \"%m\",\n                \"%OM\": \"%M\",\n                \"%OS\": \"%S\",\n                \"%Ou\": \"%u\",\n                \"%OU\": \"%U\",\n                \"%OV\": \"%V\",\n                \"%Ow\": \"%w\",\n                \"%OW\": \"%W\",\n                \"%Oy\": \"%y\"\n            };\n            for(var rule in EXPANSION_RULES_1)pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_1[rule]);\n            var WEEKDAYS = [\n                \"Sunday\",\n                \"Monday\",\n                \"Tuesday\",\n                \"Wednesday\",\n                \"Thursday\",\n                \"Friday\",\n                \"Saturday\"\n            ];\n            var MONTHS = [\n                \"January\",\n                \"February\",\n                \"March\",\n                \"April\",\n                \"May\",\n                \"June\",\n                \"July\",\n                \"August\",\n                \"September\",\n                \"October\",\n                \"November\",\n                \"December\"\n            ];\n            function leadingSomething(value, digits, character) {\n                var str = typeof value == \"number\" ? value.toString() : value || \"\";\n                while(str.length < digits)str = character[0] + str;\n                return str;\n            }\n            function leadingNulls(value, digits) {\n                return leadingSomething(value, digits, \"0\");\n            }\n            function compareByDay(date1, date2) {\n                function sgn(value) {\n                    return value < 0 ? -1 : value > 0 ? 1 : 0;\n                }\n                var compare;\n                if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n                    if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) compare = sgn(date1.getDate() - date2.getDate());\n                }\n                return compare;\n            }\n            function getFirstWeekStartDate(janFourth) {\n                switch(janFourth.getDay()){\n                    case 0:\n                        return new Date(janFourth.getFullYear() - 1, 11, 29);\n                    case 1:\n                        return janFourth;\n                    case 2:\n                        return new Date(janFourth.getFullYear(), 0, 3);\n                    case 3:\n                        return new Date(janFourth.getFullYear(), 0, 2);\n                    case 4:\n                        return new Date(janFourth.getFullYear(), 0, 1);\n                    case 5:\n                        return new Date(janFourth.getFullYear() - 1, 11, 31);\n                    case 6:\n                        return new Date(janFourth.getFullYear() - 1, 11, 30);\n                }\n            }\n            function getWeekBasedYear(date) {\n                var thisDate = addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n                var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\n                var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\n                var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n                var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n                if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n                    if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) return thisDate.getFullYear() + 1;\n                    return thisDate.getFullYear();\n                }\n                return thisDate.getFullYear() - 1;\n            }\n            var EXPANSION_RULES_2 = {\n                \"%a\": function(date) {\n                    return WEEKDAYS[date.tm_wday].substring(0, 3);\n                },\n                \"%A\": function(date) {\n                    return WEEKDAYS[date.tm_wday];\n                },\n                \"%b\": function(date) {\n                    return MONTHS[date.tm_mon].substring(0, 3);\n                },\n                \"%B\": function(date) {\n                    return MONTHS[date.tm_mon];\n                },\n                \"%C\": function(date) {\n                    var year = date.tm_year + 1900;\n                    return leadingNulls(year / 100 | 0, 2);\n                },\n                \"%d\": function(date) {\n                    return leadingNulls(date.tm_mday, 2);\n                },\n                \"%e\": function(date) {\n                    return leadingSomething(date.tm_mday, 2, \" \");\n                },\n                \"%g\": function(date) {\n                    return getWeekBasedYear(date).toString().substring(2);\n                },\n                \"%G\": function(date) {\n                    return getWeekBasedYear(date);\n                },\n                \"%H\": function(date) {\n                    return leadingNulls(date.tm_hour, 2);\n                },\n                \"%I\": function(date) {\n                    var twelveHour = date.tm_hour;\n                    if (twelveHour == 0) twelveHour = 12;\n                    else if (twelveHour > 12) twelveHour -= 12;\n                    return leadingNulls(twelveHour, 2);\n                },\n                \"%j\": function(date) {\n                    return leadingNulls(date.tm_mday + arraySum(isLeapYear(date.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date.tm_mon - 1), 3);\n                },\n                \"%m\": function(date) {\n                    return leadingNulls(date.tm_mon + 1, 2);\n                },\n                \"%M\": function(date) {\n                    return leadingNulls(date.tm_min, 2);\n                },\n                \"%n\": function() {\n                    return \"\\n\";\n                },\n                \"%p\": function(date) {\n                    if (date.tm_hour >= 0 && date.tm_hour < 12) return \"AM\";\n                    return \"PM\";\n                },\n                \"%S\": function(date) {\n                    return leadingNulls(date.tm_sec, 2);\n                },\n                \"%t\": function() {\n                    return \"\t\";\n                },\n                \"%u\": function(date) {\n                    return date.tm_wday || 7;\n                },\n                \"%U\": function(date) {\n                    var days = date.tm_yday + 7 - date.tm_wday;\n                    return leadingNulls(Math.floor(days / 7), 2);\n                },\n                \"%V\": function(date) {\n                    var val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7) / 7);\n                    if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) val++;\n                    if (!val) {\n                        val = 52;\n                        var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;\n                        if (dec31 == 4 || dec31 == 5 && isLeapYear(date.tm_year % 400 - 1)) val++;\n                    } else if (val == 53) {\n                        var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;\n                        if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date.tm_year))) val = 1;\n                    }\n                    return leadingNulls(val, 2);\n                },\n                \"%w\": function(date) {\n                    return date.tm_wday;\n                },\n                \"%W\": function(date) {\n                    var days = date.tm_yday + 7 - (date.tm_wday + 6) % 7;\n                    return leadingNulls(Math.floor(days / 7), 2);\n                },\n                \"%y\": function(date) {\n                    return (date.tm_year + 1900).toString().substring(2);\n                },\n                \"%Y\": function(date) {\n                    return date.tm_year + 1900;\n                },\n                \"%z\": function(date) {\n                    var off = date.tm_gmtoff;\n                    var ahead = off >= 0;\n                    off = Math.abs(off) / 60;\n                    off = off / 60 * 100 + off % 60;\n                    return (ahead ? \"+\" : \"-\") + String(\"0000\" + off).slice(-4);\n                },\n                \"%Z\": function(date) {\n                    return date.tm_zone;\n                },\n                \"%%\": function() {\n                    return \"%\";\n                }\n            };\n            pattern = pattern.replace(/%%/g, \"\\x00\\x00\");\n            for(var rule in EXPANSION_RULES_2)if (pattern.includes(rule)) pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_2[rule](date));\n            pattern = pattern.replace(/\\0\\0/g, \"%\");\n            var bytes = intArrayFromString(pattern, false);\n            if (bytes.length > maxsize) return 0;\n            writeArrayToMemory(bytes, s);\n            return bytes.length - 1;\n        }\n        function _strftime_l(s, maxsize, format, tm, loc) {\n            return _strftime(s, maxsize, format, tm);\n        }\n        PThread.init();\n        var FSNode = function(parent, name, mode, rdev) {\n            if (!parent) parent = this;\n            this.parent = parent;\n            this.mount = parent.mount;\n            this.mounted = null;\n            this.id = FS.nextInode++;\n            this.name = name;\n            this.mode = mode;\n            this.node_ops = {};\n            this.stream_ops = {};\n            this.rdev = rdev;\n        };\n        var readMode = 365;\n        var writeMode = 146;\n        Object.defineProperties(FSNode.prototype, {\n            read: {\n                get: function() {\n                    return (this.mode & readMode) === readMode;\n                },\n                set: function(val) {\n                    val ? this.mode |= readMode : this.mode &= ~readMode;\n                }\n            },\n            write: {\n                get: function() {\n                    return (this.mode & writeMode) === writeMode;\n                },\n                set: function(val) {\n                    val ? this.mode |= writeMode : this.mode &= ~writeMode;\n                }\n            },\n            isFolder: {\n                get: function() {\n                    return FS.isDir(this.mode);\n                }\n            },\n            isDevice: {\n                get: function() {\n                    return FS.isChrdev(this.mode);\n                }\n            }\n        });\n        FS.FSNode = FSNode;\n        FS.staticInit();\n        ERRNO_CODES = {\n            \"EPERM\": 63,\n            \"ENOENT\": 44,\n            \"ESRCH\": 71,\n            \"EINTR\": 27,\n            \"EIO\": 29,\n            \"ENXIO\": 60,\n            \"E2BIG\": 1,\n            \"ENOEXEC\": 45,\n            \"EBADF\": 8,\n            \"ECHILD\": 12,\n            \"EAGAIN\": 6,\n            \"EWOULDBLOCK\": 6,\n            \"ENOMEM\": 48,\n            \"EACCES\": 2,\n            \"EFAULT\": 21,\n            \"ENOTBLK\": 105,\n            \"EBUSY\": 10,\n            \"EEXIST\": 20,\n            \"EXDEV\": 75,\n            \"ENODEV\": 43,\n            \"ENOTDIR\": 54,\n            \"EISDIR\": 31,\n            \"EINVAL\": 28,\n            \"ENFILE\": 41,\n            \"EMFILE\": 33,\n            \"ENOTTY\": 59,\n            \"ETXTBSY\": 74,\n            \"EFBIG\": 22,\n            \"ENOSPC\": 51,\n            \"ESPIPE\": 70,\n            \"EROFS\": 69,\n            \"EMLINK\": 34,\n            \"EPIPE\": 64,\n            \"EDOM\": 18,\n            \"ERANGE\": 68,\n            \"ENOMSG\": 49,\n            \"EIDRM\": 24,\n            \"ECHRNG\": 106,\n            \"EL2NSYNC\": 156,\n            \"EL3HLT\": 107,\n            \"EL3RST\": 108,\n            \"ELNRNG\": 109,\n            \"EUNATCH\": 110,\n            \"ENOCSI\": 111,\n            \"EL2HLT\": 112,\n            \"EDEADLK\": 16,\n            \"ENOLCK\": 46,\n            \"EBADE\": 113,\n            \"EBADR\": 114,\n            \"EXFULL\": 115,\n            \"ENOANO\": 104,\n            \"EBADRQC\": 103,\n            \"EBADSLT\": 102,\n            \"EDEADLOCK\": 16,\n            \"EBFONT\": 101,\n            \"ENOSTR\": 100,\n            \"ENODATA\": 116,\n            \"ETIME\": 117,\n            \"ENOSR\": 118,\n            \"ENONET\": 119,\n            \"ENOPKG\": 120,\n            \"EREMOTE\": 121,\n            \"ENOLINK\": 47,\n            \"EADV\": 122,\n            \"ESRMNT\": 123,\n            \"ECOMM\": 124,\n            \"EPROTO\": 65,\n            \"EMULTIHOP\": 36,\n            \"EDOTDOT\": 125,\n            \"EBADMSG\": 9,\n            \"ENOTUNIQ\": 126,\n            \"EBADFD\": 127,\n            \"EREMCHG\": 128,\n            \"ELIBACC\": 129,\n            \"ELIBBAD\": 130,\n            \"ELIBSCN\": 131,\n            \"ELIBMAX\": 132,\n            \"ELIBEXEC\": 133,\n            \"ENOSYS\": 52,\n            \"ENOTEMPTY\": 55,\n            \"ENAMETOOLONG\": 37,\n            \"ELOOP\": 32,\n            \"EOPNOTSUPP\": 138,\n            \"EPFNOSUPPORT\": 139,\n            \"ECONNRESET\": 15,\n            \"ENOBUFS\": 42,\n            \"EAFNOSUPPORT\": 5,\n            \"EPROTOTYPE\": 67,\n            \"ENOTSOCK\": 57,\n            \"ENOPROTOOPT\": 50,\n            \"ESHUTDOWN\": 140,\n            \"ECONNREFUSED\": 14,\n            \"EADDRINUSE\": 3,\n            \"ECONNABORTED\": 13,\n            \"ENETUNREACH\": 40,\n            \"ENETDOWN\": 38,\n            \"ETIMEDOUT\": 73,\n            \"EHOSTDOWN\": 142,\n            \"EHOSTUNREACH\": 23,\n            \"EINPROGRESS\": 26,\n            \"EALREADY\": 7,\n            \"EDESTADDRREQ\": 17,\n            \"EMSGSIZE\": 35,\n            \"EPROTONOSUPPORT\": 66,\n            \"ESOCKTNOSUPPORT\": 137,\n            \"EADDRNOTAVAIL\": 4,\n            \"ENETRESET\": 39,\n            \"EISCONN\": 30,\n            \"ENOTCONN\": 53,\n            \"ETOOMANYREFS\": 141,\n            \"EUSERS\": 136,\n            \"EDQUOT\": 19,\n            \"ESTALE\": 72,\n            \"ENOTSUP\": 138,\n            \"ENOMEDIUM\": 148,\n            \"EILSEQ\": 25,\n            \"EOVERFLOW\": 61,\n            \"ECANCELED\": 11,\n            \"ENOTRECOVERABLE\": 56,\n            \"EOWNERDEAD\": 62,\n            \"ESTRPIPE\": 135\n        };\n        embind_init_charCodes();\n        BindingError = Module[\"BindingError\"] = extendError(Error, \"BindingError\");\n        InternalError = Module[\"InternalError\"] = extendError(Error, \"InternalError\");\n        init_ClassHandle();\n        init_embind();\n        init_RegisteredPointer();\n        UnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n        init_emval();\n        var proxiedFunctionTable = [\n            null,\n            _proc_exit,\n            exitOnMainThread,\n            pthreadCreateProxied,\n            _environ_get,\n            _environ_sizes_get,\n            _fd_close,\n            _fd_read,\n            _fd_seek,\n            _fd_write\n        ];\n        function checkIncomingModuleAPI() {\n            ignoredModuleProp(\"fetchSettings\");\n        }\n        var wasmImports = {\n            \"__assert_fail\": ___assert_fail,\n            \"__call_sighandler\": ___call_sighandler,\n            \"__emscripten_init_main_thread_js\": ___emscripten_init_main_thread_js,\n            \"__emscripten_thread_cleanup\": ___emscripten_thread_cleanup,\n            \"__pthread_create_js\": ___pthread_create_js,\n            \"__throw_exception_with_stack_trace\": ___throw_exception_with_stack_trace,\n            \"_embind_register_bigint\": __embind_register_bigint,\n            \"_embind_register_bool\": __embind_register_bool,\n            \"_embind_register_class\": __embind_register_class,\n            \"_embind_register_class_constructor\": __embind_register_class_constructor,\n            \"_embind_register_class_function\": __embind_register_class_function,\n            \"_embind_register_emval\": __embind_register_emval,\n            \"_embind_register_enum\": __embind_register_enum,\n            \"_embind_register_enum_value\": __embind_register_enum_value,\n            \"_embind_register_float\": __embind_register_float,\n            \"_embind_register_integer\": __embind_register_integer,\n            \"_embind_register_memory_view\": __embind_register_memory_view,\n            \"_embind_register_smart_ptr\": __embind_register_smart_ptr,\n            \"_embind_register_std_string\": __embind_register_std_string,\n            \"_embind_register_std_wstring\": __embind_register_std_wstring,\n            \"_embind_register_void\": __embind_register_void,\n            \"_emscripten_default_pthread_stack_size\": __emscripten_default_pthread_stack_size,\n            \"_emscripten_get_now_is_monotonic\": __emscripten_get_now_is_monotonic,\n            \"_emscripten_notify_mailbox_postmessage\": __emscripten_notify_mailbox_postmessage,\n            \"_emscripten_set_offscreencanvas_size\": __emscripten_set_offscreencanvas_size,\n            \"_emscripten_thread_mailbox_await\": __emscripten_thread_mailbox_await,\n            \"_emval_call\": __emval_call,\n            \"_emval_decref\": __emval_decref,\n            \"_emval_incref\": __emval_incref,\n            \"_emval_take_value\": __emval_take_value,\n            \"abort\": _abort,\n            \"emscripten_check_blocking_allowed\": _emscripten_check_blocking_allowed,\n            \"emscripten_date_now\": _emscripten_date_now,\n            \"emscripten_exit_with_live_runtime\": _emscripten_exit_with_live_runtime,\n            \"emscripten_get_heap_max\": _emscripten_get_heap_max,\n            \"emscripten_get_now\": _emscripten_get_now,\n            \"emscripten_num_logical_cores\": _emscripten_num_logical_cores,\n            \"emscripten_receive_on_main_thread_js\": _emscripten_receive_on_main_thread_js,\n            \"emscripten_resize_heap\": _emscripten_resize_heap,\n            \"environ_get\": _environ_get,\n            \"environ_sizes_get\": _environ_sizes_get,\n            \"exit\": _exit,\n            \"fd_close\": _fd_close,\n            \"fd_read\": _fd_read,\n            \"fd_seek\": _fd_seek,\n            \"fd_write\": _fd_write,\n            \"memory\": wasmMemory || Module[\"wasmMemory\"],\n            \"strftime_l\": _strftime_l\n        };\n        var asm = createWasm();\n        var ___wasm_call_ctors = createExportWrapper(\"__wasm_call_ctors\");\n        var _malloc = createExportWrapper(\"malloc\");\n        var _free = Module[\"_free\"] = createExportWrapper(\"free\");\n        var __emscripten_tls_init = Module[\"__emscripten_tls_init\"] = createExportWrapper(\"_emscripten_tls_init\");\n        var _pthread_self = Module[\"_pthread_self\"] = function() {\n            return (_pthread_self = Module[\"_pthread_self\"] = Module[\"asm\"][\"pthread_self\"]).apply(null, arguments);\n        };\n        var ___getTypeName = Module[\"___getTypeName\"] = createExportWrapper(\"__getTypeName\");\n        var __embind_initialize_bindings = Module[\"__embind_initialize_bindings\"] = createExportWrapper(\"_embind_initialize_bindings\");\n        var ___errno_location = createExportWrapper(\"__errno_location\");\n        var __emscripten_thread_init = Module[\"__emscripten_thread_init\"] = createExportWrapper(\"_emscripten_thread_init\");\n        var __emscripten_thread_crashed = Module[\"__emscripten_thread_crashed\"] = createExportWrapper(\"_emscripten_thread_crashed\");\n        var _fflush = Module[\"_fflush\"] = createExportWrapper(\"fflush\");\n        var _emscripten_main_thread_process_queued_calls = createExportWrapper(\"emscripten_main_thread_process_queued_calls\");\n        var _emscripten_main_runtime_thread_id = createExportWrapper(\"emscripten_main_runtime_thread_id\");\n        var __emscripten_run_in_main_runtime_thread_js = createExportWrapper(\"_emscripten_run_in_main_runtime_thread_js\");\n        var _emscripten_dispatch_to_thread_ = createExportWrapper(\"emscripten_dispatch_to_thread_\");\n        var _emscripten_stack_get_base = function() {\n            return (_emscripten_stack_get_base = Module[\"asm\"][\"emscripten_stack_get_base\"]).apply(null, arguments);\n        };\n        var _emscripten_stack_get_end = function() {\n            return (_emscripten_stack_get_end = Module[\"asm\"][\"emscripten_stack_get_end\"]).apply(null, arguments);\n        };\n        var __emscripten_thread_free_data = createExportWrapper(\"_emscripten_thread_free_data\");\n        var __emscripten_thread_exit = Module[\"__emscripten_thread_exit\"] = createExportWrapper(\"_emscripten_thread_exit\");\n        var __emscripten_check_mailbox = Module[\"__emscripten_check_mailbox\"] = createExportWrapper(\"_emscripten_check_mailbox\");\n        var ___trap = function() {\n            return (___trap = Module[\"asm\"][\"__trap\"]).apply(null, arguments);\n        };\n        var _emscripten_stack_init = function() {\n            return (_emscripten_stack_init = Module[\"asm\"][\"emscripten_stack_init\"]).apply(null, arguments);\n        };\n        var _emscripten_stack_set_limits = function() {\n            return (_emscripten_stack_set_limits = Module[\"asm\"][\"emscripten_stack_set_limits\"]).apply(null, arguments);\n        };\n        var _emscripten_stack_get_free = function() {\n            return (_emscripten_stack_get_free = Module[\"asm\"][\"emscripten_stack_get_free\"]).apply(null, arguments);\n        };\n        var stackSave = createExportWrapper(\"stackSave\");\n        var stackRestore = createExportWrapper(\"stackRestore\");\n        var stackAlloc = createExportWrapper(\"stackAlloc\");\n        var _emscripten_stack_get_current = function() {\n            return (_emscripten_stack_get_current = Module[\"asm\"][\"emscripten_stack_get_current\"]).apply(null, arguments);\n        };\n        var ___cxa_decrement_exception_refcount = Module[\"___cxa_decrement_exception_refcount\"] = createExportWrapper(\"__cxa_decrement_exception_refcount\");\n        var ___cxa_increment_exception_refcount = Module[\"___cxa_increment_exception_refcount\"] = createExportWrapper(\"__cxa_increment_exception_refcount\");\n        var ___thrown_object_from_unwind_exception = Module[\"___thrown_object_from_unwind_exception\"] = createExportWrapper(\"__thrown_object_from_unwind_exception\");\n        var ___get_exception_message = Module[\"___get_exception_message\"] = createExportWrapper(\"__get_exception_message\");\n        var dynCall_jiji = Module[\"dynCall_jiji\"] = createExportWrapper(\"dynCall_jiji\");\n        var dynCall_viijii = Module[\"dynCall_viijii\"] = createExportWrapper(\"dynCall_viijii\");\n        var dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = createExportWrapper(\"dynCall_iiiiij\");\n        var dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = createExportWrapper(\"dynCall_iiiiijj\");\n        var dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = createExportWrapper(\"dynCall_iiiiiijj\");\n        Module[\"keepRuntimeAlive\"] = keepRuntimeAlive;\n        Module[\"wasmMemory\"] = wasmMemory;\n        Module[\"ExitStatus\"] = ExitStatus;\n        Module[\"PThread\"] = PThread;\n        var missingLibrarySymbols = [\n            \"ydayFromDate\",\n            \"setErrNo\",\n            \"inetPton4\",\n            \"inetNtop4\",\n            \"inetPton6\",\n            \"inetNtop6\",\n            \"readSockaddr\",\n            \"writeSockaddr\",\n            \"getHostByName\",\n            \"traverseStack\",\n            \"getCallstack\",\n            \"emscriptenLog\",\n            \"convertPCtoSourceLocation\",\n            \"readEmAsmArgs\",\n            \"jstoi_q\",\n            \"jstoi_s\",\n            \"listenOnce\",\n            \"autoResumeAudioContext\",\n            \"runtimeKeepalivePop\",\n            \"safeSetTimeout\",\n            \"asmjsMangle\",\n            \"getNativeTypeSize\",\n            \"STACK_SIZE\",\n            \"STACK_ALIGN\",\n            \"POINTER_SIZE\",\n            \"ASSERTIONS\",\n            \"writeI53ToI64\",\n            \"writeI53ToI64Clamped\",\n            \"writeI53ToI64Signaling\",\n            \"writeI53ToU64Clamped\",\n            \"writeI53ToU64Signaling\",\n            \"readI53FromI64\",\n            \"readI53FromU64\",\n            \"convertI32PairToI53\",\n            \"convertU32PairToI53\",\n            \"getCFunc\",\n            \"ccall\",\n            \"cwrap\",\n            \"uleb128Encode\",\n            \"sigToWasmTypes\",\n            \"generateFuncType\",\n            \"convertJsFunctionToWasm\",\n            \"getEmptyTableSlot\",\n            \"updateTableMap\",\n            \"getFunctionAddress\",\n            \"addFunction\",\n            \"removeFunction\",\n            \"reallyNegative\",\n            \"unSign\",\n            \"strLen\",\n            \"reSign\",\n            \"formatString\",\n            \"intArrayToString\",\n            \"AsciiToString\",\n            \"stringToNewUTF8\",\n            \"stringToUTF8OnStack\",\n            \"getSocketFromFD\",\n            \"getSocketAddress\",\n            \"registerKeyEventCallback\",\n            \"maybeCStringToJsString\",\n            \"findEventTarget\",\n            \"findCanvasEventTarget\",\n            \"getBoundingClientRect\",\n            \"fillMouseEventData\",\n            \"registerMouseEventCallback\",\n            \"registerWheelEventCallback\",\n            \"registerUiEventCallback\",\n            \"registerFocusEventCallback\",\n            \"fillDeviceOrientationEventData\",\n            \"registerDeviceOrientationEventCallback\",\n            \"fillDeviceMotionEventData\",\n            \"registerDeviceMotionEventCallback\",\n            \"screenOrientation\",\n            \"fillOrientationChangeEventData\",\n            \"registerOrientationChangeEventCallback\",\n            \"fillFullscreenChangeEventData\",\n            \"registerFullscreenChangeEventCallback\",\n            \"JSEvents_requestFullscreen\",\n            \"JSEvents_resizeCanvasForFullscreen\",\n            \"registerRestoreOldStyle\",\n            \"hideEverythingExceptGivenElement\",\n            \"restoreHiddenElements\",\n            \"setLetterbox\",\n            \"softFullscreenResizeWebGLRenderTarget\",\n            \"doRequestFullscreen\",\n            \"fillPointerlockChangeEventData\",\n            \"registerPointerlockChangeEventCallback\",\n            \"registerPointerlockErrorEventCallback\",\n            \"requestPointerLock\",\n            \"fillVisibilityChangeEventData\",\n            \"registerVisibilityChangeEventCallback\",\n            \"registerTouchEventCallback\",\n            \"fillGamepadEventData\",\n            \"registerGamepadEventCallback\",\n            \"registerBeforeUnloadEventCallback\",\n            \"fillBatteryEventData\",\n            \"battery\",\n            \"registerBatteryEventCallback\",\n            \"setCanvasElementSizeCallingThread\",\n            \"setCanvasElementSizeMainThread\",\n            \"setCanvasElementSize\",\n            \"getCanvasSizeCallingThread\",\n            \"getCanvasSizeMainThread\",\n            \"getCanvasElementSize\",\n            \"jsStackTrace\",\n            \"stackTrace\",\n            \"checkWasiClock\",\n            \"wasiRightsToMuslOFlags\",\n            \"wasiOFlagsToMuslOFlags\",\n            \"createDyncallWrapper\",\n            \"setImmediateWrapped\",\n            \"clearImmediateWrapped\",\n            \"polyfillSetImmediate\",\n            \"getPromise\",\n            \"makePromise\",\n            \"idsToPromises\",\n            \"makePromiseCallback\",\n            \"setMainLoop\",\n            \"_setNetworkCallback\",\n            \"heapObjectForWebGLType\",\n            \"heapAccessShiftForWebGLHeap\",\n            \"webgl_enable_ANGLE_instanced_arrays\",\n            \"webgl_enable_OES_vertex_array_object\",\n            \"webgl_enable_WEBGL_draw_buffers\",\n            \"webgl_enable_WEBGL_multi_draw\",\n            \"emscriptenWebGLGet\",\n            \"computeUnpackAlignedImageSize\",\n            \"colorChannelsInGlTextureFormat\",\n            \"emscriptenWebGLGetTexPixelData\",\n            \"__glGenObject\",\n            \"emscriptenWebGLGetUniform\",\n            \"webglGetUniformLocation\",\n            \"webglPrepareUniformLocationsBeforeFirstUse\",\n            \"webglGetLeftBracePos\",\n            \"emscriptenWebGLGetVertexAttrib\",\n            \"__glGetActiveAttribOrUniform\",\n            \"writeGLArray\",\n            \"emscripten_webgl_destroy_context_before_on_calling_thread\",\n            \"registerWebGlEventCallback\",\n            \"runAndAbortIfError\",\n            \"SDL_unicode\",\n            \"SDL_ttfContext\",\n            \"SDL_audio\",\n            \"GLFW_Window\",\n            \"ALLOC_NORMAL\",\n            \"ALLOC_STACK\",\n            \"allocate\",\n            \"writeStringToMemory\",\n            \"writeAsciiToMemory\",\n            \"registerInheritedInstance\",\n            \"unregisterInheritedInstance\",\n            \"validateThis\",\n            \"getStringOrSymbol\",\n            \"craftEmvalAllocator\",\n            \"emval_get_global\",\n            \"emval_allocateDestructors\",\n            \"emval_addMethodCaller\"\n        ];\n        missingLibrarySymbols.forEach(missingLibrarySymbol);\n        var unexportedSymbols = [\n            \"run\",\n            \"addOnPreRun\",\n            \"addOnInit\",\n            \"addOnPreMain\",\n            \"addOnExit\",\n            \"addOnPostRun\",\n            \"addRunDependency\",\n            \"removeRunDependency\",\n            \"FS_createFolder\",\n            \"FS_createPath\",\n            \"FS_createDataFile\",\n            \"FS_createPreloadedFile\",\n            \"FS_createLazyFile\",\n            \"FS_createLink\",\n            \"FS_createDevice\",\n            \"FS_unlink\",\n            \"out\",\n            \"err\",\n            \"callMain\",\n            \"abort\",\n            \"stackAlloc\",\n            \"stackSave\",\n            \"stackRestore\",\n            \"getTempRet0\",\n            \"setTempRet0\",\n            \"GROWABLE_HEAP_I8\",\n            \"GROWABLE_HEAP_U8\",\n            \"GROWABLE_HEAP_I16\",\n            \"GROWABLE_HEAP_U16\",\n            \"GROWABLE_HEAP_I32\",\n            \"GROWABLE_HEAP_U32\",\n            \"GROWABLE_HEAP_F32\",\n            \"GROWABLE_HEAP_F64\",\n            \"writeStackCookie\",\n            \"checkStackCookie\",\n            \"ptrToString\",\n            \"zeroMemory\",\n            \"exitJS\",\n            \"getHeapMax\",\n            \"emscripten_realloc_buffer\",\n            \"ENV\",\n            \"MONTH_DAYS_REGULAR\",\n            \"MONTH_DAYS_LEAP\",\n            \"MONTH_DAYS_REGULAR_CUMULATIVE\",\n            \"MONTH_DAYS_LEAP_CUMULATIVE\",\n            \"isLeapYear\",\n            \"arraySum\",\n            \"addDays\",\n            \"ERRNO_CODES\",\n            \"ERRNO_MESSAGES\",\n            \"DNS\",\n            \"Protocols\",\n            \"Sockets\",\n            \"initRandomFill\",\n            \"randomFill\",\n            \"timers\",\n            \"warnOnce\",\n            \"UNWIND_CACHE\",\n            \"readEmAsmArgsArray\",\n            \"getExecutableName\",\n            \"dynCallLegacy\",\n            \"getDynCaller\",\n            \"dynCall\",\n            \"handleException\",\n            \"runtimeKeepalivePush\",\n            \"callUserCallback\",\n            \"maybeExit\",\n            \"asyncLoad\",\n            \"alignMemory\",\n            \"mmapAlloc\",\n            \"HandleAllocator\",\n            \"convertI32PairToI53Checked\",\n            \"freeTableIndexes\",\n            \"functionsInTableMap\",\n            \"setValue\",\n            \"getValue\",\n            \"PATH\",\n            \"PATH_FS\",\n            \"UTF8Decoder\",\n            \"UTF8ArrayToString\",\n            \"UTF8ToString\",\n            \"stringToUTF8Array\",\n            \"stringToUTF8\",\n            \"lengthBytesUTF8\",\n            \"intArrayFromString\",\n            \"stringToAscii\",\n            \"UTF16Decoder\",\n            \"UTF16ToString\",\n            \"stringToUTF16\",\n            \"lengthBytesUTF16\",\n            \"UTF32ToString\",\n            \"stringToUTF32\",\n            \"lengthBytesUTF32\",\n            \"writeArrayToMemory\",\n            \"SYSCALLS\",\n            \"JSEvents\",\n            \"specialHTMLTargets\",\n            \"currentFullscreenStrategy\",\n            \"restoreOldWindowedStyle\",\n            \"demangle\",\n            \"demangleAll\",\n            \"getEnvStrings\",\n            \"doReadv\",\n            \"doWritev\",\n            \"dlopenMissingError\",\n            \"promiseMap\",\n            \"getExceptionMessageCommon\",\n            \"getCppExceptionTag\",\n            \"getCppExceptionThrownObjectFromWebAssemblyException\",\n            \"incrementExceptionRefcount\",\n            \"decrementExceptionRefcount\",\n            \"getExceptionMessage\",\n            \"Browser\",\n            \"wget\",\n            \"FS\",\n            \"MEMFS\",\n            \"TTY\",\n            \"PIPEFS\",\n            \"SOCKFS\",\n            \"tempFixedLengthArray\",\n            \"miniTempWebGLFloatBuffers\",\n            \"miniTempWebGLIntBuffers\",\n            \"GL\",\n            \"emscripten_webgl_power_preferences\",\n            \"AL\",\n            \"GLUT\",\n            \"EGL\",\n            \"GLEW\",\n            \"IDBStore\",\n            \"SDL\",\n            \"SDL_gfx\",\n            \"GLFW\",\n            \"allocateUTF8\",\n            \"allocateUTF8OnStack\",\n            \"terminateWorker\",\n            \"killThread\",\n            \"cleanupThread\",\n            \"registerTLSInit\",\n            \"cancelThread\",\n            \"spawnThread\",\n            \"exitOnMainThread\",\n            \"proxyToMainThread\",\n            \"emscripten_receive_on_main_thread_js_callArgs\",\n            \"invokeEntryPoint\",\n            \"checkMailbox\",\n            \"InternalError\",\n            \"BindingError\",\n            \"UnboundTypeError\",\n            \"PureVirtualError\",\n            \"init_embind\",\n            \"throwInternalError\",\n            \"throwBindingError\",\n            \"throwUnboundTypeError\",\n            \"ensureOverloadTable\",\n            \"exposePublicSymbol\",\n            \"replacePublicSymbol\",\n            \"extendError\",\n            \"createNamedFunction\",\n            \"embindRepr\",\n            \"registeredInstances\",\n            \"getBasestPointer\",\n            \"getInheritedInstance\",\n            \"getInheritedInstanceCount\",\n            \"getLiveInheritedInstances\",\n            \"registeredTypes\",\n            \"awaitingDependencies\",\n            \"typeDependencies\",\n            \"registeredPointers\",\n            \"registerType\",\n            \"whenDependentTypesAreResolved\",\n            \"embind_charCodes\",\n            \"embind_init_charCodes\",\n            \"readLatin1String\",\n            \"getTypeName\",\n            \"heap32VectorToArray\",\n            \"requireRegisteredType\",\n            \"getShiftFromSize\",\n            \"integerReadValueFromPointer\",\n            \"enumReadValueFromPointer\",\n            \"floatReadValueFromPointer\",\n            \"simpleReadValueFromPointer\",\n            \"runDestructors\",\n            \"newFunc\",\n            \"craftInvokerFunction\",\n            \"embind__requireFunction\",\n            \"tupleRegistrations\",\n            \"structRegistrations\",\n            \"genericPointerToWireType\",\n            \"constNoSmartPtrRawPointerToWireType\",\n            \"nonConstNoSmartPtrRawPointerToWireType\",\n            \"init_RegisteredPointer\",\n            \"RegisteredPointer\",\n            \"RegisteredPointer_getPointee\",\n            \"RegisteredPointer_destructor\",\n            \"RegisteredPointer_deleteObject\",\n            \"RegisteredPointer_fromWireType\",\n            \"runDestructor\",\n            \"releaseClassHandle\",\n            \"finalizationRegistry\",\n            \"detachFinalizer_deps\",\n            \"detachFinalizer\",\n            \"attachFinalizer\",\n            \"makeClassHandle\",\n            \"init_ClassHandle\",\n            \"ClassHandle\",\n            \"ClassHandle_isAliasOf\",\n            \"throwInstanceAlreadyDeleted\",\n            \"ClassHandle_clone\",\n            \"ClassHandle_delete\",\n            \"deletionQueue\",\n            \"ClassHandle_isDeleted\",\n            \"ClassHandle_deleteLater\",\n            \"flushPendingDeletes\",\n            \"delayFunction\",\n            \"setDelayFunction\",\n            \"RegisteredClass\",\n            \"shallowCopyInternalPointer\",\n            \"downcastPointer\",\n            \"upcastPointer\",\n            \"char_0\",\n            \"char_9\",\n            \"makeLegalFunctionName\",\n            \"emval_handles\",\n            \"emval_symbols\",\n            \"init_emval\",\n            \"count_emval_handles\",\n            \"Emval\",\n            \"emval_newers\",\n            \"emval_lookupTypes\",\n            \"emval_methodCallers\",\n            \"emval_registeredMethods\"\n        ];\n        unexportedSymbols.forEach(unexportedRuntimeSymbol);\n        var calledRun;\n        dependenciesFulfilled = function runCaller() {\n            if (!calledRun) run();\n            if (!calledRun) dependenciesFulfilled = runCaller;\n        };\n        function stackCheckInit() {\n            assert(!ENVIRONMENT_IS_PTHREAD);\n            _emscripten_stack_init();\n            writeStackCookie();\n        }\n        function run() {\n            if (runDependencies > 0) return;\n            if (!ENVIRONMENT_IS_PTHREAD) stackCheckInit();\n            if (ENVIRONMENT_IS_PTHREAD) {\n                readyPromiseResolve(Module);\n                initRuntime();\n                startWorker(Module);\n                return;\n            }\n            preRun();\n            if (runDependencies > 0) return;\n            function doRun() {\n                if (calledRun) return;\n                calledRun = true;\n                Module[\"calledRun\"] = true;\n                if (ABORT) return;\n                initRuntime();\n                readyPromiseResolve(Module);\n                if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n                assert(!Module[\"_main\"], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n                postRun();\n            }\n            if (Module[\"setStatus\"]) {\n                Module[\"setStatus\"](\"Running...\");\n                setTimeout(function() {\n                    setTimeout(function() {\n                        Module[\"setStatus\"](\"\");\n                    }, 1);\n                    doRun();\n                }, 1);\n            } else doRun();\n            checkStackCookie();\n        }\n        function checkUnflushedContent() {\n            var oldOut = out;\n            var oldErr = err;\n            var has = false;\n            out = err = (x)=>{\n                has = true;\n            };\n            try {\n                _fflush(0);\n                [\n                    \"stdout\",\n                    \"stderr\"\n                ].forEach(function(name) {\n                    var info = FS.analyzePath(\"/dev/\" + name);\n                    if (!info) return;\n                    var stream = info.object;\n                    var rdev = stream.rdev;\n                    var tty = TTY.ttys[rdev];\n                    if (tty && tty.output && tty.output.length) has = true;\n                });\n            } catch (e) {}\n            out = oldOut;\n            err = oldErr;\n            if (has) warnOnce(\"stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.\");\n        }\n        if (Module[\"preInit\"]) {\n            if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [\n                Module[\"preInit\"]\n            ];\n            while(Module[\"preInit\"].length > 0)Module[\"preInit\"].pop()();\n        }\n        run();\n        return CASModule.ready;\n    };\n})();\nvar $1624ce41e04aea51$export$2e2bcd8739ae039 = $1624ce41e04aea51$var$CASModule;\n\n});\nparcelRequire.register(\"ifEks\", function(module, exports) {\n// shim for using process in browser\nvar $d498e9313a10ad19$var$process = module.exports = {};\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar $d498e9313a10ad19$var$cachedSetTimeout;\nvar $d498e9313a10ad19$var$cachedClearTimeout;\nfunction $d498e9313a10ad19$var$defaultSetTimout() {\n    throw new Error(\"setTimeout has not been defined\");\n}\nfunction $d498e9313a10ad19$var$defaultClearTimeout() {\n    throw new Error(\"clearTimeout has not been defined\");\n}\n(function() {\n    try {\n        if (typeof setTimeout === \"function\") $d498e9313a10ad19$var$cachedSetTimeout = setTimeout;\n        else $d498e9313a10ad19$var$cachedSetTimeout = $d498e9313a10ad19$var$defaultSetTimout;\n    } catch (e) {\n        $d498e9313a10ad19$var$cachedSetTimeout = $d498e9313a10ad19$var$defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === \"function\") $d498e9313a10ad19$var$cachedClearTimeout = clearTimeout;\n        else $d498e9313a10ad19$var$cachedClearTimeout = $d498e9313a10ad19$var$defaultClearTimeout;\n    } catch (e) {\n        $d498e9313a10ad19$var$cachedClearTimeout = $d498e9313a10ad19$var$defaultClearTimeout;\n    }\n})();\nfunction $d498e9313a10ad19$var$runTimeout(fun) {\n    if ($d498e9313a10ad19$var$cachedSetTimeout === setTimeout) //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n    // if setTimeout wasn't available but was latter defined\n    if (($d498e9313a10ad19$var$cachedSetTimeout === $d498e9313a10ad19$var$defaultSetTimout || !$d498e9313a10ad19$var$cachedSetTimeout) && setTimeout) {\n        $d498e9313a10ad19$var$cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $d498e9313a10ad19$var$cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return $d498e9313a10ad19$var$cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return $d498e9313a10ad19$var$cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction $d498e9313a10ad19$var$runClearTimeout(marker) {\n    if ($d498e9313a10ad19$var$cachedClearTimeout === clearTimeout) //normal enviroments in sane situations\n    return clearTimeout(marker);\n    // if clearTimeout wasn't available but was latter defined\n    if (($d498e9313a10ad19$var$cachedClearTimeout === $d498e9313a10ad19$var$defaultClearTimeout || !$d498e9313a10ad19$var$cachedClearTimeout) && clearTimeout) {\n        $d498e9313a10ad19$var$cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $d498e9313a10ad19$var$cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return $d498e9313a10ad19$var$cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return $d498e9313a10ad19$var$cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar $d498e9313a10ad19$var$queue = [];\nvar $d498e9313a10ad19$var$draining = false;\nvar $d498e9313a10ad19$var$currentQueue;\nvar $d498e9313a10ad19$var$queueIndex = -1;\nfunction $d498e9313a10ad19$var$cleanUpNextTick() {\n    if (!$d498e9313a10ad19$var$draining || !$d498e9313a10ad19$var$currentQueue) return;\n    $d498e9313a10ad19$var$draining = false;\n    if ($d498e9313a10ad19$var$currentQueue.length) $d498e9313a10ad19$var$queue = $d498e9313a10ad19$var$currentQueue.concat($d498e9313a10ad19$var$queue);\n    else $d498e9313a10ad19$var$queueIndex = -1;\n    if ($d498e9313a10ad19$var$queue.length) $d498e9313a10ad19$var$drainQueue();\n}\nfunction $d498e9313a10ad19$var$drainQueue() {\n    if ($d498e9313a10ad19$var$draining) return;\n    var timeout = $d498e9313a10ad19$var$runTimeout($d498e9313a10ad19$var$cleanUpNextTick);\n    $d498e9313a10ad19$var$draining = true;\n    var len = $d498e9313a10ad19$var$queue.length;\n    while(len){\n        $d498e9313a10ad19$var$currentQueue = $d498e9313a10ad19$var$queue;\n        $d498e9313a10ad19$var$queue = [];\n        while(++$d498e9313a10ad19$var$queueIndex < len)if ($d498e9313a10ad19$var$currentQueue) $d498e9313a10ad19$var$currentQueue[$d498e9313a10ad19$var$queueIndex].run();\n        $d498e9313a10ad19$var$queueIndex = -1;\n        len = $d498e9313a10ad19$var$queue.length;\n    }\n    $d498e9313a10ad19$var$currentQueue = null;\n    $d498e9313a10ad19$var$draining = false;\n    $d498e9313a10ad19$var$runClearTimeout(timeout);\n}\n$d498e9313a10ad19$var$process.nextTick = function(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];\n    $d498e9313a10ad19$var$queue.push(new $d498e9313a10ad19$var$Item(fun, args));\n    if ($d498e9313a10ad19$var$queue.length === 1 && !$d498e9313a10ad19$var$draining) $d498e9313a10ad19$var$runTimeout($d498e9313a10ad19$var$drainQueue);\n};\n// v8 likes predictible objects\nfunction $d498e9313a10ad19$var$Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\n$d498e9313a10ad19$var$Item.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\n$d498e9313a10ad19$var$process.title = \"browser\";\n$d498e9313a10ad19$var$process.browser = true;\n$d498e9313a10ad19$var$process.env = {};\n$d498e9313a10ad19$var$process.argv = [];\n$d498e9313a10ad19$var$process.version = \"\"; // empty string to avoid regexp issues\n$d498e9313a10ad19$var$process.versions = {};\nfunction $d498e9313a10ad19$var$noop() {}\n$d498e9313a10ad19$var$process.on = $d498e9313a10ad19$var$noop;\n$d498e9313a10ad19$var$process.addListener = $d498e9313a10ad19$var$noop;\n$d498e9313a10ad19$var$process.once = $d498e9313a10ad19$var$noop;\n$d498e9313a10ad19$var$process.off = $d498e9313a10ad19$var$noop;\n$d498e9313a10ad19$var$process.removeListener = $d498e9313a10ad19$var$noop;\n$d498e9313a10ad19$var$process.removeAllListeners = $d498e9313a10ad19$var$noop;\n$d498e9313a10ad19$var$process.emit = $d498e9313a10ad19$var$noop;\n$d498e9313a10ad19$var$process.prependListener = $d498e9313a10ad19$var$noop;\n$d498e9313a10ad19$var$process.prependOnceListener = $d498e9313a10ad19$var$noop;\n$d498e9313a10ad19$var$process.listeners = function(name) {\n    return [];\n};\n$d498e9313a10ad19$var$process.binding = function(name) {\n    throw new Error(\"process.binding is not supported\");\n};\n$d498e9313a10ad19$var$process.cwd = function() {\n    return \"/\";\n};\n$d498e9313a10ad19$var$process.chdir = function(dir) {\n    throw new Error(\"process.chdir is not supported\");\n};\n$d498e9313a10ad19$var$process.umask = function() {\n    return 0;\n};\n\n});\n\nparcelRequire.register(\"68lLB\", function(module, exports) {\n\nmodule.exports = new URL((parcelRequire(\"7q87c\")).resolve(\"32MbT\"), import.meta.url).toString();\n\n});\nparcelRequire.register(\"7q87c\", function(module, exports) {\n\n$parcel$export(module.exports, \"resolve\", () => $5671419489ba846d$export$f7ad0328861e2f03, (v) => $5671419489ba846d$export$f7ad0328861e2f03 = v);\nvar $5671419489ba846d$export$6503ec6e8aabbaf;\nvar $5671419489ba846d$export$f7ad0328861e2f03;\n\"use strict\";\nvar $5671419489ba846d$var$mapping = {};\nfunction $5671419489ba846d$var$register(pairs) {\n    var keys = Object.keys(pairs);\n    for(var i = 0; i < keys.length; i++)$5671419489ba846d$var$mapping[keys[i]] = pairs[keys[i]];\n}\nfunction $5671419489ba846d$var$resolve(id) {\n    var resolved = $5671419489ba846d$var$mapping[id];\n    if (resolved == null) throw new Error(\"Could not resolve bundle with id \" + id);\n    return resolved;\n}\n$5671419489ba846d$export$6503ec6e8aabbaf = $5671419489ba846d$var$register;\n$5671419489ba846d$export$f7ad0328861e2f03 = $5671419489ba846d$var$resolve;\n\n});\n\n\nparcelRequire.register(\"elYs7\", function(module, exports) {\n\nvar $1x9v7 = parcelRequire(\"1x9v7\");\n\nlet $a731eb7672816d7e$var$url = new URL((parcelRequire(\"7q87c\")).resolve(\"ewdRd\"), import.meta.url);\nmodule.exports = $1x9v7($a731eb7672816d7e$var$url.toString(), $a731eb7672816d7e$var$url.origin, true);\n\n});\nparcelRequire.register(\"1x9v7\", function(module, exports) {\n\"use strict\";\nmodule.exports = function(workerUrl, origin, isESM) {\n    if (origin === self.location.origin) // If the worker bundle's url is on the same origin as the document,\n    // use the worker bundle's own url.\n    return workerUrl;\n    else {\n        // Otherwise, create a blob URL which loads the worker bundle with `importScripts`.\n        var source = isESM ? \"import \" + JSON.stringify(workerUrl) + \";\" : \"importScripts(\" + JSON.stringify(workerUrl) + \");\";\n        return URL.createObjectURL(new Blob([\n            source\n        ], {\n            type: \"application/javascript\"\n        }));\n    }\n};\n\n});\n\n\n\n\nparcelRequire(\"9cUbE\");\n\n//# sourceMappingURL=cas.662c88d0.js.map\n","\nvar CASModule = (() => {\n  var _scriptDir = import.meta.url;\n  \n  return (\nfunction(CASModule = {})  {\n\n// Support for growable heap + pthreads, where the buffer may change, so JS views\n// must be updated.\nfunction GROWABLE_HEAP_I8() {\n  if (wasmMemory.buffer != HEAP8.buffer) {\n    updateMemoryViews();\n  }\n  return HEAP8;\n}\nfunction GROWABLE_HEAP_U8() {\n  if (wasmMemory.buffer != HEAP8.buffer) {\n    updateMemoryViews();\n  }\n  return HEAPU8;\n}\nfunction GROWABLE_HEAP_I16() {\n  if (wasmMemory.buffer != HEAP8.buffer) {\n    updateMemoryViews();\n  }\n  return HEAP16;\n}\nfunction GROWABLE_HEAP_U16() {\n  if (wasmMemory.buffer != HEAP8.buffer) {\n    updateMemoryViews();\n  }\n  return HEAPU16;\n}\nfunction GROWABLE_HEAP_I32() {\n  if (wasmMemory.buffer != HEAP8.buffer) {\n    updateMemoryViews();\n  }\n  return HEAP32;\n}\nfunction GROWABLE_HEAP_U32() {\n  if (wasmMemory.buffer != HEAP8.buffer) {\n    updateMemoryViews();\n  }\n  return HEAPU32;\n}\nfunction GROWABLE_HEAP_F32() {\n  if (wasmMemory.buffer != HEAP8.buffer) {\n    updateMemoryViews();\n  }\n  return HEAPF32;\n}\nfunction GROWABLE_HEAP_F64() {\n  if (wasmMemory.buffer != HEAP8.buffer) {\n    updateMemoryViews();\n  }\n  return HEAPF64;\n}\n\nvar Module = typeof CASModule != \"undefined\" ? CASModule : {};\n\nvar readyPromiseResolve, readyPromiseReject;\n\nModule[\"ready\"] = new Promise(function(resolve, reject) {\n readyPromiseResolve = resolve;\n readyPromiseReject = reject;\n});\n\n[ \"_main\", \"__emscripten_thread_init\", \"__emscripten_thread_exit\", \"__emscripten_thread_crashed\", \"__emscripten_thread_mailbox_await\", \"__emscripten_tls_init\", \"_pthread_self\", \"checkMailbox\", \"establishStackSpace\", \"invokeEntryPoint\", \"PThread\", \"getExceptionMessage\", \"___get_exception_message\", \"_free\", \"___cpp_exception\", \"___cxa_increment_exception_refcount\", \"___cxa_decrement_exception_refcount\", \"___thrown_object_from_unwind_exception\", \"___getTypeName\", \"__embind_initialize_bindings\", \"_fflush\", \"__emscripten_check_mailbox\", \"onRuntimeInitialized\" ].forEach(prop => {\n if (!Object.getOwnPropertyDescriptor(Module[\"ready\"], prop)) {\n  Object.defineProperty(Module[\"ready\"], prop, {\n   get: () => abort(\"You are getting \" + prop + \" on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\"),\n   set: () => abort(\"You are setting \" + prop + \" on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\")\n  });\n }\n});\n\nvar moduleOverrides = Object.assign({}, Module);\n\nvar arguments_ = [];\n\nvar thisProgram = \"./this.program\";\n\nvar quit_ = (status, toThrow) => {\n throw toThrow;\n};\n\nvar ENVIRONMENT_IS_WEB = typeof window == \"object\";\n\nvar ENVIRONMENT_IS_WORKER = typeof importScripts == \"function\";\n\nvar ENVIRONMENT_IS_NODE = typeof process == \"object\" && typeof process.versions == \"object\" && typeof process.versions.node == \"string\";\n\nvar ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\nif (Module[\"ENVIRONMENT\"]) {\n throw new Error(\"Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)\");\n}\n\nvar ENVIRONMENT_IS_PTHREAD = Module[\"ENVIRONMENT_IS_PTHREAD\"] || false;\n\nvar scriptDirectory = \"\";\n\nfunction locateFile(path) {\n if (Module[\"locateFile\"]) {\n  return Module[\"locateFile\"](path, scriptDirectory);\n }\n return scriptDirectory + path;\n}\n\nvar read_, readAsync, readBinary, setWindowTitle;\n\nif (ENVIRONMENT_IS_SHELL) {\n if (typeof process == \"object\" && typeof require === \"function\" || typeof window == \"object\" || typeof importScripts == \"function\") throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\n if (typeof read != \"undefined\") {\n  read_ = function shell_read(f) {\n   return read(f);\n  };\n }\n readBinary = function readBinary(f) {\n  let data;\n  if (typeof readbuffer == \"function\") {\n   return new Uint8Array(readbuffer(f));\n  }\n  data = read(f, \"binary\");\n  assert(typeof data == \"object\");\n  return data;\n };\n readAsync = function readAsync(f, onload, onerror) {\n  setTimeout(() => onload(readBinary(f)), 0);\n };\n if (typeof clearTimeout == \"undefined\") {\n  globalThis.clearTimeout = id => {};\n }\n if (typeof scriptArgs != \"undefined\") {\n  arguments_ = scriptArgs;\n } else if (typeof arguments != \"undefined\") {\n  arguments_ = arguments;\n }\n if (typeof quit == \"function\") {\n  quit_ = (status, toThrow) => {\n   setTimeout(() => {\n    if (!(toThrow instanceof ExitStatus)) {\n     let toLog = toThrow;\n     if (toThrow && typeof toThrow == \"object\" && toThrow.stack) {\n      toLog = [ toThrow, toThrow.stack ];\n     }\n     err(\"exiting due to exception: \" + toLog);\n    }\n    quit(status);\n   });\n   throw toThrow;\n  };\n }\n if (typeof print != \"undefined\") {\n  if (typeof console == \"undefined\") console = {};\n  console.log = print;\n  console.warn = console.error = typeof printErr != \"undefined\" ? printErr : print;\n }\n} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n if (ENVIRONMENT_IS_WORKER) {\n  scriptDirectory = self.location.href;\n } else if (typeof document != \"undefined\" && document.currentScript) {\n  scriptDirectory = document.currentScript.src;\n }\n if (_scriptDir) {\n  scriptDirectory = _scriptDir;\n }\n if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n  scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n } else {\n  scriptDirectory = \"\";\n }\n if (!(typeof window == \"object\" || typeof importScripts == \"function\")) throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\n {\n  read_ = url => {\n   var xhr = new XMLHttpRequest();\n   xhr.open(\"GET\", url, false);\n   xhr.send(null);\n   return xhr.responseText;\n  };\n  if (ENVIRONMENT_IS_WORKER) {\n   readBinary = url => {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, false);\n    xhr.responseType = \"arraybuffer\";\n    xhr.send(null);\n    return new Uint8Array(xhr.response);\n   };\n  }\n  readAsync = (url, onload, onerror) => {\n   var xhr = new XMLHttpRequest();\n   xhr.open(\"GET\", url, true);\n   xhr.responseType = \"arraybuffer\";\n   xhr.onload = () => {\n    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n     onload(xhr.response);\n     return;\n    }\n    onerror();\n   };\n   xhr.onerror = onerror;\n   xhr.send(null);\n  };\n }\n setWindowTitle = title => document.title = title;\n} else {\n throw new Error(\"environment detection error\");\n}\n\nvar out = Module[\"print\"] || console.log.bind(console);\n\nvar err = Module[\"printErr\"] || console.warn.bind(console);\n\nObject.assign(Module, moduleOverrides);\n\nmoduleOverrides = null;\n\ncheckIncomingModuleAPI();\n\nif (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n\nlegacyModuleProp(\"arguments\", \"arguments_\");\n\nif (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n\nlegacyModuleProp(\"thisProgram\", \"thisProgram\");\n\nif (Module[\"quit\"]) quit_ = Module[\"quit\"];\n\nlegacyModuleProp(\"quit\", \"quit_\");\n\nassert(typeof Module[\"memoryInitializerPrefixURL\"] == \"undefined\", \"Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead\");\n\nassert(typeof Module[\"pthreadMainPrefixURL\"] == \"undefined\", \"Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead\");\n\nassert(typeof Module[\"cdInitializerPrefixURL\"] == \"undefined\", \"Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead\");\n\nassert(typeof Module[\"filePackagePrefixURL\"] == \"undefined\", \"Module.filePackagePrefixURL option was removed, use Module.locateFile instead\");\n\nassert(typeof Module[\"read\"] == \"undefined\", \"Module.read option was removed (modify read_ in JS)\");\n\nassert(typeof Module[\"readAsync\"] == \"undefined\", \"Module.readAsync option was removed (modify readAsync in JS)\");\n\nassert(typeof Module[\"readBinary\"] == \"undefined\", \"Module.readBinary option was removed (modify readBinary in JS)\");\n\nassert(typeof Module[\"setWindowTitle\"] == \"undefined\", \"Module.setWindowTitle option was removed (modify setWindowTitle in JS)\");\n\nassert(typeof Module[\"TOTAL_MEMORY\"] == \"undefined\", \"Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY\");\n\nlegacyModuleProp(\"read\", \"read_\");\n\nlegacyModuleProp(\"readAsync\", \"readAsync\");\n\nlegacyModuleProp(\"readBinary\", \"readBinary\");\n\nlegacyModuleProp(\"setWindowTitle\", \"setWindowTitle\");\n\nvar IDBFS = \"IDBFS is no longer included by default; build with -lidbfs.js\";\n\nvar PROXYFS = \"PROXYFS is no longer included by default; build with -lproxyfs.js\";\n\nvar WORKERFS = \"WORKERFS is no longer included by default; build with -lworkerfs.js\";\n\nvar NODEFS = \"NODEFS is no longer included by default; build with -lnodefs.js\";\n\nassert(ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER || ENVIRONMENT_IS_NODE, \"Pthreads do not work in this environment yet (need Web Workers, or an alternative to them)\");\n\nassert(!ENVIRONMENT_IS_NODE, \"node environment detected but not enabled at build time.  Add 'node' to `-sENVIRONMENT` to enable.\");\n\nassert(!ENVIRONMENT_IS_SHELL, \"shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.\");\n\nvar wasmBinary;\n\nif (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n\nlegacyModuleProp(\"wasmBinary\", \"wasmBinary\");\n\nvar noExitRuntime = Module[\"noExitRuntime\"] || true;\n\nlegacyModuleProp(\"noExitRuntime\", \"noExitRuntime\");\n\nif (typeof WebAssembly != \"object\") {\n abort(\"no native wasm support detected\");\n}\n\nvar wasmMemory;\n\nvar wasmModule;\n\nvar ABORT = false;\n\nvar EXITSTATUS;\n\nfunction assert(condition, text) {\n if (!condition) {\n  abort(\"Assertion failed\" + (text ? \": \" + text : \"\"));\n }\n}\n\nvar HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n\nfunction updateMemoryViews() {\n var b = wasmMemory.buffer;\n Module[\"HEAP8\"] = HEAP8 = new Int8Array(b);\n Module[\"HEAP16\"] = HEAP16 = new Int16Array(b);\n Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\n Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\n Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\n Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\n Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\n Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\n}\n\nassert(!Module[\"STACK_SIZE\"], \"STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time\");\n\nassert(typeof Int32Array != \"undefined\" && typeof Float64Array !== \"undefined\" && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined, \"JS engine does not provide full typed array support\");\n\nvar INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 16777216;\n\nlegacyModuleProp(\"INITIAL_MEMORY\", \"INITIAL_MEMORY\");\n\nassert(INITIAL_MEMORY >= 65536, \"INITIAL_MEMORY should be larger than STACK_SIZE, was \" + INITIAL_MEMORY + \"! (STACK_SIZE=\" + 65536 + \")\");\n\nif (ENVIRONMENT_IS_PTHREAD) {\n wasmMemory = Module[\"wasmMemory\"];\n} else {\n if (Module[\"wasmMemory\"]) {\n  wasmMemory = Module[\"wasmMemory\"];\n } else {\n  wasmMemory = new WebAssembly.Memory({\n   \"initial\": INITIAL_MEMORY / 65536,\n   \"maximum\": 2147483648 / 65536,\n   \"shared\": true\n  });\n  if (!(wasmMemory.buffer instanceof SharedArrayBuffer)) {\n   err(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\");\n   if (ENVIRONMENT_IS_NODE) {\n    err(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)\");\n   }\n   throw Error(\"bad memory\");\n  }\n }\n}\n\nupdateMemoryViews();\n\nINITIAL_MEMORY = wasmMemory.buffer.byteLength;\n\nassert(INITIAL_MEMORY % 65536 === 0);\n\nvar wasmTable;\n\nfunction writeStackCookie() {\n var max = _emscripten_stack_get_end();\n assert((max & 3) == 0);\n if (max == 0) {\n  max += 4;\n }\n GROWABLE_HEAP_U32()[max >> 2] = 34821223;\n GROWABLE_HEAP_U32()[max + 4 >> 2] = 2310721022;\n GROWABLE_HEAP_U32()[0] = 1668509029;\n}\n\nfunction checkStackCookie() {\n if (ABORT) return;\n var max = _emscripten_stack_get_end();\n if (max == 0) {\n  max += 4;\n }\n var cookie1 = GROWABLE_HEAP_U32()[max >> 2];\n var cookie2 = GROWABLE_HEAP_U32()[max + 4 >> 2];\n if (cookie1 != 34821223 || cookie2 != 2310721022) {\n  abort(\"Stack overflow! Stack cookie has been overwritten at \" + ptrToString(max) + \", expected hex dwords 0x89BACDFE and 0x2135467, but received \" + ptrToString(cookie2) + \" \" + ptrToString(cookie1));\n }\n if (GROWABLE_HEAP_U32()[0] !== 1668509029) {\n  abort(\"Runtime error: The application has corrupted its heap memory area (address zero)!\");\n }\n}\n\n(function() {\n var h16 = new Int16Array(1);\n var h8 = new Int8Array(h16.buffer);\n h16[0] = 25459;\n if (h8[0] !== 115 || h8[1] !== 99) throw \"Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)\";\n})();\n\nvar __ATPRERUN__ = [];\n\nvar __ATINIT__ = [];\n\nvar __ATEXIT__ = [];\n\nvar __ATPOSTRUN__ = [];\n\nvar runtimeInitialized = false;\n\nvar runtimeKeepaliveCounter = 0;\n\nfunction keepRuntimeAlive() {\n return noExitRuntime || runtimeKeepaliveCounter > 0;\n}\n\nfunction preRun() {\n assert(!ENVIRONMENT_IS_PTHREAD);\n if (Module[\"preRun\"]) {\n  if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [ Module[\"preRun\"] ];\n  while (Module[\"preRun\"].length) {\n   addOnPreRun(Module[\"preRun\"].shift());\n  }\n }\n callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction initRuntime() {\n assert(!runtimeInitialized);\n runtimeInitialized = true;\n if (ENVIRONMENT_IS_PTHREAD) return;\n checkStackCookie();\n if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init();\n FS.ignorePermissions = false;\n TTY.init();\n callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction postRun() {\n checkStackCookie();\n if (ENVIRONMENT_IS_PTHREAD) return;\n if (Module[\"postRun\"]) {\n  if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [ Module[\"postRun\"] ];\n  while (Module[\"postRun\"].length) {\n   addOnPostRun(Module[\"postRun\"].shift());\n  }\n }\n callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n __ATINIT__.unshift(cb);\n}\n\nfunction addOnExit(cb) {}\n\nfunction addOnPostRun(cb) {\n __ATPOSTRUN__.unshift(cb);\n}\n\nassert(Math.imul, \"This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n\nassert(Math.fround, \"This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n\nassert(Math.clz32, \"This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n\nassert(Math.trunc, \"This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n\nvar runDependencies = 0;\n\nvar runDependencyWatcher = null;\n\nvar dependenciesFulfilled = null;\n\nvar runDependencyTracking = {};\n\nfunction getUniqueRunDependency(id) {\n var orig = id;\n while (1) {\n  if (!runDependencyTracking[id]) return id;\n  id = orig + Math.random();\n }\n}\n\nfunction addRunDependency(id) {\n runDependencies++;\n if (Module[\"monitorRunDependencies\"]) {\n  Module[\"monitorRunDependencies\"](runDependencies);\n }\n if (id) {\n  assert(!runDependencyTracking[id]);\n  runDependencyTracking[id] = 1;\n  if (runDependencyWatcher === null && typeof setInterval != \"undefined\") {\n   runDependencyWatcher = setInterval(function() {\n    if (ABORT) {\n     clearInterval(runDependencyWatcher);\n     runDependencyWatcher = null;\n     return;\n    }\n    var shown = false;\n    for (var dep in runDependencyTracking) {\n     if (!shown) {\n      shown = true;\n      err(\"still waiting on run dependencies:\");\n     }\n     err(\"dependency: \" + dep);\n    }\n    if (shown) {\n     err(\"(end of list)\");\n    }\n   }, 1e4);\n  }\n } else {\n  err(\"warning: run dependency added without ID\");\n }\n}\n\nfunction removeRunDependency(id) {\n runDependencies--;\n if (Module[\"monitorRunDependencies\"]) {\n  Module[\"monitorRunDependencies\"](runDependencies);\n }\n if (id) {\n  assert(runDependencyTracking[id]);\n  delete runDependencyTracking[id];\n } else {\n  err(\"warning: run dependency removed without ID\");\n }\n if (runDependencies == 0) {\n  if (runDependencyWatcher !== null) {\n   clearInterval(runDependencyWatcher);\n   runDependencyWatcher = null;\n  }\n  if (dependenciesFulfilled) {\n   var callback = dependenciesFulfilled;\n   dependenciesFulfilled = null;\n   callback();\n  }\n }\n}\n\nfunction abort(what) {\n if (Module[\"onAbort\"]) {\n  Module[\"onAbort\"](what);\n }\n what = \"Aborted(\" + what + \")\";\n err(what);\n ABORT = true;\n EXITSTATUS = 1;\n if (runtimeInitialized) {\n  ___trap();\n }\n var e = new WebAssembly.RuntimeError(what);\n readyPromiseReject(e);\n throw e;\n}\n\nvar dataURIPrefix = \"data:application/octet-stream;base64,\";\n\nfunction isDataURI(filename) {\n return filename.startsWith(dataURIPrefix);\n}\n\nfunction isFileURI(filename) {\n return filename.startsWith(\"file://\");\n}\n\nfunction createExportWrapper(name, fixedasm) {\n return function() {\n  var displayName = name;\n  var asm = fixedasm;\n  if (!fixedasm) {\n   asm = Module[\"asm\"];\n  }\n  assert(runtimeInitialized, \"native function `\" + displayName + \"` called before runtime initialization\");\n  if (!asm[name]) {\n   assert(asm[name], \"exported native function `\" + displayName + \"` not found\");\n  }\n  return asm[name].apply(null, arguments);\n };\n}\n\nvar wasmBinaryFile;\n\nif (Module[\"locateFile\"]) {\n wasmBinaryFile = \"cas.wasm\";\n if (!isDataURI(wasmBinaryFile)) {\n  wasmBinaryFile = locateFile(wasmBinaryFile);\n }\n} else {\n wasmBinaryFile = new URL(\"cas.wasm\", import.meta.url).href;\n}\n\nfunction getBinary(file) {\n try {\n  if (file == wasmBinaryFile && wasmBinary) {\n   return new Uint8Array(wasmBinary);\n  }\n  if (readBinary) {\n   return readBinary(file);\n  }\n  throw \"both async and sync fetching of the wasm failed\";\n } catch (err) {\n  abort(err);\n }\n}\n\nfunction getBinaryPromise(binaryFile) {\n if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n  if (typeof fetch == \"function\") {\n   return fetch(binaryFile, {\n    credentials: \"same-origin\"\n   }).then(function(response) {\n    if (!response[\"ok\"]) {\n     throw \"failed to load wasm binary file at '\" + binaryFile + \"'\";\n    }\n    return response[\"arrayBuffer\"]();\n   }).catch(function() {\n    return getBinary(binaryFile);\n   });\n  }\n }\n return Promise.resolve().then(function() {\n  return getBinary(binaryFile);\n });\n}\n\nfunction instantiateArrayBuffer(binaryFile, imports, receiver) {\n return getBinaryPromise(binaryFile).then(function(binary) {\n  return WebAssembly.instantiate(binary, imports);\n }).then(function(instance) {\n  return instance;\n }).then(receiver, function(reason) {\n  err(\"failed to asynchronously prepare wasm: \" + reason);\n  if (isFileURI(wasmBinaryFile)) {\n   err(\"warning: Loading from a file URI (\" + wasmBinaryFile + \") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing\");\n  }\n  abort(reason);\n });\n}\n\nfunction instantiateAsync(binary, binaryFile, imports, callback) {\n if (!binary && typeof WebAssembly.instantiateStreaming == \"function\" && !isDataURI(binaryFile) && typeof fetch == \"function\") {\n  return fetch(binaryFile, {\n   credentials: \"same-origin\"\n  }).then(function(response) {\n   var result = WebAssembly.instantiateStreaming(response, imports);\n   return result.then(callback, function(reason) {\n    err(\"wasm streaming compile failed: \" + reason);\n    err(\"falling back to ArrayBuffer instantiation\");\n    return instantiateArrayBuffer(binaryFile, imports, callback);\n   });\n  });\n } else {\n  return instantiateArrayBuffer(binaryFile, imports, callback);\n }\n}\n\nfunction createWasm() {\n var info = {\n  \"env\": wasmImports,\n  \"wasi_snapshot_preview1\": wasmImports\n };\n function receiveInstance(instance, module) {\n  var exports = instance.exports;\n  Module[\"asm\"] = exports;\n  registerTLSInit(Module[\"asm\"][\"_emscripten_tls_init\"]);\n  wasmTable = Module[\"asm\"][\"__indirect_function_table\"];\n  assert(wasmTable, \"table not found in wasm exports\");\n  addOnInit(Module[\"asm\"][\"__wasm_call_ctors\"]);\n  wasmModule = module;\n  PThread.loadWasmModuleToAllWorkers(() => removeRunDependency(\"wasm-instantiate\"));\n  return exports;\n }\n addRunDependency(\"wasm-instantiate\");\n var trueModule = Module;\n function receiveInstantiationResult(result) {\n  assert(Module === trueModule, \"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?\");\n  trueModule = null;\n  receiveInstance(result[\"instance\"], result[\"module\"]);\n }\n if (Module[\"instantiateWasm\"]) {\n  try {\n   return Module[\"instantiateWasm\"](info, receiveInstance);\n  } catch (e) {\n   err(\"Module.instantiateWasm callback failed with error: \" + e);\n   readyPromiseReject(e);\n  }\n }\n instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\n return {};\n}\n\nvar tempDouble;\n\nvar tempI64;\n\nfunction legacyModuleProp(prop, newName) {\n if (!Object.getOwnPropertyDescriptor(Module, prop)) {\n  Object.defineProperty(Module, prop, {\n   configurable: true,\n   get: function() {\n    abort(\"Module.\" + prop + \" has been replaced with plain \" + newName + \" (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n   }\n  });\n }\n}\n\nfunction ignoredModuleProp(prop) {\n if (Object.getOwnPropertyDescriptor(Module, prop)) {\n  abort(\"`Module.\" + prop + \"` was supplied but `\" + prop + \"` not included in INCOMING_MODULE_JS_API\");\n }\n}\n\nfunction isExportedByForceFilesystem(name) {\n return name === \"FS_createPath\" || name === \"FS_createDataFile\" || name === \"FS_createPreloadedFile\" || name === \"FS_unlink\" || name === \"addRunDependency\" || name === \"FS_createLazyFile\" || name === \"FS_createDevice\" || name === \"removeRunDependency\";\n}\n\nfunction missingGlobal(sym, msg) {\n if (typeof globalThis !== \"undefined\") {\n  Object.defineProperty(globalThis, sym, {\n   configurable: true,\n   get: function() {\n    warnOnce(\"`\" + sym + \"` is not longer defined by emscripten. \" + msg);\n    return undefined;\n   }\n  });\n }\n}\n\nmissingGlobal(\"buffer\", \"Please use HEAP8.buffer or wasmMemory.buffer\");\n\nfunction missingLibrarySymbol(sym) {\n if (typeof globalThis !== \"undefined\" && !Object.getOwnPropertyDescriptor(globalThis, sym)) {\n  Object.defineProperty(globalThis, sym, {\n   configurable: true,\n   get: function() {\n    var msg = \"`\" + sym + \"` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line\";\n    var librarySymbol = sym;\n    if (!librarySymbol.startsWith(\"_\")) {\n     librarySymbol = \"$\" + sym;\n    }\n    msg += \" (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE=\" + librarySymbol + \")\";\n    if (isExportedByForceFilesystem(sym)) {\n     msg += \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\n    }\n    warnOnce(msg);\n    return undefined;\n   }\n  });\n }\n unexportedRuntimeSymbol(sym);\n}\n\nfunction unexportedRuntimeSymbol(sym) {\n if (!Object.getOwnPropertyDescriptor(Module, sym)) {\n  Object.defineProperty(Module, sym, {\n   configurable: true,\n   get: function() {\n    var msg = \"'\" + sym + \"' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\";\n    if (isExportedByForceFilesystem(sym)) {\n     msg += \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\n    }\n    abort(msg);\n   }\n  });\n }\n}\n\nfunction dbg(text) {\n console.error.apply(console, arguments);\n}\n\nfunction ExitStatus(status) {\n this.name = \"ExitStatus\";\n this.message = \"Program terminated with exit(\" + status + \")\";\n this.status = status;\n}\n\nfunction terminateWorker(worker) {\n worker.terminate();\n worker.onmessage = e => {\n  var cmd = e[\"data\"][\"cmd\"];\n  err('received \"' + cmd + '\" command from terminated worker: ' + worker.workerID);\n };\n}\n\nfunction killThread(pthread_ptr) {\n assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! killThread() can only ever be called from main application thread!\");\n assert(pthread_ptr, \"Internal Error! Null pthread_ptr in killThread!\");\n var worker = PThread.pthreads[pthread_ptr];\n delete PThread.pthreads[pthread_ptr];\n terminateWorker(worker);\n __emscripten_thread_free_data(pthread_ptr);\n PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker), 1);\n worker.pthread_ptr = 0;\n}\n\nfunction cancelThread(pthread_ptr) {\n assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! cancelThread() can only ever be called from main application thread!\");\n assert(pthread_ptr, \"Internal Error! Null pthread_ptr in cancelThread!\");\n var worker = PThread.pthreads[pthread_ptr];\n worker.postMessage({\n  \"cmd\": \"cancel\"\n });\n}\n\nfunction cleanupThread(pthread_ptr) {\n assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! cleanupThread() can only ever be called from main application thread!\");\n assert(pthread_ptr, \"Internal Error! Null pthread_ptr in cleanupThread!\");\n var worker = PThread.pthreads[pthread_ptr];\n assert(worker);\n PThread.returnWorkerToPool(worker);\n}\n\nfunction zeroMemory(address, size) {\n GROWABLE_HEAP_U8().fill(0, address, address + size);\n return address;\n}\n\nfunction spawnThread(threadParams) {\n assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! spawnThread() can only ever be called from main application thread!\");\n assert(threadParams.pthread_ptr, \"Internal error, no pthread ptr!\");\n var worker = PThread.getNewWorker();\n if (!worker) {\n  return 6;\n }\n assert(!worker.pthread_ptr, \"Internal error!\");\n PThread.runningWorkers.push(worker);\n PThread.pthreads[threadParams.pthread_ptr] = worker;\n worker.pthread_ptr = threadParams.pthread_ptr;\n var msg = {\n  \"cmd\": \"run\",\n  \"start_routine\": threadParams.startRoutine,\n  \"arg\": threadParams.arg,\n  \"pthread_ptr\": threadParams.pthread_ptr\n };\n worker.postMessage(msg, threadParams.transferList);\n return 0;\n}\n\nvar PATH = {\n isAbs: path => path.charAt(0) === \"/\",\n splitPath: filename => {\n  var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n  return splitPathRe.exec(filename).slice(1);\n },\n normalizeArray: (parts, allowAboveRoot) => {\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n   var last = parts[i];\n   if (last === \".\") {\n    parts.splice(i, 1);\n   } else if (last === \"..\") {\n    parts.splice(i, 1);\n    up++;\n   } else if (up) {\n    parts.splice(i, 1);\n    up--;\n   }\n  }\n  if (allowAboveRoot) {\n   for (;up; up--) {\n    parts.unshift(\"..\");\n   }\n  }\n  return parts;\n },\n normalize: path => {\n  var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === \"/\";\n  path = PATH.normalizeArray(path.split(\"/\").filter(p => !!p), !isAbsolute).join(\"/\");\n  if (!path && !isAbsolute) {\n   path = \".\";\n  }\n  if (path && trailingSlash) {\n   path += \"/\";\n  }\n  return (isAbsolute ? \"/\" : \"\") + path;\n },\n dirname: path => {\n  var result = PATH.splitPath(path), root = result[0], dir = result[1];\n  if (!root && !dir) {\n   return \".\";\n  }\n  if (dir) {\n   dir = dir.substr(0, dir.length - 1);\n  }\n  return root + dir;\n },\n basename: path => {\n  if (path === \"/\") return \"/\";\n  path = PATH.normalize(path);\n  path = path.replace(/\\/$/, \"\");\n  var lastSlash = path.lastIndexOf(\"/\");\n  if (lastSlash === -1) return path;\n  return path.substr(lastSlash + 1);\n },\n join: function() {\n  var paths = Array.prototype.slice.call(arguments);\n  return PATH.normalize(paths.join(\"/\"));\n },\n join2: (l, r) => {\n  return PATH.normalize(l + \"/\" + r);\n }\n};\n\nfunction initRandomFill() {\n if (typeof crypto == \"object\" && typeof crypto[\"getRandomValues\"] == \"function\") {\n  return view => (view.set(crypto.getRandomValues(new Uint8Array(view.byteLength))), \n  view);\n } else abort(\"no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };\");\n}\n\nfunction randomFill(view) {\n return (randomFill = initRandomFill())(view);\n}\n\nvar PATH_FS = {\n resolve: function() {\n  var resolvedPath = \"\", resolvedAbsolute = false;\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n   var path = i >= 0 ? arguments[i] : FS.cwd();\n   if (typeof path != \"string\") {\n    throw new TypeError(\"Arguments to path.resolve must be strings\");\n   } else if (!path) {\n    return \"\";\n   }\n   resolvedPath = path + \"/\" + resolvedPath;\n   resolvedAbsolute = PATH.isAbs(path);\n  }\n  resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter(p => !!p), !resolvedAbsolute).join(\"/\");\n  return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\n },\n relative: (from, to) => {\n  from = PATH_FS.resolve(from).substr(1);\n  to = PATH_FS.resolve(to).substr(1);\n  function trim(arr) {\n   var start = 0;\n   for (;start < arr.length; start++) {\n    if (arr[start] !== \"\") break;\n   }\n   var end = arr.length - 1;\n   for (;end >= 0; end--) {\n    if (arr[end] !== \"\") break;\n   }\n   if (start > end) return [];\n   return arr.slice(start, end - start + 1);\n  }\n  var fromParts = trim(from.split(\"/\"));\n  var toParts = trim(to.split(\"/\"));\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n   if (fromParts[i] !== toParts[i]) {\n    samePartsLength = i;\n    break;\n   }\n  }\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n   outputParts.push(\"..\");\n  }\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n  return outputParts.join(\"/\");\n }\n};\n\nfunction lengthBytesUTF8(str) {\n var len = 0;\n for (var i = 0; i < str.length; ++i) {\n  var c = str.charCodeAt(i);\n  if (c <= 127) {\n   len++;\n  } else if (c <= 2047) {\n   len += 2;\n  } else if (c >= 55296 && c <= 57343) {\n   len += 4;\n   ++i;\n  } else {\n   len += 3;\n  }\n }\n return len;\n}\n\nfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n assert(typeof str === \"string\");\n if (!(maxBytesToWrite > 0)) return 0;\n var startIdx = outIdx;\n var endIdx = outIdx + maxBytesToWrite - 1;\n for (var i = 0; i < str.length; ++i) {\n  var u = str.charCodeAt(i);\n  if (u >= 55296 && u <= 57343) {\n   var u1 = str.charCodeAt(++i);\n   u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n  }\n  if (u <= 127) {\n   if (outIdx >= endIdx) break;\n   heap[outIdx++] = u;\n  } else if (u <= 2047) {\n   if (outIdx + 1 >= endIdx) break;\n   heap[outIdx++] = 192 | u >> 6;\n   heap[outIdx++] = 128 | u & 63;\n  } else if (u <= 65535) {\n   if (outIdx + 2 >= endIdx) break;\n   heap[outIdx++] = 224 | u >> 12;\n   heap[outIdx++] = 128 | u >> 6 & 63;\n   heap[outIdx++] = 128 | u & 63;\n  } else {\n   if (outIdx + 3 >= endIdx) break;\n   if (u > 1114111) warnOnce(\"Invalid Unicode code point \" + ptrToString(u) + \" encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).\");\n   heap[outIdx++] = 240 | u >> 18;\n   heap[outIdx++] = 128 | u >> 12 & 63;\n   heap[outIdx++] = 128 | u >> 6 & 63;\n   heap[outIdx++] = 128 | u & 63;\n  }\n }\n heap[outIdx] = 0;\n return outIdx - startIdx;\n}\n\nfunction intArrayFromString(stringy, dontAddNull, length) {\n var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n var u8array = new Array(len);\n var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n if (dontAddNull) u8array.length = numBytesWritten;\n return u8array;\n}\n\nvar TTY = {\n ttys: [],\n init: function() {},\n shutdown: function() {},\n register: function(dev, ops) {\n  TTY.ttys[dev] = {\n   input: [],\n   output: [],\n   ops: ops\n  };\n  FS.registerDevice(dev, TTY.stream_ops);\n },\n stream_ops: {\n  open: function(stream) {\n   var tty = TTY.ttys[stream.node.rdev];\n   if (!tty) {\n    throw new FS.ErrnoError(43);\n   }\n   stream.tty = tty;\n   stream.seekable = false;\n  },\n  close: function(stream) {\n   stream.tty.ops.fsync(stream.tty);\n  },\n  fsync: function(stream) {\n   stream.tty.ops.fsync(stream.tty);\n  },\n  read: function(stream, buffer, offset, length, pos) {\n   if (!stream.tty || !stream.tty.ops.get_char) {\n    throw new FS.ErrnoError(60);\n   }\n   var bytesRead = 0;\n   for (var i = 0; i < length; i++) {\n    var result;\n    try {\n     result = stream.tty.ops.get_char(stream.tty);\n    } catch (e) {\n     throw new FS.ErrnoError(29);\n    }\n    if (result === undefined && bytesRead === 0) {\n     throw new FS.ErrnoError(6);\n    }\n    if (result === null || result === undefined) break;\n    bytesRead++;\n    buffer[offset + i] = result;\n   }\n   if (bytesRead) {\n    stream.node.timestamp = Date.now();\n   }\n   return bytesRead;\n  },\n  write: function(stream, buffer, offset, length, pos) {\n   if (!stream.tty || !stream.tty.ops.put_char) {\n    throw new FS.ErrnoError(60);\n   }\n   try {\n    for (var i = 0; i < length; i++) {\n     stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n    }\n   } catch (e) {\n    throw new FS.ErrnoError(29);\n   }\n   if (length) {\n    stream.node.timestamp = Date.now();\n   }\n   return i;\n  }\n },\n default_tty_ops: {\n  get_char: function(tty) {\n   if (!tty.input.length) {\n    var result = null;\n    if (typeof window != \"undefined\" && typeof window.prompt == \"function\") {\n     result = window.prompt(\"Input: \");\n     if (result !== null) {\n      result += \"\\n\";\n     }\n    } else if (typeof readline == \"function\") {\n     result = readline();\n     if (result !== null) {\n      result += \"\\n\";\n     }\n    }\n    if (!result) {\n     return null;\n    }\n    tty.input = intArrayFromString(result, true);\n   }\n   return tty.input.shift();\n  },\n  put_char: function(tty, val) {\n   if (val === null || val === 10) {\n    out(UTF8ArrayToString(tty.output, 0));\n    tty.output = [];\n   } else {\n    if (val != 0) tty.output.push(val);\n   }\n  },\n  fsync: function(tty) {\n   if (tty.output && tty.output.length > 0) {\n    out(UTF8ArrayToString(tty.output, 0));\n    tty.output = [];\n   }\n  }\n },\n default_tty1_ops: {\n  put_char: function(tty, val) {\n   if (val === null || val === 10) {\n    err(UTF8ArrayToString(tty.output, 0));\n    tty.output = [];\n   } else {\n    if (val != 0) tty.output.push(val);\n   }\n  },\n  fsync: function(tty) {\n   if (tty.output && tty.output.length > 0) {\n    err(UTF8ArrayToString(tty.output, 0));\n    tty.output = [];\n   }\n  }\n }\n};\n\nfunction alignMemory(size, alignment) {\n assert(alignment, \"alignment argument is required\");\n return Math.ceil(size / alignment) * alignment;\n}\n\nfunction mmapAlloc(size) {\n abort(\"internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported\");\n}\n\nvar MEMFS = {\n ops_table: null,\n mount: function(mount) {\n  return MEMFS.createNode(null, \"/\", 16384 | 511, 0);\n },\n createNode: function(parent, name, mode, dev) {\n  if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n   throw new FS.ErrnoError(63);\n  }\n  if (!MEMFS.ops_table) {\n   MEMFS.ops_table = {\n    dir: {\n     node: {\n      getattr: MEMFS.node_ops.getattr,\n      setattr: MEMFS.node_ops.setattr,\n      lookup: MEMFS.node_ops.lookup,\n      mknod: MEMFS.node_ops.mknod,\n      rename: MEMFS.node_ops.rename,\n      unlink: MEMFS.node_ops.unlink,\n      rmdir: MEMFS.node_ops.rmdir,\n      readdir: MEMFS.node_ops.readdir,\n      symlink: MEMFS.node_ops.symlink\n     },\n     stream: {\n      llseek: MEMFS.stream_ops.llseek\n     }\n    },\n    file: {\n     node: {\n      getattr: MEMFS.node_ops.getattr,\n      setattr: MEMFS.node_ops.setattr\n     },\n     stream: {\n      llseek: MEMFS.stream_ops.llseek,\n      read: MEMFS.stream_ops.read,\n      write: MEMFS.stream_ops.write,\n      allocate: MEMFS.stream_ops.allocate,\n      mmap: MEMFS.stream_ops.mmap,\n      msync: MEMFS.stream_ops.msync\n     }\n    },\n    link: {\n     node: {\n      getattr: MEMFS.node_ops.getattr,\n      setattr: MEMFS.node_ops.setattr,\n      readlink: MEMFS.node_ops.readlink\n     },\n     stream: {}\n    },\n    chrdev: {\n     node: {\n      getattr: MEMFS.node_ops.getattr,\n      setattr: MEMFS.node_ops.setattr\n     },\n     stream: FS.chrdev_stream_ops\n    }\n   };\n  }\n  var node = FS.createNode(parent, name, mode, dev);\n  if (FS.isDir(node.mode)) {\n   node.node_ops = MEMFS.ops_table.dir.node;\n   node.stream_ops = MEMFS.ops_table.dir.stream;\n   node.contents = {};\n  } else if (FS.isFile(node.mode)) {\n   node.node_ops = MEMFS.ops_table.file.node;\n   node.stream_ops = MEMFS.ops_table.file.stream;\n   node.usedBytes = 0;\n   node.contents = null;\n  } else if (FS.isLink(node.mode)) {\n   node.node_ops = MEMFS.ops_table.link.node;\n   node.stream_ops = MEMFS.ops_table.link.stream;\n  } else if (FS.isChrdev(node.mode)) {\n   node.node_ops = MEMFS.ops_table.chrdev.node;\n   node.stream_ops = MEMFS.ops_table.chrdev.stream;\n  }\n  node.timestamp = Date.now();\n  if (parent) {\n   parent.contents[name] = node;\n   parent.timestamp = node.timestamp;\n  }\n  return node;\n },\n getFileDataAsTypedArray: function(node) {\n  if (!node.contents) return new Uint8Array(0);\n  if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\n  return new Uint8Array(node.contents);\n },\n expandFileStorage: function(node, newCapacity) {\n  var prevCapacity = node.contents ? node.contents.length : 0;\n  if (prevCapacity >= newCapacity) return;\n  var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n  newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);\n  if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n  var oldContents = node.contents;\n  node.contents = new Uint8Array(newCapacity);\n  if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n },\n resizeFileStorage: function(node, newSize) {\n  if (node.usedBytes == newSize) return;\n  if (newSize == 0) {\n   node.contents = null;\n   node.usedBytes = 0;\n  } else {\n   var oldContents = node.contents;\n   node.contents = new Uint8Array(newSize);\n   if (oldContents) {\n    node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n   }\n   node.usedBytes = newSize;\n  }\n },\n node_ops: {\n  getattr: function(node) {\n   var attr = {};\n   attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n   attr.ino = node.id;\n   attr.mode = node.mode;\n   attr.nlink = 1;\n   attr.uid = 0;\n   attr.gid = 0;\n   attr.rdev = node.rdev;\n   if (FS.isDir(node.mode)) {\n    attr.size = 4096;\n   } else if (FS.isFile(node.mode)) {\n    attr.size = node.usedBytes;\n   } else if (FS.isLink(node.mode)) {\n    attr.size = node.link.length;\n   } else {\n    attr.size = 0;\n   }\n   attr.atime = new Date(node.timestamp);\n   attr.mtime = new Date(node.timestamp);\n   attr.ctime = new Date(node.timestamp);\n   attr.blksize = 4096;\n   attr.blocks = Math.ceil(attr.size / attr.blksize);\n   return attr;\n  },\n  setattr: function(node, attr) {\n   if (attr.mode !== undefined) {\n    node.mode = attr.mode;\n   }\n   if (attr.timestamp !== undefined) {\n    node.timestamp = attr.timestamp;\n   }\n   if (attr.size !== undefined) {\n    MEMFS.resizeFileStorage(node, attr.size);\n   }\n  },\n  lookup: function(parent, name) {\n   throw FS.genericErrors[44];\n  },\n  mknod: function(parent, name, mode, dev) {\n   return MEMFS.createNode(parent, name, mode, dev);\n  },\n  rename: function(old_node, new_dir, new_name) {\n   if (FS.isDir(old_node.mode)) {\n    var new_node;\n    try {\n     new_node = FS.lookupNode(new_dir, new_name);\n    } catch (e) {}\n    if (new_node) {\n     for (var i in new_node.contents) {\n      throw new FS.ErrnoError(55);\n     }\n    }\n   }\n   delete old_node.parent.contents[old_node.name];\n   old_node.parent.timestamp = Date.now();\n   old_node.name = new_name;\n   new_dir.contents[new_name] = old_node;\n   new_dir.timestamp = old_node.parent.timestamp;\n   old_node.parent = new_dir;\n  },\n  unlink: function(parent, name) {\n   delete parent.contents[name];\n   parent.timestamp = Date.now();\n  },\n  rmdir: function(parent, name) {\n   var node = FS.lookupNode(parent, name);\n   for (var i in node.contents) {\n    throw new FS.ErrnoError(55);\n   }\n   delete parent.contents[name];\n   parent.timestamp = Date.now();\n  },\n  readdir: function(node) {\n   var entries = [ \".\", \"..\" ];\n   for (var key in node.contents) {\n    if (!node.contents.hasOwnProperty(key)) {\n     continue;\n    }\n    entries.push(key);\n   }\n   return entries;\n  },\n  symlink: function(parent, newname, oldpath) {\n   var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n   node.link = oldpath;\n   return node;\n  },\n  readlink: function(node) {\n   if (!FS.isLink(node.mode)) {\n    throw new FS.ErrnoError(28);\n   }\n   return node.link;\n  }\n },\n stream_ops: {\n  read: function(stream, buffer, offset, length, position) {\n   var contents = stream.node.contents;\n   if (position >= stream.node.usedBytes) return 0;\n   var size = Math.min(stream.node.usedBytes - position, length);\n   assert(size >= 0);\n   if (size > 8 && contents.subarray) {\n    buffer.set(contents.subarray(position, position + size), offset);\n   } else {\n    for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\n   }\n   return size;\n  },\n  write: function(stream, buffer, offset, length, position, canOwn) {\n   assert(!(buffer instanceof ArrayBuffer));\n   if (buffer.buffer === GROWABLE_HEAP_I8().buffer) {\n    canOwn = false;\n   }\n   if (!length) return 0;\n   var node = stream.node;\n   node.timestamp = Date.now();\n   if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n    if (canOwn) {\n     assert(position === 0, \"canOwn must imply no weird position inside the file\");\n     node.contents = buffer.subarray(offset, offset + length);\n     node.usedBytes = length;\n     return length;\n    } else if (node.usedBytes === 0 && position === 0) {\n     node.contents = buffer.slice(offset, offset + length);\n     node.usedBytes = length;\n     return length;\n    } else if (position + length <= node.usedBytes) {\n     node.contents.set(buffer.subarray(offset, offset + length), position);\n     return length;\n    }\n   }\n   MEMFS.expandFileStorage(node, position + length);\n   if (node.contents.subarray && buffer.subarray) {\n    node.contents.set(buffer.subarray(offset, offset + length), position);\n   } else {\n    for (var i = 0; i < length; i++) {\n     node.contents[position + i] = buffer[offset + i];\n    }\n   }\n   node.usedBytes = Math.max(node.usedBytes, position + length);\n   return length;\n  },\n  llseek: function(stream, offset, whence) {\n   var position = offset;\n   if (whence === 1) {\n    position += stream.position;\n   } else if (whence === 2) {\n    if (FS.isFile(stream.node.mode)) {\n     position += stream.node.usedBytes;\n    }\n   }\n   if (position < 0) {\n    throw new FS.ErrnoError(28);\n   }\n   return position;\n  },\n  allocate: function(stream, offset, length) {\n   MEMFS.expandFileStorage(stream.node, offset + length);\n   stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n  },\n  mmap: function(stream, length, position, prot, flags) {\n   if (!FS.isFile(stream.node.mode)) {\n    throw new FS.ErrnoError(43);\n   }\n   var ptr;\n   var allocated;\n   var contents = stream.node.contents;\n   if (!(flags & 2) && contents.buffer === GROWABLE_HEAP_I8().buffer) {\n    allocated = false;\n    ptr = contents.byteOffset;\n   } else {\n    if (position > 0 || position + length < contents.length) {\n     if (contents.subarray) {\n      contents = contents.subarray(position, position + length);\n     } else {\n      contents = Array.prototype.slice.call(contents, position, position + length);\n     }\n    }\n    allocated = true;\n    ptr = mmapAlloc(length);\n    if (!ptr) {\n     throw new FS.ErrnoError(48);\n    }\n    GROWABLE_HEAP_I8().set(contents, ptr);\n   }\n   return {\n    ptr: ptr,\n    allocated: allocated\n   };\n  },\n  msync: function(stream, buffer, offset, length, mmapFlags) {\n   MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n   return 0;\n  }\n }\n};\n\nfunction asyncLoad(url, onload, onerror, noRunDep) {\n var dep = !noRunDep ? getUniqueRunDependency(\"al \" + url) : \"\";\n readAsync(url, arrayBuffer => {\n  assert(arrayBuffer, 'Loading data file \"' + url + '\" failed (no arrayBuffer).');\n  onload(new Uint8Array(arrayBuffer));\n  if (dep) removeRunDependency(dep);\n }, event => {\n  if (onerror) {\n   onerror();\n  } else {\n   throw 'Loading data file \"' + url + '\" failed.';\n  }\n });\n if (dep) addRunDependency(dep);\n}\n\nvar ERRNO_MESSAGES = {\n 0: \"Success\",\n 1: \"Arg list too long\",\n 2: \"Permission denied\",\n 3: \"Address already in use\",\n 4: \"Address not available\",\n 5: \"Address family not supported by protocol family\",\n 6: \"No more processes\",\n 7: \"Socket already connected\",\n 8: \"Bad file number\",\n 9: \"Trying to read unreadable message\",\n 10: \"Mount device busy\",\n 11: \"Operation canceled\",\n 12: \"No children\",\n 13: \"Connection aborted\",\n 14: \"Connection refused\",\n 15: \"Connection reset by peer\",\n 16: \"File locking deadlock error\",\n 17: \"Destination address required\",\n 18: \"Math arg out of domain of func\",\n 19: \"Quota exceeded\",\n 20: \"File exists\",\n 21: \"Bad address\",\n 22: \"File too large\",\n 23: \"Host is unreachable\",\n 24: \"Identifier removed\",\n 25: \"Illegal byte sequence\",\n 26: \"Connection already in progress\",\n 27: \"Interrupted system call\",\n 28: \"Invalid argument\",\n 29: \"I/O error\",\n 30: \"Socket is already connected\",\n 31: \"Is a directory\",\n 32: \"Too many symbolic links\",\n 33: \"Too many open files\",\n 34: \"Too many links\",\n 35: \"Message too long\",\n 36: \"Multihop attempted\",\n 37: \"File or path name too long\",\n 38: \"Network interface is not configured\",\n 39: \"Connection reset by network\",\n 40: \"Network is unreachable\",\n 41: \"Too many open files in system\",\n 42: \"No buffer space available\",\n 43: \"No such device\",\n 44: \"No such file or directory\",\n 45: \"Exec format error\",\n 46: \"No record locks available\",\n 47: \"The link has been severed\",\n 48: \"Not enough core\",\n 49: \"No message of desired type\",\n 50: \"Protocol not available\",\n 51: \"No space left on device\",\n 52: \"Function not implemented\",\n 53: \"Socket is not connected\",\n 54: \"Not a directory\",\n 55: \"Directory not empty\",\n 56: \"State not recoverable\",\n 57: \"Socket operation on non-socket\",\n 59: \"Not a typewriter\",\n 60: \"No such device or address\",\n 61: \"Value too large for defined data type\",\n 62: \"Previous owner died\",\n 63: \"Not super-user\",\n 64: \"Broken pipe\",\n 65: \"Protocol error\",\n 66: \"Unknown protocol\",\n 67: \"Protocol wrong type for socket\",\n 68: \"Math result not representable\",\n 69: \"Read only file system\",\n 70: \"Illegal seek\",\n 71: \"No such process\",\n 72: \"Stale file handle\",\n 73: \"Connection timed out\",\n 74: \"Text file busy\",\n 75: \"Cross-device link\",\n 100: \"Device not a stream\",\n 101: \"Bad font file fmt\",\n 102: \"Invalid slot\",\n 103: \"Invalid request code\",\n 104: \"No anode\",\n 105: \"Block device required\",\n 106: \"Channel number out of range\",\n 107: \"Level 3 halted\",\n 108: \"Level 3 reset\",\n 109: \"Link number out of range\",\n 110: \"Protocol driver not attached\",\n 111: \"No CSI structure available\",\n 112: \"Level 2 halted\",\n 113: \"Invalid exchange\",\n 114: \"Invalid request descriptor\",\n 115: \"Exchange full\",\n 116: \"No data (for no delay io)\",\n 117: \"Timer expired\",\n 118: \"Out of streams resources\",\n 119: \"Machine is not on the network\",\n 120: \"Package not installed\",\n 121: \"The object is remote\",\n 122: \"Advertise error\",\n 123: \"Srmount error\",\n 124: \"Communication error on send\",\n 125: \"Cross mount point (not really error)\",\n 126: \"Given log. name not unique\",\n 127: \"f.d. invalid for this operation\",\n 128: \"Remote address changed\",\n 129: \"Can   access a needed shared lib\",\n 130: \"Accessing a corrupted shared lib\",\n 131: \".lib section in a.out corrupted\",\n 132: \"Attempting to link in too many libs\",\n 133: \"Attempting to exec a shared library\",\n 135: \"Streams pipe error\",\n 136: \"Too many users\",\n 137: \"Socket type not supported\",\n 138: \"Not supported\",\n 139: \"Protocol family not supported\",\n 140: \"Can't send after socket shutdown\",\n 141: \"Too many references\",\n 142: \"Host is down\",\n 148: \"No medium (in tape drive)\",\n 156: \"Level 2 not synchronized\"\n};\n\nvar ERRNO_CODES = {};\n\nfunction demangle(func) {\n warnOnce(\"warning: build with -sDEMANGLE_SUPPORT to link in libcxxabi demangling\");\n return func;\n}\n\nfunction demangleAll(text) {\n var regex = /\\b_Z[\\w\\d_]+/g;\n return text.replace(regex, function(x) {\n  var y = demangle(x);\n  return x === y ? x : y + \" [\" + x + \"]\";\n });\n}\n\nvar FS = {\n root: null,\n mounts: [],\n devices: {},\n streams: [],\n nextInode: 1,\n nameTable: null,\n currentPath: \"/\",\n initialized: false,\n ignorePermissions: true,\n ErrnoError: null,\n genericErrors: {},\n filesystems: null,\n syncFSRequests: 0,\n lookupPath: (path, opts = {}) => {\n  path = PATH_FS.resolve(path);\n  if (!path) return {\n   path: \"\",\n   node: null\n  };\n  var defaults = {\n   follow_mount: true,\n   recurse_count: 0\n  };\n  opts = Object.assign(defaults, opts);\n  if (opts.recurse_count > 8) {\n   throw new FS.ErrnoError(32);\n  }\n  var parts = path.split(\"/\").filter(p => !!p);\n  var current = FS.root;\n  var current_path = \"/\";\n  for (var i = 0; i < parts.length; i++) {\n   var islast = i === parts.length - 1;\n   if (islast && opts.parent) {\n    break;\n   }\n   current = FS.lookupNode(current, parts[i]);\n   current_path = PATH.join2(current_path, parts[i]);\n   if (FS.isMountpoint(current)) {\n    if (!islast || islast && opts.follow_mount) {\n     current = current.mounted.root;\n    }\n   }\n   if (!islast || opts.follow) {\n    var count = 0;\n    while (FS.isLink(current.mode)) {\n     var link = FS.readlink(current_path);\n     current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n     var lookup = FS.lookupPath(current_path, {\n      recurse_count: opts.recurse_count + 1\n     });\n     current = lookup.node;\n     if (count++ > 40) {\n      throw new FS.ErrnoError(32);\n     }\n    }\n   }\n  }\n  return {\n   path: current_path,\n   node: current\n  };\n },\n getPath: node => {\n  var path;\n  while (true) {\n   if (FS.isRoot(node)) {\n    var mount = node.mount.mountpoint;\n    if (!path) return mount;\n    return mount[mount.length - 1] !== \"/\" ? mount + \"/\" + path : mount + path;\n   }\n   path = path ? node.name + \"/\" + path : node.name;\n   node = node.parent;\n  }\n },\n hashName: (parentid, name) => {\n  var hash = 0;\n  for (var i = 0; i < name.length; i++) {\n   hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n  }\n  return (parentid + hash >>> 0) % FS.nameTable.length;\n },\n hashAddNode: node => {\n  var hash = FS.hashName(node.parent.id, node.name);\n  node.name_next = FS.nameTable[hash];\n  FS.nameTable[hash] = node;\n },\n hashRemoveNode: node => {\n  var hash = FS.hashName(node.parent.id, node.name);\n  if (FS.nameTable[hash] === node) {\n   FS.nameTable[hash] = node.name_next;\n  } else {\n   var current = FS.nameTable[hash];\n   while (current) {\n    if (current.name_next === node) {\n     current.name_next = node.name_next;\n     break;\n    }\n    current = current.name_next;\n   }\n  }\n },\n lookupNode: (parent, name) => {\n  var errCode = FS.mayLookup(parent);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode, parent);\n  }\n  var hash = FS.hashName(parent.id, name);\n  for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n   var nodeName = node.name;\n   if (node.parent.id === parent.id && nodeName === name) {\n    return node;\n   }\n  }\n  return FS.lookup(parent, name);\n },\n createNode: (parent, name, mode, rdev) => {\n  assert(typeof parent == \"object\");\n  var node = new FS.FSNode(parent, name, mode, rdev);\n  FS.hashAddNode(node);\n  return node;\n },\n destroyNode: node => {\n  FS.hashRemoveNode(node);\n },\n isRoot: node => {\n  return node === node.parent;\n },\n isMountpoint: node => {\n  return !!node.mounted;\n },\n isFile: mode => {\n  return (mode & 61440) === 32768;\n },\n isDir: mode => {\n  return (mode & 61440) === 16384;\n },\n isLink: mode => {\n  return (mode & 61440) === 40960;\n },\n isChrdev: mode => {\n  return (mode & 61440) === 8192;\n },\n isBlkdev: mode => {\n  return (mode & 61440) === 24576;\n },\n isFIFO: mode => {\n  return (mode & 61440) === 4096;\n },\n isSocket: mode => {\n  return (mode & 49152) === 49152;\n },\n flagModes: {\n  \"r\": 0,\n  \"r+\": 2,\n  \"w\": 577,\n  \"w+\": 578,\n  \"a\": 1089,\n  \"a+\": 1090\n },\n modeStringToFlags: str => {\n  var flags = FS.flagModes[str];\n  if (typeof flags == \"undefined\") {\n   throw new Error(\"Unknown file open mode: \" + str);\n  }\n  return flags;\n },\n flagsToPermissionString: flag => {\n  var perms = [ \"r\", \"w\", \"rw\" ][flag & 3];\n  if (flag & 512) {\n   perms += \"w\";\n  }\n  return perms;\n },\n nodePermissions: (node, perms) => {\n  if (FS.ignorePermissions) {\n   return 0;\n  }\n  if (perms.includes(\"r\") && !(node.mode & 292)) {\n   return 2;\n  } else if (perms.includes(\"w\") && !(node.mode & 146)) {\n   return 2;\n  } else if (perms.includes(\"x\") && !(node.mode & 73)) {\n   return 2;\n  }\n  return 0;\n },\n mayLookup: dir => {\n  var errCode = FS.nodePermissions(dir, \"x\");\n  if (errCode) return errCode;\n  if (!dir.node_ops.lookup) return 2;\n  return 0;\n },\n mayCreate: (dir, name) => {\n  try {\n   var node = FS.lookupNode(dir, name);\n   return 20;\n  } catch (e) {}\n  return FS.nodePermissions(dir, \"wx\");\n },\n mayDelete: (dir, name, isdir) => {\n  var node;\n  try {\n   node = FS.lookupNode(dir, name);\n  } catch (e) {\n   return e.errno;\n  }\n  var errCode = FS.nodePermissions(dir, \"wx\");\n  if (errCode) {\n   return errCode;\n  }\n  if (isdir) {\n   if (!FS.isDir(node.mode)) {\n    return 54;\n   }\n   if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n    return 10;\n   }\n  } else {\n   if (FS.isDir(node.mode)) {\n    return 31;\n   }\n  }\n  return 0;\n },\n mayOpen: (node, flags) => {\n  if (!node) {\n   return 44;\n  }\n  if (FS.isLink(node.mode)) {\n   return 32;\n  } else if (FS.isDir(node.mode)) {\n   if (FS.flagsToPermissionString(flags) !== \"r\" || flags & 512) {\n    return 31;\n   }\n  }\n  return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n },\n MAX_OPEN_FDS: 4096,\n nextfd: (fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {\n  for (var fd = fd_start; fd <= fd_end; fd++) {\n   if (!FS.streams[fd]) {\n    return fd;\n   }\n  }\n  throw new FS.ErrnoError(33);\n },\n getStream: fd => FS.streams[fd],\n createStream: (stream, fd_start, fd_end) => {\n  if (!FS.FSStream) {\n   FS.FSStream = function() {\n    this.shared = {};\n   };\n   FS.FSStream.prototype = {};\n   Object.defineProperties(FS.FSStream.prototype, {\n    object: {\n     get: function() {\n      return this.node;\n     },\n     set: function(val) {\n      this.node = val;\n     }\n    },\n    isRead: {\n     get: function() {\n      return (this.flags & 2097155) !== 1;\n     }\n    },\n    isWrite: {\n     get: function() {\n      return (this.flags & 2097155) !== 0;\n     }\n    },\n    isAppend: {\n     get: function() {\n      return this.flags & 1024;\n     }\n    },\n    flags: {\n     get: function() {\n      return this.shared.flags;\n     },\n     set: function(val) {\n      this.shared.flags = val;\n     }\n    },\n    position: {\n     get: function() {\n      return this.shared.position;\n     },\n     set: function(val) {\n      this.shared.position = val;\n     }\n    }\n   });\n  }\n  stream = Object.assign(new FS.FSStream(), stream);\n  var fd = FS.nextfd(fd_start, fd_end);\n  stream.fd = fd;\n  FS.streams[fd] = stream;\n  return stream;\n },\n closeStream: fd => {\n  FS.streams[fd] = null;\n },\n chrdev_stream_ops: {\n  open: stream => {\n   var device = FS.getDevice(stream.node.rdev);\n   stream.stream_ops = device.stream_ops;\n   if (stream.stream_ops.open) {\n    stream.stream_ops.open(stream);\n   }\n  },\n  llseek: () => {\n   throw new FS.ErrnoError(70);\n  }\n },\n major: dev => dev >> 8,\n minor: dev => dev & 255,\n makedev: (ma, mi) => ma << 8 | mi,\n registerDevice: (dev, ops) => {\n  FS.devices[dev] = {\n   stream_ops: ops\n  };\n },\n getDevice: dev => FS.devices[dev],\n getMounts: mount => {\n  var mounts = [];\n  var check = [ mount ];\n  while (check.length) {\n   var m = check.pop();\n   mounts.push(m);\n   check.push.apply(check, m.mounts);\n  }\n  return mounts;\n },\n syncfs: (populate, callback) => {\n  if (typeof populate == \"function\") {\n   callback = populate;\n   populate = false;\n  }\n  FS.syncFSRequests++;\n  if (FS.syncFSRequests > 1) {\n   err(\"warning: \" + FS.syncFSRequests + \" FS.syncfs operations in flight at once, probably just doing extra work\");\n  }\n  var mounts = FS.getMounts(FS.root.mount);\n  var completed = 0;\n  function doCallback(errCode) {\n   assert(FS.syncFSRequests > 0);\n   FS.syncFSRequests--;\n   return callback(errCode);\n  }\n  function done(errCode) {\n   if (errCode) {\n    if (!done.errored) {\n     done.errored = true;\n     return doCallback(errCode);\n    }\n    return;\n   }\n   if (++completed >= mounts.length) {\n    doCallback(null);\n   }\n  }\n  mounts.forEach(mount => {\n   if (!mount.type.syncfs) {\n    return done(null);\n   }\n   mount.type.syncfs(mount, populate, done);\n  });\n },\n mount: (type, opts, mountpoint) => {\n  if (typeof type == \"string\") {\n   throw type;\n  }\n  var root = mountpoint === \"/\";\n  var pseudo = !mountpoint;\n  var node;\n  if (root && FS.root) {\n   throw new FS.ErrnoError(10);\n  } else if (!root && !pseudo) {\n   var lookup = FS.lookupPath(mountpoint, {\n    follow_mount: false\n   });\n   mountpoint = lookup.path;\n   node = lookup.node;\n   if (FS.isMountpoint(node)) {\n    throw new FS.ErrnoError(10);\n   }\n   if (!FS.isDir(node.mode)) {\n    throw new FS.ErrnoError(54);\n   }\n  }\n  var mount = {\n   type: type,\n   opts: opts,\n   mountpoint: mountpoint,\n   mounts: []\n  };\n  var mountRoot = type.mount(mount);\n  mountRoot.mount = mount;\n  mount.root = mountRoot;\n  if (root) {\n   FS.root = mountRoot;\n  } else if (node) {\n   node.mounted = mount;\n   if (node.mount) {\n    node.mount.mounts.push(mount);\n   }\n  }\n  return mountRoot;\n },\n unmount: mountpoint => {\n  var lookup = FS.lookupPath(mountpoint, {\n   follow_mount: false\n  });\n  if (!FS.isMountpoint(lookup.node)) {\n   throw new FS.ErrnoError(28);\n  }\n  var node = lookup.node;\n  var mount = node.mounted;\n  var mounts = FS.getMounts(mount);\n  Object.keys(FS.nameTable).forEach(hash => {\n   var current = FS.nameTable[hash];\n   while (current) {\n    var next = current.name_next;\n    if (mounts.includes(current.mount)) {\n     FS.destroyNode(current);\n    }\n    current = next;\n   }\n  });\n  node.mounted = null;\n  var idx = node.mount.mounts.indexOf(mount);\n  assert(idx !== -1);\n  node.mount.mounts.splice(idx, 1);\n },\n lookup: (parent, name) => {\n  return parent.node_ops.lookup(parent, name);\n },\n mknod: (path, mode, dev) => {\n  var lookup = FS.lookupPath(path, {\n   parent: true\n  });\n  var parent = lookup.node;\n  var name = PATH.basename(path);\n  if (!name || name === \".\" || name === \"..\") {\n   throw new FS.ErrnoError(28);\n  }\n  var errCode = FS.mayCreate(parent, name);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  if (!parent.node_ops.mknod) {\n   throw new FS.ErrnoError(63);\n  }\n  return parent.node_ops.mknod(parent, name, mode, dev);\n },\n create: (path, mode) => {\n  mode = mode !== undefined ? mode : 438;\n  mode &= 4095;\n  mode |= 32768;\n  return FS.mknod(path, mode, 0);\n },\n mkdir: (path, mode) => {\n  mode = mode !== undefined ? mode : 511;\n  mode &= 511 | 512;\n  mode |= 16384;\n  return FS.mknod(path, mode, 0);\n },\n mkdirTree: (path, mode) => {\n  var dirs = path.split(\"/\");\n  var d = \"\";\n  for (var i = 0; i < dirs.length; ++i) {\n   if (!dirs[i]) continue;\n   d += \"/\" + dirs[i];\n   try {\n    FS.mkdir(d, mode);\n   } catch (e) {\n    if (e.errno != 20) throw e;\n   }\n  }\n },\n mkdev: (path, mode, dev) => {\n  if (typeof dev == \"undefined\") {\n   dev = mode;\n   mode = 438;\n  }\n  mode |= 8192;\n  return FS.mknod(path, mode, dev);\n },\n symlink: (oldpath, newpath) => {\n  if (!PATH_FS.resolve(oldpath)) {\n   throw new FS.ErrnoError(44);\n  }\n  var lookup = FS.lookupPath(newpath, {\n   parent: true\n  });\n  var parent = lookup.node;\n  if (!parent) {\n   throw new FS.ErrnoError(44);\n  }\n  var newname = PATH.basename(newpath);\n  var errCode = FS.mayCreate(parent, newname);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  if (!parent.node_ops.symlink) {\n   throw new FS.ErrnoError(63);\n  }\n  return parent.node_ops.symlink(parent, newname, oldpath);\n },\n rename: (old_path, new_path) => {\n  var old_dirname = PATH.dirname(old_path);\n  var new_dirname = PATH.dirname(new_path);\n  var old_name = PATH.basename(old_path);\n  var new_name = PATH.basename(new_path);\n  var lookup, old_dir, new_dir;\n  lookup = FS.lookupPath(old_path, {\n   parent: true\n  });\n  old_dir = lookup.node;\n  lookup = FS.lookupPath(new_path, {\n   parent: true\n  });\n  new_dir = lookup.node;\n  if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n  if (old_dir.mount !== new_dir.mount) {\n   throw new FS.ErrnoError(75);\n  }\n  var old_node = FS.lookupNode(old_dir, old_name);\n  var relative = PATH_FS.relative(old_path, new_dirname);\n  if (relative.charAt(0) !== \".\") {\n   throw new FS.ErrnoError(28);\n  }\n  relative = PATH_FS.relative(new_path, old_dirname);\n  if (relative.charAt(0) !== \".\") {\n   throw new FS.ErrnoError(55);\n  }\n  var new_node;\n  try {\n   new_node = FS.lookupNode(new_dir, new_name);\n  } catch (e) {}\n  if (old_node === new_node) {\n   return;\n  }\n  var isdir = FS.isDir(old_node.mode);\n  var errCode = FS.mayDelete(old_dir, old_name, isdir);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  if (!old_dir.node_ops.rename) {\n   throw new FS.ErrnoError(63);\n  }\n  if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n   throw new FS.ErrnoError(10);\n  }\n  if (new_dir !== old_dir) {\n   errCode = FS.nodePermissions(old_dir, \"w\");\n   if (errCode) {\n    throw new FS.ErrnoError(errCode);\n   }\n  }\n  FS.hashRemoveNode(old_node);\n  try {\n   old_dir.node_ops.rename(old_node, new_dir, new_name);\n  } catch (e) {\n   throw e;\n  } finally {\n   FS.hashAddNode(old_node);\n  }\n },\n rmdir: path => {\n  var lookup = FS.lookupPath(path, {\n   parent: true\n  });\n  var parent = lookup.node;\n  var name = PATH.basename(path);\n  var node = FS.lookupNode(parent, name);\n  var errCode = FS.mayDelete(parent, name, true);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  if (!parent.node_ops.rmdir) {\n   throw new FS.ErrnoError(63);\n  }\n  if (FS.isMountpoint(node)) {\n   throw new FS.ErrnoError(10);\n  }\n  parent.node_ops.rmdir(parent, name);\n  FS.destroyNode(node);\n },\n readdir: path => {\n  var lookup = FS.lookupPath(path, {\n   follow: true\n  });\n  var node = lookup.node;\n  if (!node.node_ops.readdir) {\n   throw new FS.ErrnoError(54);\n  }\n  return node.node_ops.readdir(node);\n },\n unlink: path => {\n  var lookup = FS.lookupPath(path, {\n   parent: true\n  });\n  var parent = lookup.node;\n  if (!parent) {\n   throw new FS.ErrnoError(44);\n  }\n  var name = PATH.basename(path);\n  var node = FS.lookupNode(parent, name);\n  var errCode = FS.mayDelete(parent, name, false);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  if (!parent.node_ops.unlink) {\n   throw new FS.ErrnoError(63);\n  }\n  if (FS.isMountpoint(node)) {\n   throw new FS.ErrnoError(10);\n  }\n  parent.node_ops.unlink(parent, name);\n  FS.destroyNode(node);\n },\n readlink: path => {\n  var lookup = FS.lookupPath(path);\n  var link = lookup.node;\n  if (!link) {\n   throw new FS.ErrnoError(44);\n  }\n  if (!link.node_ops.readlink) {\n   throw new FS.ErrnoError(28);\n  }\n  return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n },\n stat: (path, dontFollow) => {\n  var lookup = FS.lookupPath(path, {\n   follow: !dontFollow\n  });\n  var node = lookup.node;\n  if (!node) {\n   throw new FS.ErrnoError(44);\n  }\n  if (!node.node_ops.getattr) {\n   throw new FS.ErrnoError(63);\n  }\n  return node.node_ops.getattr(node);\n },\n lstat: path => {\n  return FS.stat(path, true);\n },\n chmod: (path, mode, dontFollow) => {\n  var node;\n  if (typeof path == \"string\") {\n   var lookup = FS.lookupPath(path, {\n    follow: !dontFollow\n   });\n   node = lookup.node;\n  } else {\n   node = path;\n  }\n  if (!node.node_ops.setattr) {\n   throw new FS.ErrnoError(63);\n  }\n  node.node_ops.setattr(node, {\n   mode: mode & 4095 | node.mode & ~4095,\n   timestamp: Date.now()\n  });\n },\n lchmod: (path, mode) => {\n  FS.chmod(path, mode, true);\n },\n fchmod: (fd, mode) => {\n  var stream = FS.getStream(fd);\n  if (!stream) {\n   throw new FS.ErrnoError(8);\n  }\n  FS.chmod(stream.node, mode);\n },\n chown: (path, uid, gid, dontFollow) => {\n  var node;\n  if (typeof path == \"string\") {\n   var lookup = FS.lookupPath(path, {\n    follow: !dontFollow\n   });\n   node = lookup.node;\n  } else {\n   node = path;\n  }\n  if (!node.node_ops.setattr) {\n   throw new FS.ErrnoError(63);\n  }\n  node.node_ops.setattr(node, {\n   timestamp: Date.now()\n  });\n },\n lchown: (path, uid, gid) => {\n  FS.chown(path, uid, gid, true);\n },\n fchown: (fd, uid, gid) => {\n  var stream = FS.getStream(fd);\n  if (!stream) {\n   throw new FS.ErrnoError(8);\n  }\n  FS.chown(stream.node, uid, gid);\n },\n truncate: (path, len) => {\n  if (len < 0) {\n   throw new FS.ErrnoError(28);\n  }\n  var node;\n  if (typeof path == \"string\") {\n   var lookup = FS.lookupPath(path, {\n    follow: true\n   });\n   node = lookup.node;\n  } else {\n   node = path;\n  }\n  if (!node.node_ops.setattr) {\n   throw new FS.ErrnoError(63);\n  }\n  if (FS.isDir(node.mode)) {\n   throw new FS.ErrnoError(31);\n  }\n  if (!FS.isFile(node.mode)) {\n   throw new FS.ErrnoError(28);\n  }\n  var errCode = FS.nodePermissions(node, \"w\");\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  node.node_ops.setattr(node, {\n   size: len,\n   timestamp: Date.now()\n  });\n },\n ftruncate: (fd, len) => {\n  var stream = FS.getStream(fd);\n  if (!stream) {\n   throw new FS.ErrnoError(8);\n  }\n  if ((stream.flags & 2097155) === 0) {\n   throw new FS.ErrnoError(28);\n  }\n  FS.truncate(stream.node, len);\n },\n utime: (path, atime, mtime) => {\n  var lookup = FS.lookupPath(path, {\n   follow: true\n  });\n  var node = lookup.node;\n  node.node_ops.setattr(node, {\n   timestamp: Math.max(atime, mtime)\n  });\n },\n open: (path, flags, mode) => {\n  if (path === \"\") {\n   throw new FS.ErrnoError(44);\n  }\n  flags = typeof flags == \"string\" ? FS.modeStringToFlags(flags) : flags;\n  mode = typeof mode == \"undefined\" ? 438 : mode;\n  if (flags & 64) {\n   mode = mode & 4095 | 32768;\n  } else {\n   mode = 0;\n  }\n  var node;\n  if (typeof path == \"object\") {\n   node = path;\n  } else {\n   path = PATH.normalize(path);\n   try {\n    var lookup = FS.lookupPath(path, {\n     follow: !(flags & 131072)\n    });\n    node = lookup.node;\n   } catch (e) {}\n  }\n  var created = false;\n  if (flags & 64) {\n   if (node) {\n    if (flags & 128) {\n     throw new FS.ErrnoError(20);\n    }\n   } else {\n    node = FS.mknod(path, mode, 0);\n    created = true;\n   }\n  }\n  if (!node) {\n   throw new FS.ErrnoError(44);\n  }\n  if (FS.isChrdev(node.mode)) {\n   flags &= ~512;\n  }\n  if (flags & 65536 && !FS.isDir(node.mode)) {\n   throw new FS.ErrnoError(54);\n  }\n  if (!created) {\n   var errCode = FS.mayOpen(node, flags);\n   if (errCode) {\n    throw new FS.ErrnoError(errCode);\n   }\n  }\n  if (flags & 512 && !created) {\n   FS.truncate(node, 0);\n  }\n  flags &= ~(128 | 512 | 131072);\n  var stream = FS.createStream({\n   node: node,\n   path: FS.getPath(node),\n   flags: flags,\n   seekable: true,\n   position: 0,\n   stream_ops: node.stream_ops,\n   ungotten: [],\n   error: false\n  });\n  if (stream.stream_ops.open) {\n   stream.stream_ops.open(stream);\n  }\n  if (Module[\"logReadFiles\"] && !(flags & 1)) {\n   if (!FS.readFiles) FS.readFiles = {};\n   if (!(path in FS.readFiles)) {\n    FS.readFiles[path] = 1;\n   }\n  }\n  return stream;\n },\n close: stream => {\n  if (FS.isClosed(stream)) {\n   throw new FS.ErrnoError(8);\n  }\n  if (stream.getdents) stream.getdents = null;\n  try {\n   if (stream.stream_ops.close) {\n    stream.stream_ops.close(stream);\n   }\n  } catch (e) {\n   throw e;\n  } finally {\n   FS.closeStream(stream.fd);\n  }\n  stream.fd = null;\n },\n isClosed: stream => {\n  return stream.fd === null;\n },\n llseek: (stream, offset, whence) => {\n  if (FS.isClosed(stream)) {\n   throw new FS.ErrnoError(8);\n  }\n  if (!stream.seekable || !stream.stream_ops.llseek) {\n   throw new FS.ErrnoError(70);\n  }\n  if (whence != 0 && whence != 1 && whence != 2) {\n   throw new FS.ErrnoError(28);\n  }\n  stream.position = stream.stream_ops.llseek(stream, offset, whence);\n  stream.ungotten = [];\n  return stream.position;\n },\n read: (stream, buffer, offset, length, position) => {\n  if (length < 0 || position < 0) {\n   throw new FS.ErrnoError(28);\n  }\n  if (FS.isClosed(stream)) {\n   throw new FS.ErrnoError(8);\n  }\n  if ((stream.flags & 2097155) === 1) {\n   throw new FS.ErrnoError(8);\n  }\n  if (FS.isDir(stream.node.mode)) {\n   throw new FS.ErrnoError(31);\n  }\n  if (!stream.stream_ops.read) {\n   throw new FS.ErrnoError(28);\n  }\n  var seeking = typeof position != \"undefined\";\n  if (!seeking) {\n   position = stream.position;\n  } else if (!stream.seekable) {\n   throw new FS.ErrnoError(70);\n  }\n  var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n  if (!seeking) stream.position += bytesRead;\n  return bytesRead;\n },\n write: (stream, buffer, offset, length, position, canOwn) => {\n  if (length < 0 || position < 0) {\n   throw new FS.ErrnoError(28);\n  }\n  if (FS.isClosed(stream)) {\n   throw new FS.ErrnoError(8);\n  }\n  if ((stream.flags & 2097155) === 0) {\n   throw new FS.ErrnoError(8);\n  }\n  if (FS.isDir(stream.node.mode)) {\n   throw new FS.ErrnoError(31);\n  }\n  if (!stream.stream_ops.write) {\n   throw new FS.ErrnoError(28);\n  }\n  if (stream.seekable && stream.flags & 1024) {\n   FS.llseek(stream, 0, 2);\n  }\n  var seeking = typeof position != \"undefined\";\n  if (!seeking) {\n   position = stream.position;\n  } else if (!stream.seekable) {\n   throw new FS.ErrnoError(70);\n  }\n  var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n  if (!seeking) stream.position += bytesWritten;\n  return bytesWritten;\n },\n allocate: (stream, offset, length) => {\n  if (FS.isClosed(stream)) {\n   throw new FS.ErrnoError(8);\n  }\n  if (offset < 0 || length <= 0) {\n   throw new FS.ErrnoError(28);\n  }\n  if ((stream.flags & 2097155) === 0) {\n   throw new FS.ErrnoError(8);\n  }\n  if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n   throw new FS.ErrnoError(43);\n  }\n  if (!stream.stream_ops.allocate) {\n   throw new FS.ErrnoError(138);\n  }\n  stream.stream_ops.allocate(stream, offset, length);\n },\n mmap: (stream, length, position, prot, flags) => {\n  if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n   throw new FS.ErrnoError(2);\n  }\n  if ((stream.flags & 2097155) === 1) {\n   throw new FS.ErrnoError(2);\n  }\n  if (!stream.stream_ops.mmap) {\n   throw new FS.ErrnoError(43);\n  }\n  return stream.stream_ops.mmap(stream, length, position, prot, flags);\n },\n msync: (stream, buffer, offset, length, mmapFlags) => {\n  if (!stream.stream_ops.msync) {\n   return 0;\n  }\n  return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n },\n munmap: stream => 0,\n ioctl: (stream, cmd, arg) => {\n  if (!stream.stream_ops.ioctl) {\n   throw new FS.ErrnoError(59);\n  }\n  return stream.stream_ops.ioctl(stream, cmd, arg);\n },\n readFile: (path, opts = {}) => {\n  opts.flags = opts.flags || 0;\n  opts.encoding = opts.encoding || \"binary\";\n  if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\n   throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\n  }\n  var ret;\n  var stream = FS.open(path, opts.flags);\n  var stat = FS.stat(path);\n  var length = stat.size;\n  var buf = new Uint8Array(length);\n  FS.read(stream, buf, 0, length, 0);\n  if (opts.encoding === \"utf8\") {\n   ret = UTF8ArrayToString(buf, 0);\n  } else if (opts.encoding === \"binary\") {\n   ret = buf;\n  }\n  FS.close(stream);\n  return ret;\n },\n writeFile: (path, data, opts = {}) => {\n  opts.flags = opts.flags || 577;\n  var stream = FS.open(path, opts.flags, opts.mode);\n  if (typeof data == \"string\") {\n   var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n   var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n   FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n  } else if (ArrayBuffer.isView(data)) {\n   FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n  } else {\n   throw new Error(\"Unsupported data type\");\n  }\n  FS.close(stream);\n },\n cwd: () => FS.currentPath,\n chdir: path => {\n  var lookup = FS.lookupPath(path, {\n   follow: true\n  });\n  if (lookup.node === null) {\n   throw new FS.ErrnoError(44);\n  }\n  if (!FS.isDir(lookup.node.mode)) {\n   throw new FS.ErrnoError(54);\n  }\n  var errCode = FS.nodePermissions(lookup.node, \"x\");\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  FS.currentPath = lookup.path;\n },\n createDefaultDirectories: () => {\n  FS.mkdir(\"/tmp\");\n  FS.mkdir(\"/home\");\n  FS.mkdir(\"/home/web_user\");\n },\n createDefaultDevices: () => {\n  FS.mkdir(\"/dev\");\n  FS.registerDevice(FS.makedev(1, 3), {\n   read: () => 0,\n   write: (stream, buffer, offset, length, pos) => length\n  });\n  FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\n  TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n  TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n  FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\n  FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\n  var randomBuffer = new Uint8Array(1024), randomLeft = 0;\n  var randomByte = () => {\n   if (randomLeft === 0) {\n    randomLeft = randomFill(randomBuffer).byteLength;\n   }\n   return randomBuffer[--randomLeft];\n  };\n  FS.createDevice(\"/dev\", \"random\", randomByte);\n  FS.createDevice(\"/dev\", \"urandom\", randomByte);\n  FS.mkdir(\"/dev/shm\");\n  FS.mkdir(\"/dev/shm/tmp\");\n },\n createSpecialDirectories: () => {\n  FS.mkdir(\"/proc\");\n  var proc_self = FS.mkdir(\"/proc/self\");\n  FS.mkdir(\"/proc/self/fd\");\n  FS.mount({\n   mount: () => {\n    var node = FS.createNode(proc_self, \"fd\", 16384 | 511, 73);\n    node.node_ops = {\n     lookup: (parent, name) => {\n      var fd = +name;\n      var stream = FS.getStream(fd);\n      if (!stream) throw new FS.ErrnoError(8);\n      var ret = {\n       parent: null,\n       mount: {\n        mountpoint: \"fake\"\n       },\n       node_ops: {\n        readlink: () => stream.path\n       }\n      };\n      ret.parent = ret;\n      return ret;\n     }\n    };\n    return node;\n   }\n  }, {}, \"/proc/self/fd\");\n },\n createStandardStreams: () => {\n  if (Module[\"stdin\"]) {\n   FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"]);\n  } else {\n   FS.symlink(\"/dev/tty\", \"/dev/stdin\");\n  }\n  if (Module[\"stdout\"]) {\n   FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"]);\n  } else {\n   FS.symlink(\"/dev/tty\", \"/dev/stdout\");\n  }\n  if (Module[\"stderr\"]) {\n   FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"]);\n  } else {\n   FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\n  }\n  var stdin = FS.open(\"/dev/stdin\", 0);\n  var stdout = FS.open(\"/dev/stdout\", 1);\n  var stderr = FS.open(\"/dev/stderr\", 1);\n  assert(stdin.fd === 0, \"invalid handle for stdin (\" + stdin.fd + \")\");\n  assert(stdout.fd === 1, \"invalid handle for stdout (\" + stdout.fd + \")\");\n  assert(stderr.fd === 2, \"invalid handle for stderr (\" + stderr.fd + \")\");\n },\n ensureErrnoError: () => {\n  if (FS.ErrnoError) return;\n  FS.ErrnoError = function ErrnoError(errno, node) {\n   this.name = \"ErrnoError\";\n   this.node = node;\n   this.setErrno = function(errno) {\n    this.errno = errno;\n    for (var key in ERRNO_CODES) {\n     if (ERRNO_CODES[key] === errno) {\n      this.code = key;\n      break;\n     }\n    }\n   };\n   this.setErrno(errno);\n   this.message = ERRNO_MESSAGES[errno];\n   if (this.stack) {\n    Object.defineProperty(this, \"stack\", {\n     value: new Error().stack,\n     writable: true\n    });\n    this.stack = demangleAll(this.stack);\n   }\n  };\n  FS.ErrnoError.prototype = new Error();\n  FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n  [ 44 ].forEach(code => {\n   FS.genericErrors[code] = new FS.ErrnoError(code);\n   FS.genericErrors[code].stack = \"<generic error, no stack>\";\n  });\n },\n staticInit: () => {\n  FS.ensureErrnoError();\n  FS.nameTable = new Array(4096);\n  FS.mount(MEMFS, {}, \"/\");\n  FS.createDefaultDirectories();\n  FS.createDefaultDevices();\n  FS.createSpecialDirectories();\n  FS.filesystems = {\n   \"MEMFS\": MEMFS\n  };\n },\n init: (input, output, error) => {\n  assert(!FS.init.initialized, \"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)\");\n  FS.init.initialized = true;\n  FS.ensureErrnoError();\n  Module[\"stdin\"] = input || Module[\"stdin\"];\n  Module[\"stdout\"] = output || Module[\"stdout\"];\n  Module[\"stderr\"] = error || Module[\"stderr\"];\n  FS.createStandardStreams();\n },\n quit: () => {\n  FS.init.initialized = false;\n  _fflush(0);\n  for (var i = 0; i < FS.streams.length; i++) {\n   var stream = FS.streams[i];\n   if (!stream) {\n    continue;\n   }\n   FS.close(stream);\n  }\n },\n getMode: (canRead, canWrite) => {\n  var mode = 0;\n  if (canRead) mode |= 292 | 73;\n  if (canWrite) mode |= 146;\n  return mode;\n },\n findObject: (path, dontResolveLastLink) => {\n  var ret = FS.analyzePath(path, dontResolveLastLink);\n  if (!ret.exists) {\n   return null;\n  }\n  return ret.object;\n },\n analyzePath: (path, dontResolveLastLink) => {\n  try {\n   var lookup = FS.lookupPath(path, {\n    follow: !dontResolveLastLink\n   });\n   path = lookup.path;\n  } catch (e) {}\n  var ret = {\n   isRoot: false,\n   exists: false,\n   error: 0,\n   name: null,\n   path: null,\n   object: null,\n   parentExists: false,\n   parentPath: null,\n   parentObject: null\n  };\n  try {\n   var lookup = FS.lookupPath(path, {\n    parent: true\n   });\n   ret.parentExists = true;\n   ret.parentPath = lookup.path;\n   ret.parentObject = lookup.node;\n   ret.name = PATH.basename(path);\n   lookup = FS.lookupPath(path, {\n    follow: !dontResolveLastLink\n   });\n   ret.exists = true;\n   ret.path = lookup.path;\n   ret.object = lookup.node;\n   ret.name = lookup.node.name;\n   ret.isRoot = lookup.path === \"/\";\n  } catch (e) {\n   ret.error = e.errno;\n  }\n  return ret;\n },\n createPath: (parent, path, canRead, canWrite) => {\n  parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\n  var parts = path.split(\"/\").reverse();\n  while (parts.length) {\n   var part = parts.pop();\n   if (!part) continue;\n   var current = PATH.join2(parent, part);\n   try {\n    FS.mkdir(current);\n   } catch (e) {}\n   parent = current;\n  }\n  return current;\n },\n createFile: (parent, name, properties, canRead, canWrite) => {\n  var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name);\n  var mode = FS.getMode(canRead, canWrite);\n  return FS.create(path, mode);\n },\n createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {\n  var path = name;\n  if (parent) {\n   parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\n   path = name ? PATH.join2(parent, name) : parent;\n  }\n  var mode = FS.getMode(canRead, canWrite);\n  var node = FS.create(path, mode);\n  if (data) {\n   if (typeof data == \"string\") {\n    var arr = new Array(data.length);\n    for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n    data = arr;\n   }\n   FS.chmod(node, mode | 146);\n   var stream = FS.open(node, 577);\n   FS.write(stream, data, 0, data.length, 0, canOwn);\n   FS.close(stream);\n   FS.chmod(node, mode);\n  }\n  return node;\n },\n createDevice: (parent, name, input, output) => {\n  var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name);\n  var mode = FS.getMode(!!input, !!output);\n  if (!FS.createDevice.major) FS.createDevice.major = 64;\n  var dev = FS.makedev(FS.createDevice.major++, 0);\n  FS.registerDevice(dev, {\n   open: stream => {\n    stream.seekable = false;\n   },\n   close: stream => {\n    if (output && output.buffer && output.buffer.length) {\n     output(10);\n    }\n   },\n   read: (stream, buffer, offset, length, pos) => {\n    var bytesRead = 0;\n    for (var i = 0; i < length; i++) {\n     var result;\n     try {\n      result = input();\n     } catch (e) {\n      throw new FS.ErrnoError(29);\n     }\n     if (result === undefined && bytesRead === 0) {\n      throw new FS.ErrnoError(6);\n     }\n     if (result === null || result === undefined) break;\n     bytesRead++;\n     buffer[offset + i] = result;\n    }\n    if (bytesRead) {\n     stream.node.timestamp = Date.now();\n    }\n    return bytesRead;\n   },\n   write: (stream, buffer, offset, length, pos) => {\n    for (var i = 0; i < length; i++) {\n     try {\n      output(buffer[offset + i]);\n     } catch (e) {\n      throw new FS.ErrnoError(29);\n     }\n    }\n    if (length) {\n     stream.node.timestamp = Date.now();\n    }\n    return i;\n   }\n  });\n  return FS.mkdev(path, mode, dev);\n },\n forceLoadFile: obj => {\n  if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n  if (typeof XMLHttpRequest != \"undefined\") {\n   throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n  } else if (read_) {\n   try {\n    obj.contents = intArrayFromString(read_(obj.url), true);\n    obj.usedBytes = obj.contents.length;\n   } catch (e) {\n    throw new FS.ErrnoError(29);\n   }\n  } else {\n   throw new Error(\"Cannot load without read() or XMLHttpRequest.\");\n  }\n },\n createLazyFile: (parent, name, url, canRead, canWrite) => {\n  function LazyUint8Array() {\n   this.lengthKnown = false;\n   this.chunks = [];\n  }\n  LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n   if (idx > this.length - 1 || idx < 0) {\n    return undefined;\n   }\n   var chunkOffset = idx % this.chunkSize;\n   var chunkNum = idx / this.chunkSize | 0;\n   return this.getter(chunkNum)[chunkOffset];\n  };\n  LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n   this.getter = getter;\n  };\n  LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n   var xhr = new XMLHttpRequest();\n   xhr.open(\"HEAD\", url, false);\n   xhr.send(null);\n   if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n   var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n   var header;\n   var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n   var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n   var chunkSize = 1024 * 1024;\n   if (!hasByteServing) chunkSize = datalength;\n   var doXHR = (from, to) => {\n    if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n    if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, false);\n    if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n    xhr.responseType = \"arraybuffer\";\n    if (xhr.overrideMimeType) {\n     xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n    }\n    xhr.send(null);\n    if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n    if (xhr.response !== undefined) {\n     return new Uint8Array(xhr.response || []);\n    }\n    return intArrayFromString(xhr.responseText || \"\", true);\n   };\n   var lazyArray = this;\n   lazyArray.setDataGetter(chunkNum => {\n    var start = chunkNum * chunkSize;\n    var end = (chunkNum + 1) * chunkSize - 1;\n    end = Math.min(end, datalength - 1);\n    if (typeof lazyArray.chunks[chunkNum] == \"undefined\") {\n     lazyArray.chunks[chunkNum] = doXHR(start, end);\n    }\n    if (typeof lazyArray.chunks[chunkNum] == \"undefined\") throw new Error(\"doXHR failed!\");\n    return lazyArray.chunks[chunkNum];\n   });\n   if (usesGzip || !datalength) {\n    chunkSize = datalength = 1;\n    datalength = this.getter(0).length;\n    chunkSize = datalength;\n    out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n   }\n   this._length = datalength;\n   this._chunkSize = chunkSize;\n   this.lengthKnown = true;\n  };\n  if (typeof XMLHttpRequest != \"undefined\") {\n   if (!ENVIRONMENT_IS_WORKER) throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\n   var lazyArray = new LazyUint8Array();\n   Object.defineProperties(lazyArray, {\n    length: {\n     get: function() {\n      if (!this.lengthKnown) {\n       this.cacheLength();\n      }\n      return this._length;\n     }\n    },\n    chunkSize: {\n     get: function() {\n      if (!this.lengthKnown) {\n       this.cacheLength();\n      }\n      return this._chunkSize;\n     }\n    }\n   });\n   var properties = {\n    isDevice: false,\n    contents: lazyArray\n   };\n  } else {\n   var properties = {\n    isDevice: false,\n    url: url\n   };\n  }\n  var node = FS.createFile(parent, name, properties, canRead, canWrite);\n  if (properties.contents) {\n   node.contents = properties.contents;\n  } else if (properties.url) {\n   node.contents = null;\n   node.url = properties.url;\n  }\n  Object.defineProperties(node, {\n   usedBytes: {\n    get: function() {\n     return this.contents.length;\n    }\n   }\n  });\n  var stream_ops = {};\n  var keys = Object.keys(node.stream_ops);\n  keys.forEach(key => {\n   var fn = node.stream_ops[key];\n   stream_ops[key] = function forceLoadLazyFile() {\n    FS.forceLoadFile(node);\n    return fn.apply(null, arguments);\n   };\n  });\n  function writeChunks(stream, buffer, offset, length, position) {\n   var contents = stream.node.contents;\n   if (position >= contents.length) return 0;\n   var size = Math.min(contents.length - position, length);\n   assert(size >= 0);\n   if (contents.slice) {\n    for (var i = 0; i < size; i++) {\n     buffer[offset + i] = contents[position + i];\n    }\n   } else {\n    for (var i = 0; i < size; i++) {\n     buffer[offset + i] = contents.get(position + i);\n    }\n   }\n   return size;\n  }\n  stream_ops.read = (stream, buffer, offset, length, position) => {\n   FS.forceLoadFile(node);\n   return writeChunks(stream, buffer, offset, length, position);\n  };\n  stream_ops.mmap = (stream, length, position, prot, flags) => {\n   FS.forceLoadFile(node);\n   var ptr = mmapAlloc(length);\n   if (!ptr) {\n    throw new FS.ErrnoError(48);\n   }\n   writeChunks(stream, GROWABLE_HEAP_I8(), ptr, length, position);\n   return {\n    ptr: ptr,\n    allocated: true\n   };\n  };\n  node.stream_ops = stream_ops;\n  return node;\n },\n createPreloadedFile: (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {\n  var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n  var dep = getUniqueRunDependency(\"cp \" + fullname);\n  function processData(byteArray) {\n   function finish(byteArray) {\n    if (preFinish) preFinish();\n    if (!dontCreateFile) {\n     FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n    }\n    if (onload) onload();\n    removeRunDependency(dep);\n   }\n   if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {\n    if (onerror) onerror();\n    removeRunDependency(dep);\n   })) {\n    return;\n   }\n   finish(byteArray);\n  }\n  addRunDependency(dep);\n  if (typeof url == \"string\") {\n   asyncLoad(url, byteArray => processData(byteArray), onerror);\n  } else {\n   processData(url);\n  }\n },\n absolutePath: () => {\n  abort(\"FS.absolutePath has been removed; use PATH_FS.resolve instead\");\n },\n createFolder: () => {\n  abort(\"FS.createFolder has been removed; use FS.mkdir instead\");\n },\n createLink: () => {\n  abort(\"FS.createLink has been removed; use FS.symlink instead\");\n },\n joinPath: () => {\n  abort(\"FS.joinPath has been removed; use PATH.join instead\");\n },\n mmapAlloc: () => {\n  abort(\"FS.mmapAlloc has been replaced by the top level function mmapAlloc\");\n },\n standardizePath: () => {\n  abort(\"FS.standardizePath has been removed; use PATH.normalize instead\");\n }\n};\n\nvar UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n\nfunction UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\n var endIdx = idx + maxBytesToRead;\n var endPtr = idx;\n while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n  return UTF8Decoder.decode(heapOrArray.buffer instanceof SharedArrayBuffer ? heapOrArray.slice(idx, endPtr) : heapOrArray.subarray(idx, endPtr));\n }\n var str = \"\";\n while (idx < endPtr) {\n  var u0 = heapOrArray[idx++];\n  if (!(u0 & 128)) {\n   str += String.fromCharCode(u0);\n   continue;\n  }\n  var u1 = heapOrArray[idx++] & 63;\n  if ((u0 & 224) == 192) {\n   str += String.fromCharCode((u0 & 31) << 6 | u1);\n   continue;\n  }\n  var u2 = heapOrArray[idx++] & 63;\n  if ((u0 & 240) == 224) {\n   u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n  } else {\n   if ((u0 & 248) != 240) warnOnce(\"Invalid UTF-8 leading byte \" + ptrToString(u0) + \" encountered when deserializing a UTF-8 string in wasm memory to a JS string!\");\n   u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n  }\n  if (u0 < 65536) {\n   str += String.fromCharCode(u0);\n  } else {\n   var ch = u0 - 65536;\n   str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n  }\n }\n return str;\n}\n\nfunction UTF8ToString(ptr, maxBytesToRead) {\n assert(typeof ptr == \"number\");\n return ptr ? UTF8ArrayToString(GROWABLE_HEAP_U8(), ptr, maxBytesToRead) : \"\";\n}\n\nvar SYSCALLS = {\n DEFAULT_POLLMASK: 5,\n calculateAt: function(dirfd, path, allowEmpty) {\n  if (PATH.isAbs(path)) {\n   return path;\n  }\n  var dir;\n  if (dirfd === -100) {\n   dir = FS.cwd();\n  } else {\n   var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n   dir = dirstream.path;\n  }\n  if (path.length == 0) {\n   if (!allowEmpty) {\n    throw new FS.ErrnoError(44);\n   }\n   return dir;\n  }\n  return PATH.join2(dir, path);\n },\n doStat: function(func, path, buf) {\n  try {\n   var stat = func(path);\n  } catch (e) {\n   if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n    return -54;\n   }\n   throw e;\n  }\n  GROWABLE_HEAP_I32()[buf >> 2] = stat.dev;\n  GROWABLE_HEAP_I32()[buf + 8 >> 2] = stat.ino;\n  GROWABLE_HEAP_I32()[buf + 12 >> 2] = stat.mode;\n  GROWABLE_HEAP_U32()[buf + 16 >> 2] = stat.nlink;\n  GROWABLE_HEAP_I32()[buf + 20 >> 2] = stat.uid;\n  GROWABLE_HEAP_I32()[buf + 24 >> 2] = stat.gid;\n  GROWABLE_HEAP_I32()[buf + 28 >> 2] = stat.rdev;\n  tempI64 = [ stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], \n  GROWABLE_HEAP_I32()[buf + 40 >> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 44 >> 2] = tempI64[1];\n  GROWABLE_HEAP_I32()[buf + 48 >> 2] = 4096;\n  GROWABLE_HEAP_I32()[buf + 52 >> 2] = stat.blocks;\n  var atime = stat.atime.getTime();\n  var mtime = stat.mtime.getTime();\n  var ctime = stat.ctime.getTime();\n  tempI64 = [ Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), \n  +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], \n  GROWABLE_HEAP_I32()[buf + 56 >> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 60 >> 2] = tempI64[1];\n  GROWABLE_HEAP_U32()[buf + 64 >> 2] = atime % 1e3 * 1e3;\n  tempI64 = [ Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), \n  +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], \n  GROWABLE_HEAP_I32()[buf + 72 >> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 76 >> 2] = tempI64[1];\n  GROWABLE_HEAP_U32()[buf + 80 >> 2] = mtime % 1e3 * 1e3;\n  tempI64 = [ Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), \n  +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], \n  GROWABLE_HEAP_I32()[buf + 88 >> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 92 >> 2] = tempI64[1];\n  GROWABLE_HEAP_U32()[buf + 96 >> 2] = ctime % 1e3 * 1e3;\n  tempI64 = [ stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], \n  GROWABLE_HEAP_I32()[buf + 104 >> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 108 >> 2] = tempI64[1];\n  return 0;\n },\n doMsync: function(addr, stream, len, flags, offset) {\n  if (!FS.isFile(stream.node.mode)) {\n   throw new FS.ErrnoError(43);\n  }\n  if (flags & 2) {\n   return 0;\n  }\n  var buffer = GROWABLE_HEAP_U8().slice(addr, addr + len);\n  FS.msync(stream, buffer, offset, len, flags);\n },\n varargs: undefined,\n get: function() {\n  assert(SYSCALLS.varargs != undefined);\n  SYSCALLS.varargs += 4;\n  var ret = GROWABLE_HEAP_I32()[SYSCALLS.varargs - 4 >> 2];\n  return ret;\n },\n getStr: function(ptr) {\n  var ret = UTF8ToString(ptr);\n  return ret;\n },\n getStreamFromFD: function(fd) {\n  var stream = FS.getStream(fd);\n  if (!stream) throw new FS.ErrnoError(8);\n  return stream;\n }\n};\n\nfunction _proc_exit(code) {\n if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(1, 1, code);\n EXITSTATUS = code;\n if (!keepRuntimeAlive()) {\n  PThread.terminateAllThreads();\n  if (Module[\"onExit\"]) Module[\"onExit\"](code);\n  ABORT = true;\n }\n quit_(code, new ExitStatus(code));\n}\n\nfunction exitJS(status, implicit) {\n EXITSTATUS = status;\n checkUnflushedContent();\n if (ENVIRONMENT_IS_PTHREAD) {\n  assert(!implicit);\n  exitOnMainThread(status);\n  throw \"unwind\";\n }\n if (keepRuntimeAlive() && !implicit) {\n  var msg = \"program exited (with status: \" + status + \"), but keepRuntimeAlive() is set (counter=\" + runtimeKeepaliveCounter + \") due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)\";\n  readyPromiseReject(msg);\n  err(msg);\n }\n _proc_exit(status);\n}\n\nvar _exit = exitJS;\n\nfunction ptrToString(ptr) {\n assert(typeof ptr === \"number\");\n return \"0x\" + ptr.toString(16).padStart(8, \"0\");\n}\n\nfunction handleException(e) {\n if (e instanceof ExitStatus || e == \"unwind\") {\n  return EXITSTATUS;\n }\n checkStackCookie();\n if (e instanceof WebAssembly.RuntimeError) {\n  if (_emscripten_stack_get_current() <= 0) {\n   err(\"Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to \" + 65536 + \")\");\n  }\n }\n quit_(1, e);\n}\n\nvar PThread = {\n unusedWorkers: [],\n runningWorkers: [],\n tlsInitFunctions: [],\n pthreads: {},\n nextWorkerID: 1,\n debugInit: function() {\n  function pthreadLogPrefix() {\n   var t = 0;\n   if (runtimeInitialized && typeof _pthread_self != \"undefined\") {\n    t = _pthread_self();\n   }\n   return \"w:\" + (Module[\"workerID\"] || 0) + \",t:\" + ptrToString(t) + \": \";\n  }\n  var origDbg = dbg;\n  dbg = message => origDbg(pthreadLogPrefix() + message);\n },\n init: function() {\n  PThread.debugInit();\n  if (ENVIRONMENT_IS_PTHREAD) {\n   PThread.initWorker();\n  } else {\n   PThread.initMainThread();\n  }\n },\n initMainThread: function() {\n  var pthreadPoolSize = navigator.hardwareConcurrency;\n  while (pthreadPoolSize--) {\n   PThread.allocateUnusedWorker();\n  }\n },\n initWorker: function() {\n  noExitRuntime = false;\n },\n setExitStatus: function(status) {\n  EXITSTATUS = status;\n },\n terminateAllThreads__deps: [ \"$terminateWorker\" ],\n terminateAllThreads: function() {\n  assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! terminateAllThreads() can only ever be called from main application thread!\");\n  for (var worker of PThread.runningWorkers) {\n   terminateWorker(worker);\n  }\n  for (var worker of PThread.unusedWorkers) {\n   terminateWorker(worker);\n  }\n  PThread.unusedWorkers = [];\n  PThread.runningWorkers = [];\n  PThread.pthreads = [];\n },\n returnWorkerToPool: function(worker) {\n  var pthread_ptr = worker.pthread_ptr;\n  delete PThread.pthreads[pthread_ptr];\n  PThread.unusedWorkers.push(worker);\n  PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker), 1);\n  worker.pthread_ptr = 0;\n  __emscripten_thread_free_data(pthread_ptr);\n },\n receiveObjectTransfer: function(data) {},\n threadInitTLS: function() {\n  PThread.tlsInitFunctions.forEach(f => f());\n },\n loadWasmModuleToWorker: worker => new Promise(onFinishedLoading => {\n  worker.onmessage = e => {\n   var d = e[\"data\"];\n   var cmd = d[\"cmd\"];\n   if (worker.pthread_ptr) PThread.currentProxiedOperationCallerThread = worker.pthread_ptr;\n   if (d[\"targetThread\"] && d[\"targetThread\"] != _pthread_self()) {\n    var targetWorker = PThread.pthreads[d.targetThread];\n    if (targetWorker) {\n     targetWorker.postMessage(d, d[\"transferList\"]);\n    } else {\n     err('Internal error! Worker sent a message \"' + cmd + '\" to target pthread ' + d[\"targetThread\"] + \", but that thread no longer exists!\");\n    }\n    PThread.currentProxiedOperationCallerThread = undefined;\n    return;\n   }\n   if (cmd === \"checkMailbox\") {\n    checkMailbox();\n   } else if (cmd === \"spawnThread\") {\n    spawnThread(d);\n   } else if (cmd === \"cleanupThread\") {\n    cleanupThread(d[\"thread\"]);\n   } else if (cmd === \"killThread\") {\n    killThread(d[\"thread\"]);\n   } else if (cmd === \"cancelThread\") {\n    cancelThread(d[\"thread\"]);\n   } else if (cmd === \"loaded\") {\n    worker.loaded = true;\n    onFinishedLoading(worker);\n   } else if (cmd === \"print\") {\n    out(\"Thread \" + d[\"threadId\"] + \": \" + d[\"text\"]);\n   } else if (cmd === \"printErr\") {\n    err(\"Thread \" + d[\"threadId\"] + \": \" + d[\"text\"]);\n   } else if (cmd === \"alert\") {\n    alert(\"Thread \" + d[\"threadId\"] + \": \" + d[\"text\"]);\n   } else if (d.target === \"setimmediate\") {\n    worker.postMessage(d);\n   } else if (cmd === \"callHandler\") {\n    Module[d[\"handler\"]](...d[\"args\"]);\n   } else if (cmd) {\n    err(\"worker sent an unknown command \" + cmd);\n   }\n   PThread.currentProxiedOperationCallerThread = undefined;\n  };\n  worker.onerror = e => {\n   var message = \"worker sent an error!\";\n   if (worker.pthread_ptr) {\n    message = \"Pthread \" + ptrToString(worker.pthread_ptr) + \" sent an error!\";\n   }\n   err(message + \" \" + e.filename + \":\" + e.lineno + \": \" + e.message);\n   throw e;\n  };\n  assert(wasmMemory instanceof WebAssembly.Memory, \"WebAssembly memory should have been loaded by now!\");\n  assert(wasmModule instanceof WebAssembly.Module, \"WebAssembly Module should have been loaded by now!\");\n  var handlers = [];\n  var knownHandlers = [ \"onExit\", \"onAbort\", \"print\", \"printErr\" ];\n  for (var handler of knownHandlers) {\n   if (Module.hasOwnProperty(handler)) {\n    handlers.push(handler);\n   }\n  }\n  worker.workerID = PThread.nextWorkerID++;\n  worker.postMessage({\n   \"cmd\": \"load\",\n   \"handlers\": handlers,\n   \"urlOrBlob\": Module[\"mainScriptUrlOrBlob\"],\n   \"wasmMemory\": wasmMemory,\n   \"wasmModule\": wasmModule,\n   \"workerID\": worker.workerID\n  });\n }),\n loadWasmModuleToAllWorkers: function(onMaybeReady) {\n  if (ENVIRONMENT_IS_PTHREAD) {\n   return onMaybeReady();\n  }\n  let pthreadPoolReady = Promise.all(PThread.unusedWorkers.map(PThread.loadWasmModuleToWorker));\n  pthreadPoolReady.then(onMaybeReady);\n },\n allocateUnusedWorker: function() {\n  var worker;\n  if (!Module[\"locateFile\"]) {\n   worker = new Worker(new URL(\"cas.worker.js\", import.meta.url));\n  } else {\n   var pthreadMainJs = locateFile(\"cas.worker.js\");\n   worker = new Worker(pthreadMainJs);\n  }\n  PThread.unusedWorkers.push(worker);\n },\n getNewWorker: function() {\n  if (PThread.unusedWorkers.length == 0) {\n   err(\"Tried to spawn a new thread, but the thread pool is exhausted.\\n\" + \"This might result in a deadlock unless some threads eventually exit or the code explicitly breaks out to the event loop.\\n\" + \"If you want to increase the pool size, use setting `-sPTHREAD_POOL_SIZE=...`.\" + \"\\nIf you want to throw an explicit error instead of the risk of deadlocking in those cases, use setting `-sPTHREAD_POOL_SIZE_STRICT=2`.\");\n   PThread.allocateUnusedWorker();\n   PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0]);\n  }\n  return PThread.unusedWorkers.pop();\n }\n};\n\nModule[\"PThread\"] = PThread;\n\nfunction callRuntimeCallbacks(callbacks) {\n while (callbacks.length > 0) {\n  callbacks.shift()(Module);\n }\n}\n\nfunction getCppExceptionTag() {\n return Module[\"asm\"][\"__cpp_exception\"];\n}\n\nfunction getCppExceptionThrownObjectFromWebAssemblyException(ex) {\n var unwind_header = ex.getArg(getCppExceptionTag(), 0);\n return ___thrown_object_from_unwind_exception(unwind_header);\n}\n\nfunction decrementExceptionRefcount(ex) {\n var ptr = getCppExceptionThrownObjectFromWebAssemblyException(ex);\n ___cxa_decrement_exception_refcount(ptr);\n}\n\nfunction establishStackSpace() {\n var pthread_ptr = _pthread_self();\n var stackTop = GROWABLE_HEAP_I32()[pthread_ptr + 52 >> 2];\n var stackSize = GROWABLE_HEAP_I32()[pthread_ptr + 56 >> 2];\n var stackMax = stackTop - stackSize;\n assert(stackTop != 0);\n assert(stackMax != 0);\n assert(stackTop > stackMax, \"stackTop must be higher then stackMax\");\n _emscripten_stack_set_limits(stackTop, stackMax);\n stackRestore(stackTop);\n writeStackCookie();\n}\n\nModule[\"establishStackSpace\"] = establishStackSpace;\n\nfunction exitOnMainThread(returnCode) {\n if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(2, 0, returnCode);\n _exit(returnCode);\n}\n\nfunction withStackSave(f) {\n var stack = stackSave();\n var ret = f();\n stackRestore(stack);\n return ret;\n}\n\nfunction getExceptionMessageCommon(ptr) {\n return withStackSave(function() {\n  var type_addr_addr = stackAlloc(4);\n  var message_addr_addr = stackAlloc(4);\n  ___get_exception_message(ptr, type_addr_addr, message_addr_addr);\n  var type_addr = GROWABLE_HEAP_U32()[type_addr_addr >> 2];\n  var message_addr = GROWABLE_HEAP_U32()[message_addr_addr >> 2];\n  var type = UTF8ToString(type_addr);\n  _free(type_addr);\n  var message;\n  if (message_addr) {\n   message = UTF8ToString(message_addr);\n   _free(message_addr);\n  }\n  return [ type, message ];\n });\n}\n\nfunction getExceptionMessage(ex) {\n var ptr = getCppExceptionThrownObjectFromWebAssemblyException(ex);\n return getExceptionMessageCommon(ptr);\n}\n\nModule[\"getExceptionMessage\"] = getExceptionMessage;\n\nfunction getValue(ptr, type = \"i8\") {\n if (type.endsWith(\"*\")) type = \"*\";\n switch (type) {\n case \"i1\":\n  return GROWABLE_HEAP_I8()[ptr >> 0];\n\n case \"i8\":\n  return GROWABLE_HEAP_I8()[ptr >> 0];\n\n case \"i16\":\n  return GROWABLE_HEAP_I16()[ptr >> 1];\n\n case \"i32\":\n  return GROWABLE_HEAP_I32()[ptr >> 2];\n\n case \"i64\":\n  return GROWABLE_HEAP_I32()[ptr >> 2];\n\n case \"float\":\n  return GROWABLE_HEAP_F32()[ptr >> 2];\n\n case \"double\":\n  return GROWABLE_HEAP_F64()[ptr >> 3];\n\n case \"*\":\n  return GROWABLE_HEAP_U32()[ptr >> 2];\n\n default:\n  abort(\"invalid type for getValue: \" + type);\n }\n}\n\nfunction incrementExceptionRefcount(ex) {\n var ptr = getCppExceptionThrownObjectFromWebAssemblyException(ex);\n ___cxa_increment_exception_refcount(ptr);\n}\n\nvar wasmTableMirror = [];\n\nfunction getWasmTableEntry(funcPtr) {\n var func = wasmTableMirror[funcPtr];\n if (!func) {\n  if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n  wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n }\n assert(wasmTable.get(funcPtr) == func, \"JavaScript-side Wasm function table mirror is out of date!\");\n return func;\n}\n\nfunction invokeEntryPoint(ptr, arg) {\n var result = getWasmTableEntry(ptr)(arg);\n checkStackCookie();\n if (keepRuntimeAlive()) {\n  PThread.setExitStatus(result);\n } else {\n  __emscripten_thread_exit(result);\n }\n}\n\nModule[\"invokeEntryPoint\"] = invokeEntryPoint;\n\nfunction registerTLSInit(tlsInitFunc) {\n PThread.tlsInitFunctions.push(tlsInitFunc);\n}\n\nfunction setValue(ptr, value, type = \"i8\") {\n if (type.endsWith(\"*\")) type = \"*\";\n switch (type) {\n case \"i1\":\n  GROWABLE_HEAP_I8()[ptr >> 0] = value;\n  break;\n\n case \"i8\":\n  GROWABLE_HEAP_I8()[ptr >> 0] = value;\n  break;\n\n case \"i16\":\n  GROWABLE_HEAP_I16()[ptr >> 1] = value;\n  break;\n\n case \"i32\":\n  GROWABLE_HEAP_I32()[ptr >> 2] = value;\n  break;\n\n case \"i64\":\n  tempI64 = [ value >>> 0, (tempDouble = value, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], \n  GROWABLE_HEAP_I32()[ptr >> 2] = tempI64[0], GROWABLE_HEAP_I32()[ptr + 4 >> 2] = tempI64[1];\n  break;\n\n case \"float\":\n  GROWABLE_HEAP_F32()[ptr >> 2] = value;\n  break;\n\n case \"double\":\n  GROWABLE_HEAP_F64()[ptr >> 3] = value;\n  break;\n\n case \"*\":\n  GROWABLE_HEAP_U32()[ptr >> 2] = value;\n  break;\n\n default:\n  abort(\"invalid type for setValue: \" + type);\n }\n}\n\nfunction warnOnce(text) {\n if (!warnOnce.shown) warnOnce.shown = {};\n if (!warnOnce.shown[text]) {\n  warnOnce.shown[text] = 1;\n  err(text);\n }\n}\n\nfunction ___assert_fail(condition, filename, line, func) {\n abort(\"Assertion failed: \" + UTF8ToString(condition) + \", at: \" + [ filename ? UTF8ToString(filename) : \"unknown filename\", line, func ? UTF8ToString(func) : \"unknown function\" ]);\n}\n\nfunction ___call_sighandler(fp, sig) {\n getWasmTableEntry(fp)(sig);\n}\n\nfunction ___emscripten_init_main_thread_js(tb) {\n __emscripten_thread_init(tb, !ENVIRONMENT_IS_WORKER, 1, !ENVIRONMENT_IS_WEB);\n PThread.threadInitTLS();\n}\n\nfunction ___emscripten_thread_cleanup(thread) {\n if (!ENVIRONMENT_IS_PTHREAD) cleanupThread(thread); else postMessage({\n  \"cmd\": \"cleanupThread\",\n  \"thread\": thread\n });\n}\n\nfunction pthreadCreateProxied(pthread_ptr, attr, startRoutine, arg) {\n if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(3, 1, pthread_ptr, attr, startRoutine, arg);\n return ___pthread_create_js(pthread_ptr, attr, startRoutine, arg);\n}\n\nfunction ___pthread_create_js(pthread_ptr, attr, startRoutine, arg) {\n if (typeof SharedArrayBuffer == \"undefined\") {\n  err(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\");\n  return 6;\n }\n var transferList = [];\n var error = 0;\n if (ENVIRONMENT_IS_PTHREAD && (transferList.length === 0 || error)) {\n  return pthreadCreateProxied(pthread_ptr, attr, startRoutine, arg);\n }\n if (error) return error;\n var threadParams = {\n  startRoutine: startRoutine,\n  pthread_ptr: pthread_ptr,\n  arg: arg,\n  transferList: transferList\n };\n if (ENVIRONMENT_IS_PTHREAD) {\n  threadParams.cmd = \"spawnThread\";\n  postMessage(threadParams, transferList);\n  return 0;\n }\n return spawnThread(threadParams);\n}\n\nfunction ___throw_exception_with_stack_trace(ex) {\n var e = new WebAssembly.Exception(getCppExceptionTag(), [ ex ], {\n  traceStack: true\n });\n e.message = getExceptionMessage(e);\n if (e.stack) {\n  var arr = e.stack.split(\"\\n\");\n  arr.splice(1, 1);\n  e.stack = arr.join(\"\\n\");\n }\n throw e;\n}\n\nfunction __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}\n\nfunction getShiftFromSize(size) {\n switch (size) {\n case 1:\n  return 0;\n\n case 2:\n  return 1;\n\n case 4:\n  return 2;\n\n case 8:\n  return 3;\n\n default:\n  throw new TypeError(\"Unknown type size: \" + size);\n }\n}\n\nfunction embind_init_charCodes() {\n var codes = new Array(256);\n for (var i = 0; i < 256; ++i) {\n  codes[i] = String.fromCharCode(i);\n }\n embind_charCodes = codes;\n}\n\nvar embind_charCodes = undefined;\n\nfunction readLatin1String(ptr) {\n var ret = \"\";\n var c = ptr;\n while (GROWABLE_HEAP_U8()[c]) {\n  ret += embind_charCodes[GROWABLE_HEAP_U8()[c++]];\n }\n return ret;\n}\n\nvar awaitingDependencies = {};\n\nvar registeredTypes = {};\n\nvar typeDependencies = {};\n\nvar char_0 = 48;\n\nvar char_9 = 57;\n\nfunction makeLegalFunctionName(name) {\n if (undefined === name) {\n  return \"_unknown\";\n }\n name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\n var f = name.charCodeAt(0);\n if (f >= char_0 && f <= char_9) {\n  return \"_\" + name;\n }\n return name;\n}\n\nfunction createNamedFunction(name, body) {\n name = makeLegalFunctionName(name);\n return {\n  [name]: function() {\n   return body.apply(this, arguments);\n  }\n }[name];\n}\n\nfunction extendError(baseErrorType, errorName) {\n var errorClass = createNamedFunction(errorName, function(message) {\n  this.name = errorName;\n  this.message = message;\n  var stack = new Error(message).stack;\n  if (stack !== undefined) {\n   this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n  }\n });\n errorClass.prototype = Object.create(baseErrorType.prototype);\n errorClass.prototype.constructor = errorClass;\n errorClass.prototype.toString = function() {\n  if (this.message === undefined) {\n   return this.name;\n  } else {\n   return this.name + \": \" + this.message;\n  }\n };\n return errorClass;\n}\n\nvar BindingError = undefined;\n\nfunction throwBindingError(message) {\n throw new BindingError(message);\n}\n\nvar InternalError = undefined;\n\nfunction throwInternalError(message) {\n throw new InternalError(message);\n}\n\nfunction whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\n myTypes.forEach(function(type) {\n  typeDependencies[type] = dependentTypes;\n });\n function onComplete(typeConverters) {\n  var myTypeConverters = getTypeConverters(typeConverters);\n  if (myTypeConverters.length !== myTypes.length) {\n   throwInternalError(\"Mismatched type converter count\");\n  }\n  for (var i = 0; i < myTypes.length; ++i) {\n   registerType(myTypes[i], myTypeConverters[i]);\n  }\n }\n var typeConverters = new Array(dependentTypes.length);\n var unregisteredTypes = [];\n var registered = 0;\n dependentTypes.forEach((dt, i) => {\n  if (registeredTypes.hasOwnProperty(dt)) {\n   typeConverters[i] = registeredTypes[dt];\n  } else {\n   unregisteredTypes.push(dt);\n   if (!awaitingDependencies.hasOwnProperty(dt)) {\n    awaitingDependencies[dt] = [];\n   }\n   awaitingDependencies[dt].push(() => {\n    typeConverters[i] = registeredTypes[dt];\n    ++registered;\n    if (registered === unregisteredTypes.length) {\n     onComplete(typeConverters);\n    }\n   });\n  }\n });\n if (0 === unregisteredTypes.length) {\n  onComplete(typeConverters);\n }\n}\n\nfunction registerType(rawType, registeredInstance, options = {}) {\n if (!(\"argPackAdvance\" in registeredInstance)) {\n  throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n }\n var name = registeredInstance.name;\n if (!rawType) {\n  throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer');\n }\n if (registeredTypes.hasOwnProperty(rawType)) {\n  if (options.ignoreDuplicateRegistrations) {\n   return;\n  } else {\n   throwBindingError(\"Cannot register type '\" + name + \"' twice\");\n  }\n }\n registeredTypes[rawType] = registeredInstance;\n delete typeDependencies[rawType];\n if (awaitingDependencies.hasOwnProperty(rawType)) {\n  var callbacks = awaitingDependencies[rawType];\n  delete awaitingDependencies[rawType];\n  callbacks.forEach(cb => cb());\n }\n}\n\nfunction __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n var shift = getShiftFromSize(size);\n name = readLatin1String(name);\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(wt) {\n   return !!wt;\n  },\n  \"toWireType\": function(destructors, o) {\n   return o ? trueValue : falseValue;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": function(pointer) {\n   var heap;\n   if (size === 1) {\n    heap = GROWABLE_HEAP_I8();\n   } else if (size === 2) {\n    heap = GROWABLE_HEAP_I16();\n   } else if (size === 4) {\n    heap = GROWABLE_HEAP_I32();\n   } else {\n    throw new TypeError(\"Unknown boolean type size: \" + name);\n   }\n   return this[\"fromWireType\"](heap[pointer >> shift]);\n  },\n  destructorFunction: null\n });\n}\n\nfunction ClassHandle_isAliasOf(other) {\n if (!(this instanceof ClassHandle)) {\n  return false;\n }\n if (!(other instanceof ClassHandle)) {\n  return false;\n }\n var leftClass = this.$$.ptrType.registeredClass;\n var left = this.$$.ptr;\n var rightClass = other.$$.ptrType.registeredClass;\n var right = other.$$.ptr;\n while (leftClass.baseClass) {\n  left = leftClass.upcast(left);\n  leftClass = leftClass.baseClass;\n }\n while (rightClass.baseClass) {\n  right = rightClass.upcast(right);\n  rightClass = rightClass.baseClass;\n }\n return leftClass === rightClass && left === right;\n}\n\nfunction shallowCopyInternalPointer(o) {\n return {\n  count: o.count,\n  deleteScheduled: o.deleteScheduled,\n  preservePointerOnDelete: o.preservePointerOnDelete,\n  ptr: o.ptr,\n  ptrType: o.ptrType,\n  smartPtr: o.smartPtr,\n  smartPtrType: o.smartPtrType\n };\n}\n\nfunction throwInstanceAlreadyDeleted(obj) {\n function getInstanceTypeName(handle) {\n  return handle.$$.ptrType.registeredClass.name;\n }\n throwBindingError(getInstanceTypeName(obj) + \" instance already deleted\");\n}\n\nvar finalizationRegistry = false;\n\nfunction detachFinalizer(handle) {}\n\nfunction runDestructor($$) {\n if ($$.smartPtr) {\n  $$.smartPtrType.rawDestructor($$.smartPtr);\n } else {\n  $$.ptrType.registeredClass.rawDestructor($$.ptr);\n }\n}\n\nfunction releaseClassHandle($$) {\n $$.count.value -= 1;\n var toDelete = 0 === $$.count.value;\n if (toDelete) {\n  runDestructor($$);\n }\n}\n\nfunction downcastPointer(ptr, ptrClass, desiredClass) {\n if (ptrClass === desiredClass) {\n  return ptr;\n }\n if (undefined === desiredClass.baseClass) {\n  return null;\n }\n var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n if (rv === null) {\n  return null;\n }\n return desiredClass.downcast(rv);\n}\n\nvar registeredPointers = {};\n\nfunction getInheritedInstanceCount() {\n return Object.keys(registeredInstances).length;\n}\n\nfunction getLiveInheritedInstances() {\n var rv = [];\n for (var k in registeredInstances) {\n  if (registeredInstances.hasOwnProperty(k)) {\n   rv.push(registeredInstances[k]);\n  }\n }\n return rv;\n}\n\nvar deletionQueue = [];\n\nfunction flushPendingDeletes() {\n while (deletionQueue.length) {\n  var obj = deletionQueue.pop();\n  obj.$$.deleteScheduled = false;\n  obj[\"delete\"]();\n }\n}\n\nvar delayFunction = undefined;\n\nfunction setDelayFunction(fn) {\n delayFunction = fn;\n if (deletionQueue.length && delayFunction) {\n  delayFunction(flushPendingDeletes);\n }\n}\n\nfunction init_embind() {\n Module[\"getInheritedInstanceCount\"] = getInheritedInstanceCount;\n Module[\"getLiveInheritedInstances\"] = getLiveInheritedInstances;\n Module[\"flushPendingDeletes\"] = flushPendingDeletes;\n Module[\"setDelayFunction\"] = setDelayFunction;\n}\n\nvar registeredInstances = {};\n\nfunction getBasestPointer(class_, ptr) {\n if (ptr === undefined) {\n  throwBindingError(\"ptr should not be undefined\");\n }\n while (class_.baseClass) {\n  ptr = class_.upcast(ptr);\n  class_ = class_.baseClass;\n }\n return ptr;\n}\n\nfunction getInheritedInstance(class_, ptr) {\n ptr = getBasestPointer(class_, ptr);\n return registeredInstances[ptr];\n}\n\nfunction makeClassHandle(prototype, record) {\n if (!record.ptrType || !record.ptr) {\n  throwInternalError(\"makeClassHandle requires ptr and ptrType\");\n }\n var hasSmartPtrType = !!record.smartPtrType;\n var hasSmartPtr = !!record.smartPtr;\n if (hasSmartPtrType !== hasSmartPtr) {\n  throwInternalError(\"Both smartPtrType and smartPtr must be specified\");\n }\n record.count = {\n  value: 1\n };\n return attachFinalizer(Object.create(prototype, {\n  $$: {\n   value: record\n  }\n }));\n}\n\nfunction RegisteredPointer_fromWireType(ptr) {\n var rawPointer = this.getPointee(ptr);\n if (!rawPointer) {\n  this.destructor(ptr);\n  return null;\n }\n var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n if (undefined !== registeredInstance) {\n  if (0 === registeredInstance.$$.count.value) {\n   registeredInstance.$$.ptr = rawPointer;\n   registeredInstance.$$.smartPtr = ptr;\n   return registeredInstance[\"clone\"]();\n  } else {\n   var rv = registeredInstance[\"clone\"]();\n   this.destructor(ptr);\n   return rv;\n  }\n }\n function makeDefaultHandle() {\n  if (this.isSmartPointer) {\n   return makeClassHandle(this.registeredClass.instancePrototype, {\n    ptrType: this.pointeeType,\n    ptr: rawPointer,\n    smartPtrType: this,\n    smartPtr: ptr\n   });\n  } else {\n   return makeClassHandle(this.registeredClass.instancePrototype, {\n    ptrType: this,\n    ptr: ptr\n   });\n  }\n }\n var actualType = this.registeredClass.getActualType(rawPointer);\n var registeredPointerRecord = registeredPointers[actualType];\n if (!registeredPointerRecord) {\n  return makeDefaultHandle.call(this);\n }\n var toType;\n if (this.isConst) {\n  toType = registeredPointerRecord.constPointerType;\n } else {\n  toType = registeredPointerRecord.pointerType;\n }\n var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n if (dp === null) {\n  return makeDefaultHandle.call(this);\n }\n if (this.isSmartPointer) {\n  return makeClassHandle(toType.registeredClass.instancePrototype, {\n   ptrType: toType,\n   ptr: dp,\n   smartPtrType: this,\n   smartPtr: ptr\n  });\n } else {\n  return makeClassHandle(toType.registeredClass.instancePrototype, {\n   ptrType: toType,\n   ptr: dp\n  });\n }\n}\n\nfunction attachFinalizer(handle) {\n if (\"undefined\" === typeof FinalizationRegistry) {\n  attachFinalizer = handle => handle;\n  return handle;\n }\n finalizationRegistry = new FinalizationRegistry(info => {\n  console.warn(info.leakWarning.stack.replace(/^Error: /, \"\"));\n  releaseClassHandle(info.$$);\n });\n attachFinalizer = handle => {\n  var $$ = handle.$$;\n  var hasSmartPtr = !!$$.smartPtr;\n  if (hasSmartPtr) {\n   var info = {\n    $$: $$\n   };\n   var cls = $$.ptrType.registeredClass;\n   info.leakWarning = new Error(\"Embind found a leaked C++ instance \" + cls.name + \" <\" + ptrToString($$.ptr) + \">.\\n\" + \"We'll free it automatically in this case, but this functionality is not reliable across various environments.\\n\" + \"Make sure to invoke .delete() manually once you're done with the instance instead.\\n\" + \"Originally allocated\");\n   if (\"captureStackTrace\" in Error) {\n    Error.captureStackTrace(info.leakWarning, RegisteredPointer_fromWireType);\n   }\n   finalizationRegistry.register(handle, info, handle);\n  }\n  return handle;\n };\n detachFinalizer = handle => finalizationRegistry.unregister(handle);\n return attachFinalizer(handle);\n}\n\nfunction ClassHandle_clone() {\n if (!this.$$.ptr) {\n  throwInstanceAlreadyDeleted(this);\n }\n if (this.$$.preservePointerOnDelete) {\n  this.$$.count.value += 1;\n  return this;\n } else {\n  var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n   $$: {\n    value: shallowCopyInternalPointer(this.$$)\n   }\n  }));\n  clone.$$.count.value += 1;\n  clone.$$.deleteScheduled = false;\n  return clone;\n }\n}\n\nfunction ClassHandle_delete() {\n if (!this.$$.ptr) {\n  throwInstanceAlreadyDeleted(this);\n }\n if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n  throwBindingError(\"Object already scheduled for deletion\");\n }\n detachFinalizer(this);\n releaseClassHandle(this.$$);\n if (!this.$$.preservePointerOnDelete) {\n  this.$$.smartPtr = undefined;\n  this.$$.ptr = undefined;\n }\n}\n\nfunction ClassHandle_isDeleted() {\n return !this.$$.ptr;\n}\n\nfunction ClassHandle_deleteLater() {\n if (!this.$$.ptr) {\n  throwInstanceAlreadyDeleted(this);\n }\n if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n  throwBindingError(\"Object already scheduled for deletion\");\n }\n deletionQueue.push(this);\n if (deletionQueue.length === 1 && delayFunction) {\n  delayFunction(flushPendingDeletes);\n }\n this.$$.deleteScheduled = true;\n return this;\n}\n\nfunction init_ClassHandle() {\n ClassHandle.prototype[\"isAliasOf\"] = ClassHandle_isAliasOf;\n ClassHandle.prototype[\"clone\"] = ClassHandle_clone;\n ClassHandle.prototype[\"delete\"] = ClassHandle_delete;\n ClassHandle.prototype[\"isDeleted\"] = ClassHandle_isDeleted;\n ClassHandle.prototype[\"deleteLater\"] = ClassHandle_deleteLater;\n}\n\nfunction ClassHandle() {}\n\nfunction ensureOverloadTable(proto, methodName, humanName) {\n if (undefined === proto[methodName].overloadTable) {\n  var prevFunc = proto[methodName];\n  proto[methodName] = function() {\n   if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n    throwBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\");\n   }\n   return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n  };\n  proto[methodName].overloadTable = [];\n  proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n }\n}\n\nfunction exposePublicSymbol(name, value, numArguments) {\n if (Module.hasOwnProperty(name)) {\n  if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {\n   throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\n  }\n  ensureOverloadTable(Module, name, name);\n  if (Module.hasOwnProperty(numArguments)) {\n   throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\");\n  }\n  Module[name].overloadTable[numArguments] = value;\n } else {\n  Module[name] = value;\n  if (undefined !== numArguments) {\n   Module[name].numArguments = numArguments;\n  }\n }\n}\n\nfunction RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\n this.name = name;\n this.constructor = constructor;\n this.instancePrototype = instancePrototype;\n this.rawDestructor = rawDestructor;\n this.baseClass = baseClass;\n this.getActualType = getActualType;\n this.upcast = upcast;\n this.downcast = downcast;\n this.pureVirtualFunctions = [];\n}\n\nfunction upcastPointer(ptr, ptrClass, desiredClass) {\n while (ptrClass !== desiredClass) {\n  if (!ptrClass.upcast) {\n   throwBindingError(\"Expected null or instance of \" + desiredClass.name + \", got an instance of \" + ptrClass.name);\n  }\n  ptr = ptrClass.upcast(ptr);\n  ptrClass = ptrClass.baseClass;\n }\n return ptr;\n}\n\nfunction constNoSmartPtrRawPointerToWireType(destructors, handle) {\n if (handle === null) {\n  if (this.isReference) {\n   throwBindingError(\"null is not a valid \" + this.name);\n  }\n  return 0;\n }\n if (!handle.$$) {\n  throwBindingError('Cannot pass \"' + embindRepr(handle) + '\" as a ' + this.name);\n }\n if (!handle.$$.ptr) {\n  throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n }\n var handleClass = handle.$$.ptrType.registeredClass;\n var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n return ptr;\n}\n\nfunction genericPointerToWireType(destructors, handle) {\n var ptr;\n if (handle === null) {\n  if (this.isReference) {\n   throwBindingError(\"null is not a valid \" + this.name);\n  }\n  if (this.isSmartPointer) {\n   ptr = this.rawConstructor();\n   if (destructors !== null) {\n    destructors.push(this.rawDestructor, ptr);\n   }\n   return ptr;\n  } else {\n   return 0;\n  }\n }\n if (!handle.$$) {\n  throwBindingError('Cannot pass \"' + embindRepr(handle) + '\" as a ' + this.name);\n }\n if (!handle.$$.ptr) {\n  throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n }\n if (!this.isConst && handle.$$.ptrType.isConst) {\n  throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n }\n var handleClass = handle.$$.ptrType.registeredClass;\n ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n if (this.isSmartPointer) {\n  if (undefined === handle.$$.smartPtr) {\n   throwBindingError(\"Passing raw pointer to smart pointer is illegal\");\n  }\n  switch (this.sharingPolicy) {\n  case 0:\n   if (handle.$$.smartPtrType === this) {\n    ptr = handle.$$.smartPtr;\n   } else {\n    throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n   }\n   break;\n\n  case 1:\n   ptr = handle.$$.smartPtr;\n   break;\n\n  case 2:\n   if (handle.$$.smartPtrType === this) {\n    ptr = handle.$$.smartPtr;\n   } else {\n    var clonedHandle = handle[\"clone\"]();\n    ptr = this.rawShare(ptr, Emval.toHandle(function() {\n     clonedHandle[\"delete\"]();\n    }));\n    if (destructors !== null) {\n     destructors.push(this.rawDestructor, ptr);\n    }\n   }\n   break;\n\n  default:\n   throwBindingError(\"Unsupporting sharing policy\");\n  }\n }\n return ptr;\n}\n\nfunction nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n if (handle === null) {\n  if (this.isReference) {\n   throwBindingError(\"null is not a valid \" + this.name);\n  }\n  return 0;\n }\n if (!handle.$$) {\n  throwBindingError('Cannot pass \"' + embindRepr(handle) + '\" as a ' + this.name);\n }\n if (!handle.$$.ptr) {\n  throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n }\n if (handle.$$.ptrType.isConst) {\n  throwBindingError(\"Cannot convert argument of type \" + handle.$$.ptrType.name + \" to parameter type \" + this.name);\n }\n var handleClass = handle.$$.ptrType.registeredClass;\n var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n return ptr;\n}\n\nfunction simpleReadValueFromPointer(pointer) {\n return this[\"fromWireType\"](GROWABLE_HEAP_I32()[pointer >> 2]);\n}\n\nfunction RegisteredPointer_getPointee(ptr) {\n if (this.rawGetPointee) {\n  ptr = this.rawGetPointee(ptr);\n }\n return ptr;\n}\n\nfunction RegisteredPointer_destructor(ptr) {\n if (this.rawDestructor) {\n  this.rawDestructor(ptr);\n }\n}\n\nfunction RegisteredPointer_deleteObject(handle) {\n if (handle !== null) {\n  handle[\"delete\"]();\n }\n}\n\nfunction init_RegisteredPointer() {\n RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\n RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\n RegisteredPointer.prototype[\"argPackAdvance\"] = 8;\n RegisteredPointer.prototype[\"readValueFromPointer\"] = simpleReadValueFromPointer;\n RegisteredPointer.prototype[\"deleteObject\"] = RegisteredPointer_deleteObject;\n RegisteredPointer.prototype[\"fromWireType\"] = RegisteredPointer_fromWireType;\n}\n\nfunction RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\n this.name = name;\n this.registeredClass = registeredClass;\n this.isReference = isReference;\n this.isConst = isConst;\n this.isSmartPointer = isSmartPointer;\n this.pointeeType = pointeeType;\n this.sharingPolicy = sharingPolicy;\n this.rawGetPointee = rawGetPointee;\n this.rawConstructor = rawConstructor;\n this.rawShare = rawShare;\n this.rawDestructor = rawDestructor;\n if (!isSmartPointer && registeredClass.baseClass === undefined) {\n  if (isConst) {\n   this[\"toWireType\"] = constNoSmartPtrRawPointerToWireType;\n   this.destructorFunction = null;\n  } else {\n   this[\"toWireType\"] = nonConstNoSmartPtrRawPointerToWireType;\n   this.destructorFunction = null;\n  }\n } else {\n  this[\"toWireType\"] = genericPointerToWireType;\n }\n}\n\nfunction replacePublicSymbol(name, value, numArguments) {\n if (!Module.hasOwnProperty(name)) {\n  throwInternalError(\"Replacing nonexistant public symbol\");\n }\n if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n  Module[name].overloadTable[numArguments] = value;\n } else {\n  Module[name] = value;\n  Module[name].argCount = numArguments;\n }\n}\n\nfunction dynCallLegacy(sig, ptr, args) {\n assert(\"dynCall_\" + sig in Module, \"bad function pointer type - dynCall function not found for sig '\" + sig + \"'\");\n if (args && args.length) {\n  assert(args.length === sig.substring(1).replace(/j/g, \"--\").length);\n } else {\n  assert(sig.length == 1);\n }\n var f = Module[\"dynCall_\" + sig];\n return args && args.length ? f.apply(null, [ ptr ].concat(args)) : f.call(null, ptr);\n}\n\nfunction dynCall(sig, ptr, args) {\n if (sig.includes(\"j\")) {\n  return dynCallLegacy(sig, ptr, args);\n }\n assert(getWasmTableEntry(ptr), \"missing table entry in dynCall: \" + ptr);\n var rtn = getWasmTableEntry(ptr).apply(null, args);\n return rtn;\n}\n\nfunction getDynCaller(sig, ptr) {\n assert(sig.includes(\"j\") || sig.includes(\"p\"), \"getDynCaller should only be called with i64 sigs\");\n var argCache = [];\n return function() {\n  argCache.length = 0;\n  Object.assign(argCache, arguments);\n  return dynCall(sig, ptr, argCache);\n };\n}\n\nfunction embind__requireFunction(signature, rawFunction) {\n signature = readLatin1String(signature);\n function makeDynCaller() {\n  if (signature.includes(\"j\")) {\n   return getDynCaller(signature, rawFunction);\n  }\n  return getWasmTableEntry(rawFunction);\n }\n var fp = makeDynCaller();\n if (typeof fp != \"function\") {\n  throwBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction);\n }\n return fp;\n}\n\nvar UnboundTypeError = undefined;\n\nfunction getTypeName(type) {\n var ptr = ___getTypeName(type);\n var rv = readLatin1String(ptr);\n _free(ptr);\n return rv;\n}\n\nfunction throwUnboundTypeError(message, types) {\n var unboundTypes = [];\n var seen = {};\n function visit(type) {\n  if (seen[type]) {\n   return;\n  }\n  if (registeredTypes[type]) {\n   return;\n  }\n  if (typeDependencies[type]) {\n   typeDependencies[type].forEach(visit);\n   return;\n  }\n  unboundTypes.push(type);\n  seen[type] = true;\n }\n types.forEach(visit);\n throw new UnboundTypeError(message + \": \" + unboundTypes.map(getTypeName).join([ \", \" ]));\n}\n\nfunction __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {\n name = readLatin1String(name);\n getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n if (upcast) {\n  upcast = embind__requireFunction(upcastSignature, upcast);\n }\n if (downcast) {\n  downcast = embind__requireFunction(downcastSignature, downcast);\n }\n rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n var legalFunctionName = makeLegalFunctionName(name);\n exposePublicSymbol(legalFunctionName, function() {\n  throwUnboundTypeError(\"Cannot construct \" + name + \" due to unbound types\", [ baseClassRawType ]);\n });\n whenDependentTypesAreResolved([ rawType, rawPointerType, rawConstPointerType ], baseClassRawType ? [ baseClassRawType ] : [], function(base) {\n  base = base[0];\n  var baseClass;\n  var basePrototype;\n  if (baseClassRawType) {\n   baseClass = base.registeredClass;\n   basePrototype = baseClass.instancePrototype;\n  } else {\n   basePrototype = ClassHandle.prototype;\n  }\n  var constructor = createNamedFunction(legalFunctionName, function() {\n   if (Object.getPrototypeOf(this) !== instancePrototype) {\n    throw new BindingError(\"Use 'new' to construct \" + name);\n   }\n   if (undefined === registeredClass.constructor_body) {\n    throw new BindingError(name + \" has no accessible constructor\");\n   }\n   var body = registeredClass.constructor_body[arguments.length];\n   if (undefined === body) {\n    throw new BindingError(\"Tried to invoke ctor of \" + name + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(registeredClass.constructor_body).toString() + \") parameters instead!\");\n   }\n   return body.apply(this, arguments);\n  });\n  var instancePrototype = Object.create(basePrototype, {\n   constructor: {\n    value: constructor\n   }\n  });\n  constructor.prototype = instancePrototype;\n  var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\n  var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n  var pointerConverter = new RegisteredPointer(name + \"*\", registeredClass, false, false, false);\n  var constPointerConverter = new RegisteredPointer(name + \" const*\", registeredClass, false, true, false);\n  registeredPointers[rawType] = {\n   pointerType: pointerConverter,\n   constPointerType: constPointerConverter\n  };\n  replacePublicSymbol(legalFunctionName, constructor);\n  return [ referenceConverter, pointerConverter, constPointerConverter ];\n });\n}\n\nfunction heap32VectorToArray(count, firstElement) {\n var array = [];\n for (var i = 0; i < count; i++) {\n  array.push(GROWABLE_HEAP_U32()[firstElement + i * 4 >> 2]);\n }\n return array;\n}\n\nfunction runDestructors(destructors) {\n while (destructors.length) {\n  var ptr = destructors.pop();\n  var del = destructors.pop();\n  del(ptr);\n }\n}\n\nfunction newFunc(constructor, argumentList) {\n if (!(constructor instanceof Function)) {\n  throw new TypeError(\"new_ called with constructor type \" + typeof constructor + \" which is not a function\");\n }\n var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function() {});\n dummy.prototype = constructor.prototype;\n var obj = new dummy();\n var r = constructor.apply(obj, argumentList);\n return r instanceof Object ? r : obj;\n}\n\nfunction craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {\n var argCount = argTypes.length;\n if (argCount < 2) {\n  throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n }\n assert(!isAsync, \"Async bindings are only supported with JSPI.\");\n var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n var needsDestructorStack = false;\n for (var i = 1; i < argTypes.length; ++i) {\n  if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n   needsDestructorStack = true;\n   break;\n  }\n }\n var returns = argTypes[0].name !== \"void\";\n var argsList = \"\";\n var argsListWired = \"\";\n for (var i = 0; i < argCount - 2; ++i) {\n  argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n  argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\n }\n var invokerFnBody = \"return function \" + makeLegalFunctionName(humanName) + \"(\" + argsList + \") {\\n\" + \"if (arguments.length !== \" + (argCount - 2) + \") {\\n\" + \"throwBindingError('function \" + humanName + \" called with ' + arguments.length + ' arguments, expected \" + (argCount - 2) + \" args!');\\n\" + \"}\\n\";\n if (needsDestructorStack) {\n  invokerFnBody += \"var destructors = [];\\n\";\n }\n var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n var args1 = [ \"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\" ];\n var args2 = [ throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1] ];\n if (isClassMethodFunc) {\n  invokerFnBody += \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\";\n }\n for (var i = 0; i < argCount - 2; ++i) {\n  invokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \".toWireType(\" + dtorStack + \", arg\" + i + \"); // \" + argTypes[i + 2].name + \"\\n\";\n  args1.push(\"argType\" + i);\n  args2.push(argTypes[i + 2]);\n }\n if (isClassMethodFunc) {\n  argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n }\n invokerFnBody += (returns || isAsync ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\n if (needsDestructorStack) {\n  invokerFnBody += \"runDestructors(destructors);\\n\";\n } else {\n  for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\n   var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n   if (argTypes[i].destructorFunction !== null) {\n    invokerFnBody += paramName + \"_dtor(\" + paramName + \"); // \" + argTypes[i].name + \"\\n\";\n    args1.push(paramName + \"_dtor\");\n    args2.push(argTypes[i].destructorFunction);\n   }\n  }\n }\n if (returns) {\n  invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" + \"return ret;\\n\";\n } else {}\n invokerFnBody += \"}\\n\";\n args1.push(invokerFnBody);\n return newFunc(Function, args1).apply(null, args2);\n}\n\nfunction __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {\n assert(argCount > 0);\n var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n invoker = embind__requireFunction(invokerSignature, invoker);\n var args = [ rawConstructor ];\n var destructors = [];\n whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {\n  classType = classType[0];\n  var humanName = \"constructor \" + classType.name;\n  if (undefined === classType.registeredClass.constructor_body) {\n   classType.registeredClass.constructor_body = [];\n  }\n  if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n   throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\" + (argCount - 1) + \") for class '\" + classType.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\n  }\n  classType.registeredClass.constructor_body[argCount - 1] = () => {\n   throwUnboundTypeError(\"Cannot construct \" + classType.name + \" due to unbound types\", rawArgTypes);\n  };\n  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n   argTypes.splice(1, 0, null);\n   classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\n   return [];\n  });\n  return [];\n });\n}\n\nfunction __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync) {\n var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n methodName = readLatin1String(methodName);\n rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {\n  classType = classType[0];\n  var humanName = classType.name + \".\" + methodName;\n  if (methodName.startsWith(\"@@\")) {\n   methodName = Symbol[methodName.substring(2)];\n  }\n  if (isPureVirtual) {\n   classType.registeredClass.pureVirtualFunctions.push(methodName);\n  }\n  function unboundTypesHandler() {\n   throwUnboundTypeError(\"Cannot call \" + humanName + \" due to unbound types\", rawArgTypes);\n  }\n  var proto = classType.registeredClass.instancePrototype;\n  var method = proto[methodName];\n  if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {\n   unboundTypesHandler.argCount = argCount - 2;\n   unboundTypesHandler.className = classType.name;\n   proto[methodName] = unboundTypesHandler;\n  } else {\n   ensureOverloadTable(proto, methodName, humanName);\n   proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n  }\n  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n   var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);\n   if (undefined === proto[methodName].overloadTable) {\n    memberFunction.argCount = argCount - 2;\n    proto[methodName] = memberFunction;\n   } else {\n    proto[methodName].overloadTable[argCount - 2] = memberFunction;\n   }\n   return [];\n  });\n  return [];\n });\n}\n\nfunction HandleAllocator() {\n this.allocated = [ undefined ];\n this.freelist = [];\n this.get = function(id) {\n  assert(this.allocated[id] !== undefined, \"invalid handle: \" + id);\n  return this.allocated[id];\n };\n this.allocate = function(handle) {\n  let id = this.freelist.pop() || this.allocated.length;\n  this.allocated[id] = handle;\n  return id;\n };\n this.free = function(id) {\n  assert(this.allocated[id] !== undefined);\n  this.allocated[id] = undefined;\n  this.freelist.push(id);\n };\n}\n\nvar emval_handles = new HandleAllocator();\n\nfunction __emval_decref(handle) {\n if (handle >= emval_handles.reserved && 0 === --emval_handles.get(handle).refcount) {\n  emval_handles.free(handle);\n }\n}\n\nfunction count_emval_handles() {\n var count = 0;\n for (var i = emval_handles.reserved; i < emval_handles.allocated.length; ++i) {\n  if (emval_handles.allocated[i] !== undefined) {\n   ++count;\n  }\n }\n return count;\n}\n\nfunction init_emval() {\n emval_handles.allocated.push({\n  value: undefined\n }, {\n  value: null\n }, {\n  value: true\n }, {\n  value: false\n });\n emval_handles.reserved = emval_handles.allocated.length;\n Module[\"count_emval_handles\"] = count_emval_handles;\n}\n\nvar Emval = {\n toValue: handle => {\n  if (!handle) {\n   throwBindingError(\"Cannot use deleted val. handle = \" + handle);\n  }\n  return emval_handles.get(handle).value;\n },\n toHandle: value => {\n  switch (value) {\n  case undefined:\n   return 1;\n\n  case null:\n   return 2;\n\n  case true:\n   return 3;\n\n  case false:\n   return 4;\n\n  default:\n   {\n    return emval_handles.allocate({\n     refcount: 1,\n     value: value\n    });\n   }\n  }\n }\n};\n\nfunction __embind_register_emval(rawType, name) {\n name = readLatin1String(name);\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(handle) {\n   var rv = Emval.toValue(handle);\n   __emval_decref(handle);\n   return rv;\n  },\n  \"toWireType\": function(destructors, value) {\n   return Emval.toHandle(value);\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": simpleReadValueFromPointer,\n  destructorFunction: null\n });\n}\n\nfunction enumReadValueFromPointer(name, shift, signed) {\n switch (shift) {\n case 0:\n  return function(pointer) {\n   var heap = signed ? GROWABLE_HEAP_I8() : GROWABLE_HEAP_U8();\n   return this[\"fromWireType\"](heap[pointer]);\n  };\n\n case 1:\n  return function(pointer) {\n   var heap = signed ? GROWABLE_HEAP_I16() : GROWABLE_HEAP_U16();\n   return this[\"fromWireType\"](heap[pointer >> 1]);\n  };\n\n case 2:\n  return function(pointer) {\n   var heap = signed ? GROWABLE_HEAP_I32() : GROWABLE_HEAP_U32();\n   return this[\"fromWireType\"](heap[pointer >> 2]);\n  };\n\n default:\n  throw new TypeError(\"Unknown integer type: \" + name);\n }\n}\n\nfunction __embind_register_enum(rawType, name, size, isSigned) {\n var shift = getShiftFromSize(size);\n name = readLatin1String(name);\n function ctor() {}\n ctor.values = {};\n registerType(rawType, {\n  name: name,\n  constructor: ctor,\n  \"fromWireType\": function(c) {\n   return this.constructor.values[c];\n  },\n  \"toWireType\": function(destructors, c) {\n   return c.value;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": enumReadValueFromPointer(name, shift, isSigned),\n  destructorFunction: null\n });\n exposePublicSymbol(name, ctor);\n}\n\nfunction requireRegisteredType(rawType, humanName) {\n var impl = registeredTypes[rawType];\n if (undefined === impl) {\n  throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\n }\n return impl;\n}\n\nfunction __embind_register_enum_value(rawEnumType, name, enumValue) {\n var enumType = requireRegisteredType(rawEnumType, \"enum\");\n name = readLatin1String(name);\n var Enum = enumType.constructor;\n var Value = Object.create(enumType.constructor.prototype, {\n  value: {\n   value: enumValue\n  },\n  constructor: {\n   value: createNamedFunction(enumType.name + \"_\" + name, function() {})\n  }\n });\n Enum.values[enumValue] = Value;\n Enum[name] = Value;\n}\n\nfunction embindRepr(v) {\n if (v === null) {\n  return \"null\";\n }\n var t = typeof v;\n if (t === \"object\" || t === \"array\" || t === \"function\") {\n  return v.toString();\n } else {\n  return \"\" + v;\n }\n}\n\nfunction floatReadValueFromPointer(name, shift) {\n switch (shift) {\n case 2:\n  return function(pointer) {\n   return this[\"fromWireType\"](GROWABLE_HEAP_F32()[pointer >> 2]);\n  };\n\n case 3:\n  return function(pointer) {\n   return this[\"fromWireType\"](GROWABLE_HEAP_F64()[pointer >> 3]);\n  };\n\n default:\n  throw new TypeError(\"Unknown float type: \" + name);\n }\n}\n\nfunction __embind_register_float(rawType, name, size) {\n var shift = getShiftFromSize(size);\n name = readLatin1String(name);\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(value) {\n   return value;\n  },\n  \"toWireType\": function(destructors, value) {\n   if (typeof value != \"number\" && typeof value != \"boolean\") {\n    throw new TypeError('Cannot convert \"' + embindRepr(value) + '\" to ' + this.name);\n   }\n   return value;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": floatReadValueFromPointer(name, shift),\n  destructorFunction: null\n });\n}\n\nfunction integerReadValueFromPointer(name, shift, signed) {\n switch (shift) {\n case 0:\n  return signed ? function readS8FromPointer(pointer) {\n   return GROWABLE_HEAP_I8()[pointer];\n  } : function readU8FromPointer(pointer) {\n   return GROWABLE_HEAP_U8()[pointer];\n  };\n\n case 1:\n  return signed ? function readS16FromPointer(pointer) {\n   return GROWABLE_HEAP_I16()[pointer >> 1];\n  } : function readU16FromPointer(pointer) {\n   return GROWABLE_HEAP_U16()[pointer >> 1];\n  };\n\n case 2:\n  return signed ? function readS32FromPointer(pointer) {\n   return GROWABLE_HEAP_I32()[pointer >> 2];\n  } : function readU32FromPointer(pointer) {\n   return GROWABLE_HEAP_U32()[pointer >> 2];\n  };\n\n default:\n  throw new TypeError(\"Unknown integer type: \" + name);\n }\n}\n\nfunction __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n name = readLatin1String(name);\n if (maxRange === -1) {\n  maxRange = 4294967295;\n }\n var shift = getShiftFromSize(size);\n var fromWireType = value => value;\n if (minRange === 0) {\n  var bitshift = 32 - 8 * size;\n  fromWireType = value => value << bitshift >>> bitshift;\n }\n var isUnsignedType = name.includes(\"unsigned\");\n var checkAssertions = (value, toTypeName) => {\n  if (typeof value != \"number\" && typeof value != \"boolean\") {\n   throw new TypeError('Cannot convert \"' + embindRepr(value) + '\" to ' + toTypeName);\n  }\n  if (value < minRange || value > maxRange) {\n   throw new TypeError('Passing a number \"' + embindRepr(value) + '\" from JS side to C/C++ side to an argument of type \"' + name + '\", which is outside the valid range [' + minRange + \", \" + maxRange + \"]!\");\n  }\n };\n var toWireType;\n if (isUnsignedType) {\n  toWireType = function(destructors, value) {\n   checkAssertions(value, this.name);\n   return value >>> 0;\n  };\n } else {\n  toWireType = function(destructors, value) {\n   checkAssertions(value, this.name);\n   return value;\n  };\n }\n registerType(primitiveType, {\n  name: name,\n  \"fromWireType\": fromWireType,\n  \"toWireType\": toWireType,\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": integerReadValueFromPointer(name, shift, minRange !== 0),\n  destructorFunction: null\n });\n}\n\nfunction __embind_register_memory_view(rawType, dataTypeIndex, name) {\n var typeMapping = [ Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];\n var TA = typeMapping[dataTypeIndex];\n function decodeMemoryView(handle) {\n  handle = handle >> 2;\n  var heap = GROWABLE_HEAP_U32();\n  var size = heap[handle];\n  var data = heap[handle + 1];\n  return new TA(heap.buffer, data, size);\n }\n name = readLatin1String(name);\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": decodeMemoryView,\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": decodeMemoryView\n }, {\n  ignoreDuplicateRegistrations: true\n });\n}\n\nfunction __embind_register_smart_ptr(rawType, rawPointeeType, name, sharingPolicy, getPointeeSignature, rawGetPointee, constructorSignature, rawConstructor, shareSignature, rawShare, destructorSignature, rawDestructor) {\n name = readLatin1String(name);\n rawGetPointee = embind__requireFunction(getPointeeSignature, rawGetPointee);\n rawConstructor = embind__requireFunction(constructorSignature, rawConstructor);\n rawShare = embind__requireFunction(shareSignature, rawShare);\n rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n whenDependentTypesAreResolved([ rawType ], [ rawPointeeType ], function(pointeeType) {\n  pointeeType = pointeeType[0];\n  var registeredPointer = new RegisteredPointer(name, pointeeType.registeredClass, false, false, true, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor);\n  return [ registeredPointer ];\n });\n}\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n assert(typeof maxBytesToWrite == \"number\", \"stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n return stringToUTF8Array(str, GROWABLE_HEAP_U8(), outPtr, maxBytesToWrite);\n}\n\nfunction __embind_register_std_string(rawType, name) {\n name = readLatin1String(name);\n var stdStringIsUTF8 = name === \"std::string\";\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(value) {\n   var length = GROWABLE_HEAP_U32()[value >> 2];\n   var payload = value + 4;\n   var str;\n   if (stdStringIsUTF8) {\n    var decodeStartPtr = payload;\n    for (var i = 0; i <= length; ++i) {\n     var currentBytePtr = payload + i;\n     if (i == length || GROWABLE_HEAP_U8()[currentBytePtr] == 0) {\n      var maxRead = currentBytePtr - decodeStartPtr;\n      var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n      if (str === undefined) {\n       str = stringSegment;\n      } else {\n       str += String.fromCharCode(0);\n       str += stringSegment;\n      }\n      decodeStartPtr = currentBytePtr + 1;\n     }\n    }\n   } else {\n    var a = new Array(length);\n    for (var i = 0; i < length; ++i) {\n     a[i] = String.fromCharCode(GROWABLE_HEAP_U8()[payload + i]);\n    }\n    str = a.join(\"\");\n   }\n   _free(value);\n   return str;\n  },\n  \"toWireType\": function(destructors, value) {\n   if (value instanceof ArrayBuffer) {\n    value = new Uint8Array(value);\n   }\n   var length;\n   var valueIsOfTypeString = typeof value == \"string\";\n   if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n    throwBindingError(\"Cannot pass non-string to std::string\");\n   }\n   if (stdStringIsUTF8 && valueIsOfTypeString) {\n    length = lengthBytesUTF8(value);\n   } else {\n    length = value.length;\n   }\n   var base = _malloc(4 + length + 1);\n   var ptr = base + 4;\n   GROWABLE_HEAP_U32()[base >> 2] = length;\n   if (stdStringIsUTF8 && valueIsOfTypeString) {\n    stringToUTF8(value, ptr, length + 1);\n   } else {\n    if (valueIsOfTypeString) {\n     for (var i = 0; i < length; ++i) {\n      var charCode = value.charCodeAt(i);\n      if (charCode > 255) {\n       _free(ptr);\n       throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\n      }\n      GROWABLE_HEAP_U8()[ptr + i] = charCode;\n     }\n    } else {\n     for (var i = 0; i < length; ++i) {\n      GROWABLE_HEAP_U8()[ptr + i] = value[i];\n     }\n    }\n   }\n   if (destructors !== null) {\n    destructors.push(_free, base);\n   }\n   return base;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": simpleReadValueFromPointer,\n  destructorFunction: function(ptr) {\n   _free(ptr);\n  }\n });\n}\n\nvar UTF16Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n\nfunction UTF16ToString(ptr, maxBytesToRead) {\n assert(ptr % 2 == 0, \"Pointer passed to UTF16ToString must be aligned to two bytes!\");\n var endPtr = ptr;\n var idx = endPtr >> 1;\n var maxIdx = idx + maxBytesToRead / 2;\n while (!(idx >= maxIdx) && GROWABLE_HEAP_U16()[idx]) ++idx;\n endPtr = idx << 1;\n if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(GROWABLE_HEAP_U8().slice(ptr, endPtr));\n var str = \"\";\n for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n  var codeUnit = GROWABLE_HEAP_I16()[ptr + i * 2 >> 1];\n  if (codeUnit == 0) break;\n  str += String.fromCharCode(codeUnit);\n }\n return str;\n}\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n assert(outPtr % 2 == 0, \"Pointer passed to stringToUTF16 must be aligned to two bytes!\");\n assert(typeof maxBytesToWrite == \"number\", \"stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n if (maxBytesToWrite === undefined) {\n  maxBytesToWrite = 2147483647;\n }\n if (maxBytesToWrite < 2) return 0;\n maxBytesToWrite -= 2;\n var startPtr = outPtr;\n var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n for (var i = 0; i < numCharsToWrite; ++i) {\n  var codeUnit = str.charCodeAt(i);\n  GROWABLE_HEAP_I16()[outPtr >> 1] = codeUnit;\n  outPtr += 2;\n }\n GROWABLE_HEAP_I16()[outPtr >> 1] = 0;\n return outPtr - startPtr;\n}\n\nfunction lengthBytesUTF16(str) {\n return str.length * 2;\n}\n\nfunction UTF32ToString(ptr, maxBytesToRead) {\n assert(ptr % 4 == 0, \"Pointer passed to UTF32ToString must be aligned to four bytes!\");\n var i = 0;\n var str = \"\";\n while (!(i >= maxBytesToRead / 4)) {\n  var utf32 = GROWABLE_HEAP_I32()[ptr + i * 4 >> 2];\n  if (utf32 == 0) break;\n  ++i;\n  if (utf32 >= 65536) {\n   var ch = utf32 - 65536;\n   str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n  } else {\n   str += String.fromCharCode(utf32);\n  }\n }\n return str;\n}\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n assert(outPtr % 4 == 0, \"Pointer passed to stringToUTF32 must be aligned to four bytes!\");\n assert(typeof maxBytesToWrite == \"number\", \"stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n if (maxBytesToWrite === undefined) {\n  maxBytesToWrite = 2147483647;\n }\n if (maxBytesToWrite < 4) return 0;\n var startPtr = outPtr;\n var endPtr = startPtr + maxBytesToWrite - 4;\n for (var i = 0; i < str.length; ++i) {\n  var codeUnit = str.charCodeAt(i);\n  if (codeUnit >= 55296 && codeUnit <= 57343) {\n   var trailSurrogate = str.charCodeAt(++i);\n   codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n  }\n  GROWABLE_HEAP_I32()[outPtr >> 2] = codeUnit;\n  outPtr += 4;\n  if (outPtr + 4 > endPtr) break;\n }\n GROWABLE_HEAP_I32()[outPtr >> 2] = 0;\n return outPtr - startPtr;\n}\n\nfunction lengthBytesUTF32(str) {\n var len = 0;\n for (var i = 0; i < str.length; ++i) {\n  var codeUnit = str.charCodeAt(i);\n  if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n  len += 4;\n }\n return len;\n}\n\nfunction __embind_register_std_wstring(rawType, charSize, name) {\n name = readLatin1String(name);\n var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n if (charSize === 2) {\n  decodeString = UTF16ToString;\n  encodeString = stringToUTF16;\n  lengthBytesUTF = lengthBytesUTF16;\n  getHeap = () => GROWABLE_HEAP_U16();\n  shift = 1;\n } else if (charSize === 4) {\n  decodeString = UTF32ToString;\n  encodeString = stringToUTF32;\n  lengthBytesUTF = lengthBytesUTF32;\n  getHeap = () => GROWABLE_HEAP_U32();\n  shift = 2;\n }\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(value) {\n   var length = GROWABLE_HEAP_U32()[value >> 2];\n   var HEAP = getHeap();\n   var str;\n   var decodeStartPtr = value + 4;\n   for (var i = 0; i <= length; ++i) {\n    var currentBytePtr = value + 4 + i * charSize;\n    if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n     var maxReadBytes = currentBytePtr - decodeStartPtr;\n     var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n     if (str === undefined) {\n      str = stringSegment;\n     } else {\n      str += String.fromCharCode(0);\n      str += stringSegment;\n     }\n     decodeStartPtr = currentBytePtr + charSize;\n    }\n   }\n   _free(value);\n   return str;\n  },\n  \"toWireType\": function(destructors, value) {\n   if (!(typeof value == \"string\")) {\n    throwBindingError(\"Cannot pass non-string to C++ string type \" + name);\n   }\n   var length = lengthBytesUTF(value);\n   var ptr = _malloc(4 + length + charSize);\n   GROWABLE_HEAP_U32()[ptr >> 2] = length >> shift;\n   encodeString(value, ptr + 4, length + charSize);\n   if (destructors !== null) {\n    destructors.push(_free, ptr);\n   }\n   return ptr;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": simpleReadValueFromPointer,\n  destructorFunction: function(ptr) {\n   _free(ptr);\n  }\n });\n}\n\nfunction __embind_register_void(rawType, name) {\n name = readLatin1String(name);\n registerType(rawType, {\n  isVoid: true,\n  name: name,\n  \"argPackAdvance\": 0,\n  \"fromWireType\": function() {\n   return undefined;\n  },\n  \"toWireType\": function(destructors, o) {\n   return undefined;\n  }\n });\n}\n\nfunction __emscripten_default_pthread_stack_size() {\n return 65536;\n}\n\nvar nowIsMonotonic = true;\n\nfunction __emscripten_get_now_is_monotonic() {\n return nowIsMonotonic;\n}\n\nfunction maybeExit() {\n if (!keepRuntimeAlive()) {\n  try {\n   if (ENVIRONMENT_IS_PTHREAD) __emscripten_thread_exit(EXITSTATUS); else _exit(EXITSTATUS);\n  } catch (e) {\n   handleException(e);\n  }\n }\n}\n\nfunction callUserCallback(func) {\n if (ABORT) {\n  err(\"user callback triggered after runtime exited or application aborted.  Ignoring.\");\n  return;\n }\n try {\n  func();\n  maybeExit();\n } catch (e) {\n  handleException(e);\n }\n}\n\nfunction __emscripten_thread_mailbox_await(pthread_ptr) {\n if (typeof Atomics.waitAsync === \"function\") {\n  var wait = Atomics.waitAsync(GROWABLE_HEAP_I32(), pthread_ptr >> 2, pthread_ptr);\n  assert(wait.async);\n  wait.value.then(checkMailbox);\n  var waitingAsync = pthread_ptr + 128;\n  Atomics.store(GROWABLE_HEAP_I32(), waitingAsync >> 2, 1);\n }\n}\n\nModule[\"__emscripten_thread_mailbox_await\"] = __emscripten_thread_mailbox_await;\n\nfunction checkMailbox() {\n var pthread_ptr = _pthread_self();\n if (pthread_ptr) {\n  __emscripten_thread_mailbox_await(pthread_ptr);\n  callUserCallback(() => __emscripten_check_mailbox());\n }\n}\n\nModule[\"checkMailbox\"] = checkMailbox;\n\nfunction __emscripten_notify_mailbox_postmessage(targetThreadId, currThreadId, mainThreadId) {\n if (targetThreadId == currThreadId) {\n  setTimeout(() => checkMailbox());\n } else if (ENVIRONMENT_IS_PTHREAD) {\n  postMessage({\n   \"targetThread\": targetThreadId,\n   \"cmd\": \"checkMailbox\"\n  });\n } else {\n  var worker = PThread.pthreads[targetThreadId];\n  if (!worker) {\n   err(\"Cannot send message to thread with ID \" + targetThreadId + \", unknown thread ID!\");\n   return;\n  }\n  worker.postMessage({\n   \"cmd\": \"checkMailbox\"\n  });\n }\n}\n\nfunction __emscripten_set_offscreencanvas_size(target, width, height) {\n err(\"emscripten_set_offscreencanvas_size: Build with -sOFFSCREENCANVAS_SUPPORT=1 to enable transferring canvases to pthreads.\");\n return -1;\n}\n\nfunction emval_lookupTypes(argCount, argTypes) {\n var a = new Array(argCount);\n for (var i = 0; i < argCount; ++i) {\n  a[i] = requireRegisteredType(GROWABLE_HEAP_U32()[argTypes + i * 4 >> 2], \"parameter \" + i);\n }\n return a;\n}\n\nfunction __emval_call(handle, argCount, argTypes, argv) {\n handle = Emval.toValue(handle);\n var types = emval_lookupTypes(argCount, argTypes);\n var args = new Array(argCount);\n for (var i = 0; i < argCount; ++i) {\n  var type = types[i];\n  args[i] = type[\"readValueFromPointer\"](argv);\n  argv += type[\"argPackAdvance\"];\n }\n var rv = handle.apply(undefined, args);\n return Emval.toHandle(rv);\n}\n\nfunction __emval_incref(handle) {\n if (handle > 4) {\n  emval_handles.get(handle).refcount += 1;\n }\n}\n\nfunction __emval_take_value(type, arg) {\n type = requireRegisteredType(type, \"_emval_take_value\");\n var v = type[\"readValueFromPointer\"](arg);\n return Emval.toHandle(v);\n}\n\nfunction _abort() {\n abort(\"native code called abort()\");\n}\n\nfunction _emscripten_check_blocking_allowed() {\n if (ENVIRONMENT_IS_WORKER) return;\n warnOnce(\"Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread\");\n}\n\nfunction _emscripten_date_now() {\n return Date.now();\n}\n\nfunction runtimeKeepalivePush() {\n runtimeKeepaliveCounter += 1;\n}\n\nfunction _emscripten_exit_with_live_runtime() {\n runtimeKeepalivePush();\n throw \"unwind\";\n}\n\nfunction getHeapMax() {\n return 2147483648;\n}\n\nfunction _emscripten_get_heap_max() {\n return getHeapMax();\n}\n\nvar _emscripten_get_now;\n\n_emscripten_get_now = () => performance.timeOrigin + performance.now();\n\nfunction _emscripten_num_logical_cores() {\n return navigator[\"hardwareConcurrency\"];\n}\n\nfunction proxyToMainThread(index, sync) {\n var numCallArgs = arguments.length - 2;\n var outerArgs = arguments;\n var maxArgs = 19;\n if (numCallArgs > maxArgs) {\n  throw \"proxyToMainThread: Too many arguments \" + numCallArgs + \" to proxied function idx=\" + index + \", maximum supported is \" + maxArgs;\n }\n return withStackSave(() => {\n  var serializedNumCallArgs = numCallArgs;\n  var args = stackAlloc(serializedNumCallArgs * 8);\n  var b = args >> 3;\n  for (var i = 0; i < numCallArgs; i++) {\n   var arg = outerArgs[2 + i];\n   GROWABLE_HEAP_F64()[b + i] = arg;\n  }\n  return __emscripten_run_in_main_runtime_thread_js(index, serializedNumCallArgs, args, sync);\n });\n}\n\nvar emscripten_receive_on_main_thread_js_callArgs = [];\n\nfunction _emscripten_receive_on_main_thread_js(index, numCallArgs, args) {\n emscripten_receive_on_main_thread_js_callArgs.length = numCallArgs;\n var b = args >> 3;\n for (var i = 0; i < numCallArgs; i++) {\n  emscripten_receive_on_main_thread_js_callArgs[i] = GROWABLE_HEAP_F64()[b + i];\n }\n var func = proxiedFunctionTable[index];\n assert(func.length == numCallArgs, \"Call args mismatch in emscripten_receive_on_main_thread_js\");\n return func.apply(null, emscripten_receive_on_main_thread_js_callArgs);\n}\n\nfunction emscripten_realloc_buffer(size) {\n var b = wasmMemory.buffer;\n try {\n  wasmMemory.grow(size - b.byteLength + 65535 >>> 16);\n  updateMemoryViews();\n  return 1;\n } catch (e) {\n  err(\"emscripten_realloc_buffer: Attempted to grow heap from \" + b.byteLength + \" bytes to \" + size + \" bytes, but got error: \" + e);\n }\n}\n\nfunction _emscripten_resize_heap(requestedSize) {\n var oldSize = GROWABLE_HEAP_U8().length;\n requestedSize = requestedSize >>> 0;\n if (requestedSize <= oldSize) {\n  return false;\n }\n var maxHeapSize = getHeapMax();\n if (requestedSize > maxHeapSize) {\n  err(\"Cannot enlarge memory, asked to go up to \" + requestedSize + \" bytes, but the limit is \" + maxHeapSize + \" bytes!\");\n  return false;\n }\n let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;\n for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n  var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n  overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n  var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n  var replacement = emscripten_realloc_buffer(newSize);\n  if (replacement) {\n   return true;\n  }\n }\n err(\"Failed to grow the heap from \" + oldSize + \" bytes to \" + newSize + \" bytes, not enough memory!\");\n return false;\n}\n\nvar ENV = {};\n\nfunction getExecutableName() {\n return thisProgram || \"./this.program\";\n}\n\nfunction getEnvStrings() {\n if (!getEnvStrings.strings) {\n  var lang = (typeof navigator == \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\";\n  var env = {\n   \"USER\": \"web_user\",\n   \"LOGNAME\": \"web_user\",\n   \"PATH\": \"/\",\n   \"PWD\": \"/\",\n   \"HOME\": \"/home/web_user\",\n   \"LANG\": lang,\n   \"_\": getExecutableName()\n  };\n  for (var x in ENV) {\n   if (ENV[x] === undefined) delete env[x]; else env[x] = ENV[x];\n  }\n  var strings = [];\n  for (var x in env) {\n   strings.push(x + \"=\" + env[x]);\n  }\n  getEnvStrings.strings = strings;\n }\n return getEnvStrings.strings;\n}\n\nfunction stringToAscii(str, buffer) {\n for (var i = 0; i < str.length; ++i) {\n  assert(str.charCodeAt(i) === (str.charCodeAt(i) & 255));\n  GROWABLE_HEAP_I8()[buffer++ >> 0] = str.charCodeAt(i);\n }\n GROWABLE_HEAP_I8()[buffer >> 0] = 0;\n}\n\nfunction _environ_get(__environ, environ_buf) {\n if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(4, 1, __environ, environ_buf);\n var bufSize = 0;\n getEnvStrings().forEach(function(string, i) {\n  var ptr = environ_buf + bufSize;\n  GROWABLE_HEAP_U32()[__environ + i * 4 >> 2] = ptr;\n  stringToAscii(string, ptr);\n  bufSize += string.length + 1;\n });\n return 0;\n}\n\nfunction _environ_sizes_get(penviron_count, penviron_buf_size) {\n if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(5, 1, penviron_count, penviron_buf_size);\n var strings = getEnvStrings();\n GROWABLE_HEAP_U32()[penviron_count >> 2] = strings.length;\n var bufSize = 0;\n strings.forEach(function(string) {\n  bufSize += string.length + 1;\n });\n GROWABLE_HEAP_U32()[penviron_buf_size >> 2] = bufSize;\n return 0;\n}\n\nfunction _fd_close(fd) {\n if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(6, 1, fd);\n try {\n  var stream = SYSCALLS.getStreamFromFD(fd);\n  FS.close(stream);\n  return 0;\n } catch (e) {\n  if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n  return e.errno;\n }\n}\n\nfunction doReadv(stream, iov, iovcnt, offset) {\n var ret = 0;\n for (var i = 0; i < iovcnt; i++) {\n  var ptr = GROWABLE_HEAP_U32()[iov >> 2];\n  var len = GROWABLE_HEAP_U32()[iov + 4 >> 2];\n  iov += 8;\n  var curr = FS.read(stream, GROWABLE_HEAP_I8(), ptr, len, offset);\n  if (curr < 0) return -1;\n  ret += curr;\n  if (curr < len) break;\n  if (typeof offset !== \"undefined\") {\n   offset += curr;\n  }\n }\n return ret;\n}\n\nfunction _fd_read(fd, iov, iovcnt, pnum) {\n if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(7, 1, fd, iov, iovcnt, pnum);\n try {\n  var stream = SYSCALLS.getStreamFromFD(fd);\n  var num = doReadv(stream, iov, iovcnt);\n  GROWABLE_HEAP_U32()[pnum >> 2] = num;\n  return 0;\n } catch (e) {\n  if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n  return e.errno;\n }\n}\n\nfunction convertI32PairToI53Checked(lo, hi) {\n assert(lo == lo >>> 0 || lo == (lo | 0));\n assert(hi === (hi | 0));\n return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;\n}\n\nfunction _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(8, 1, fd, offset_low, offset_high, whence, newOffset);\n try {\n  var offset = convertI32PairToI53Checked(offset_low, offset_high);\n  if (isNaN(offset)) return 61;\n  var stream = SYSCALLS.getStreamFromFD(fd);\n  FS.llseek(stream, offset, whence);\n  tempI64 = [ stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], \n  GROWABLE_HEAP_I32()[newOffset >> 2] = tempI64[0], GROWABLE_HEAP_I32()[newOffset + 4 >> 2] = tempI64[1];\n  if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\n  return 0;\n } catch (e) {\n  if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n  return e.errno;\n }\n}\n\nfunction doWritev(stream, iov, iovcnt, offset) {\n var ret = 0;\n for (var i = 0; i < iovcnt; i++) {\n  var ptr = GROWABLE_HEAP_U32()[iov >> 2];\n  var len = GROWABLE_HEAP_U32()[iov + 4 >> 2];\n  iov += 8;\n  var curr = FS.write(stream, GROWABLE_HEAP_I8(), ptr, len, offset);\n  if (curr < 0) return -1;\n  ret += curr;\n  if (typeof offset !== \"undefined\") {\n   offset += curr;\n  }\n }\n return ret;\n}\n\nfunction _fd_write(fd, iov, iovcnt, pnum) {\n if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(9, 1, fd, iov, iovcnt, pnum);\n try {\n  var stream = SYSCALLS.getStreamFromFD(fd);\n  var num = doWritev(stream, iov, iovcnt);\n  GROWABLE_HEAP_U32()[pnum >> 2] = num;\n  return 0;\n } catch (e) {\n  if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n  return e.errno;\n }\n}\n\nfunction isLeapYear(year) {\n return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n\nfunction arraySum(array, index) {\n var sum = 0;\n for (var i = 0; i <= index; sum += array[i++]) {}\n return sum;\n}\n\nvar MONTH_DAYS_LEAP = [ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];\n\nvar MONTH_DAYS_REGULAR = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];\n\nfunction addDays(date, days) {\n var newDate = new Date(date.getTime());\n while (days > 0) {\n  var leap = isLeapYear(newDate.getFullYear());\n  var currentMonth = newDate.getMonth();\n  var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];\n  if (days > daysInCurrentMonth - newDate.getDate()) {\n   days -= daysInCurrentMonth - newDate.getDate() + 1;\n   newDate.setDate(1);\n   if (currentMonth < 11) {\n    newDate.setMonth(currentMonth + 1);\n   } else {\n    newDate.setMonth(0);\n    newDate.setFullYear(newDate.getFullYear() + 1);\n   }\n  } else {\n   newDate.setDate(newDate.getDate() + days);\n   return newDate;\n  }\n }\n return newDate;\n}\n\nfunction writeArrayToMemory(array, buffer) {\n assert(array.length >= 0, \"writeArrayToMemory array must have a length (should be an array or typed array)\");\n GROWABLE_HEAP_I8().set(array, buffer);\n}\n\nfunction _strftime(s, maxsize, format, tm) {\n var tm_zone = GROWABLE_HEAP_I32()[tm + 40 >> 2];\n var date = {\n  tm_sec: GROWABLE_HEAP_I32()[tm >> 2],\n  tm_min: GROWABLE_HEAP_I32()[tm + 4 >> 2],\n  tm_hour: GROWABLE_HEAP_I32()[tm + 8 >> 2],\n  tm_mday: GROWABLE_HEAP_I32()[tm + 12 >> 2],\n  tm_mon: GROWABLE_HEAP_I32()[tm + 16 >> 2],\n  tm_year: GROWABLE_HEAP_I32()[tm + 20 >> 2],\n  tm_wday: GROWABLE_HEAP_I32()[tm + 24 >> 2],\n  tm_yday: GROWABLE_HEAP_I32()[tm + 28 >> 2],\n  tm_isdst: GROWABLE_HEAP_I32()[tm + 32 >> 2],\n  tm_gmtoff: GROWABLE_HEAP_I32()[tm + 36 >> 2],\n  tm_zone: tm_zone ? UTF8ToString(tm_zone) : \"\"\n };\n var pattern = UTF8ToString(format);\n var EXPANSION_RULES_1 = {\n  \"%c\": \"%a %b %d %H:%M:%S %Y\",\n  \"%D\": \"%m/%d/%y\",\n  \"%F\": \"%Y-%m-%d\",\n  \"%h\": \"%b\",\n  \"%r\": \"%I:%M:%S %p\",\n  \"%R\": \"%H:%M\",\n  \"%T\": \"%H:%M:%S\",\n  \"%x\": \"%m/%d/%y\",\n  \"%X\": \"%H:%M:%S\",\n  \"%Ec\": \"%c\",\n  \"%EC\": \"%C\",\n  \"%Ex\": \"%m/%d/%y\",\n  \"%EX\": \"%H:%M:%S\",\n  \"%Ey\": \"%y\",\n  \"%EY\": \"%Y\",\n  \"%Od\": \"%d\",\n  \"%Oe\": \"%e\",\n  \"%OH\": \"%H\",\n  \"%OI\": \"%I\",\n  \"%Om\": \"%m\",\n  \"%OM\": \"%M\",\n  \"%OS\": \"%S\",\n  \"%Ou\": \"%u\",\n  \"%OU\": \"%U\",\n  \"%OV\": \"%V\",\n  \"%Ow\": \"%w\",\n  \"%OW\": \"%W\",\n  \"%Oy\": \"%y\"\n };\n for (var rule in EXPANSION_RULES_1) {\n  pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_1[rule]);\n }\n var WEEKDAYS = [ \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" ];\n var MONTHS = [ \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" ];\n function leadingSomething(value, digits, character) {\n  var str = typeof value == \"number\" ? value.toString() : value || \"\";\n  while (str.length < digits) {\n   str = character[0] + str;\n  }\n  return str;\n }\n function leadingNulls(value, digits) {\n  return leadingSomething(value, digits, \"0\");\n }\n function compareByDay(date1, date2) {\n  function sgn(value) {\n   return value < 0 ? -1 : value > 0 ? 1 : 0;\n  }\n  var compare;\n  if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n   if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\n    compare = sgn(date1.getDate() - date2.getDate());\n   }\n  }\n  return compare;\n }\n function getFirstWeekStartDate(janFourth) {\n  switch (janFourth.getDay()) {\n  case 0:\n   return new Date(janFourth.getFullYear() - 1, 11, 29);\n\n  case 1:\n   return janFourth;\n\n  case 2:\n   return new Date(janFourth.getFullYear(), 0, 3);\n\n  case 3:\n   return new Date(janFourth.getFullYear(), 0, 2);\n\n  case 4:\n   return new Date(janFourth.getFullYear(), 0, 1);\n\n  case 5:\n   return new Date(janFourth.getFullYear() - 1, 11, 31);\n\n  case 6:\n   return new Date(janFourth.getFullYear() - 1, 11, 30);\n  }\n }\n function getWeekBasedYear(date) {\n  var thisDate = addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n  var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\n  var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\n  var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n  var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n  if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n   if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\n    return thisDate.getFullYear() + 1;\n   }\n   return thisDate.getFullYear();\n  }\n  return thisDate.getFullYear() - 1;\n }\n var EXPANSION_RULES_2 = {\n  \"%a\": function(date) {\n   return WEEKDAYS[date.tm_wday].substring(0, 3);\n  },\n  \"%A\": function(date) {\n   return WEEKDAYS[date.tm_wday];\n  },\n  \"%b\": function(date) {\n   return MONTHS[date.tm_mon].substring(0, 3);\n  },\n  \"%B\": function(date) {\n   return MONTHS[date.tm_mon];\n  },\n  \"%C\": function(date) {\n   var year = date.tm_year + 1900;\n   return leadingNulls(year / 100 | 0, 2);\n  },\n  \"%d\": function(date) {\n   return leadingNulls(date.tm_mday, 2);\n  },\n  \"%e\": function(date) {\n   return leadingSomething(date.tm_mday, 2, \" \");\n  },\n  \"%g\": function(date) {\n   return getWeekBasedYear(date).toString().substring(2);\n  },\n  \"%G\": function(date) {\n   return getWeekBasedYear(date);\n  },\n  \"%H\": function(date) {\n   return leadingNulls(date.tm_hour, 2);\n  },\n  \"%I\": function(date) {\n   var twelveHour = date.tm_hour;\n   if (twelveHour == 0) twelveHour = 12; else if (twelveHour > 12) twelveHour -= 12;\n   return leadingNulls(twelveHour, 2);\n  },\n  \"%j\": function(date) {\n   return leadingNulls(date.tm_mday + arraySum(isLeapYear(date.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date.tm_mon - 1), 3);\n  },\n  \"%m\": function(date) {\n   return leadingNulls(date.tm_mon + 1, 2);\n  },\n  \"%M\": function(date) {\n   return leadingNulls(date.tm_min, 2);\n  },\n  \"%n\": function() {\n   return \"\\n\";\n  },\n  \"%p\": function(date) {\n   if (date.tm_hour >= 0 && date.tm_hour < 12) {\n    return \"AM\";\n   }\n   return \"PM\";\n  },\n  \"%S\": function(date) {\n   return leadingNulls(date.tm_sec, 2);\n  },\n  \"%t\": function() {\n   return \"\\t\";\n  },\n  \"%u\": function(date) {\n   return date.tm_wday || 7;\n  },\n  \"%U\": function(date) {\n   var days = date.tm_yday + 7 - date.tm_wday;\n   return leadingNulls(Math.floor(days / 7), 2);\n  },\n  \"%V\": function(date) {\n   var val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7) / 7);\n   if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {\n    val++;\n   }\n   if (!val) {\n    val = 52;\n    var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;\n    if (dec31 == 4 || dec31 == 5 && isLeapYear(date.tm_year % 400 - 1)) {\n     val++;\n    }\n   } else if (val == 53) {\n    var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;\n    if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date.tm_year))) val = 1;\n   }\n   return leadingNulls(val, 2);\n  },\n  \"%w\": function(date) {\n   return date.tm_wday;\n  },\n  \"%W\": function(date) {\n   var days = date.tm_yday + 7 - (date.tm_wday + 6) % 7;\n   return leadingNulls(Math.floor(days / 7), 2);\n  },\n  \"%y\": function(date) {\n   return (date.tm_year + 1900).toString().substring(2);\n  },\n  \"%Y\": function(date) {\n   return date.tm_year + 1900;\n  },\n  \"%z\": function(date) {\n   var off = date.tm_gmtoff;\n   var ahead = off >= 0;\n   off = Math.abs(off) / 60;\n   off = off / 60 * 100 + off % 60;\n   return (ahead ? \"+\" : \"-\") + String(\"0000\" + off).slice(-4);\n  },\n  \"%Z\": function(date) {\n   return date.tm_zone;\n  },\n  \"%%\": function() {\n   return \"%\";\n  }\n };\n pattern = pattern.replace(/%%/g, \"\\0\\0\");\n for (var rule in EXPANSION_RULES_2) {\n  if (pattern.includes(rule)) {\n   pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_2[rule](date));\n  }\n }\n pattern = pattern.replace(/\\0\\0/g, \"%\");\n var bytes = intArrayFromString(pattern, false);\n if (bytes.length > maxsize) {\n  return 0;\n }\n writeArrayToMemory(bytes, s);\n return bytes.length - 1;\n}\n\nfunction _strftime_l(s, maxsize, format, tm, loc) {\n return _strftime(s, maxsize, format, tm);\n}\n\nPThread.init();\n\nvar FSNode = function(parent, name, mode, rdev) {\n if (!parent) {\n  parent = this;\n }\n this.parent = parent;\n this.mount = parent.mount;\n this.mounted = null;\n this.id = FS.nextInode++;\n this.name = name;\n this.mode = mode;\n this.node_ops = {};\n this.stream_ops = {};\n this.rdev = rdev;\n};\n\nvar readMode = 292 | 73;\n\nvar writeMode = 146;\n\nObject.defineProperties(FSNode.prototype, {\n read: {\n  get: function() {\n   return (this.mode & readMode) === readMode;\n  },\n  set: function(val) {\n   val ? this.mode |= readMode : this.mode &= ~readMode;\n  }\n },\n write: {\n  get: function() {\n   return (this.mode & writeMode) === writeMode;\n  },\n  set: function(val) {\n   val ? this.mode |= writeMode : this.mode &= ~writeMode;\n  }\n },\n isFolder: {\n  get: function() {\n   return FS.isDir(this.mode);\n  }\n },\n isDevice: {\n  get: function() {\n   return FS.isChrdev(this.mode);\n  }\n }\n});\n\nFS.FSNode = FSNode;\n\nFS.staticInit();\n\nERRNO_CODES = {\n \"EPERM\": 63,\n \"ENOENT\": 44,\n \"ESRCH\": 71,\n \"EINTR\": 27,\n \"EIO\": 29,\n \"ENXIO\": 60,\n \"E2BIG\": 1,\n \"ENOEXEC\": 45,\n \"EBADF\": 8,\n \"ECHILD\": 12,\n \"EAGAIN\": 6,\n \"EWOULDBLOCK\": 6,\n \"ENOMEM\": 48,\n \"EACCES\": 2,\n \"EFAULT\": 21,\n \"ENOTBLK\": 105,\n \"EBUSY\": 10,\n \"EEXIST\": 20,\n \"EXDEV\": 75,\n \"ENODEV\": 43,\n \"ENOTDIR\": 54,\n \"EISDIR\": 31,\n \"EINVAL\": 28,\n \"ENFILE\": 41,\n \"EMFILE\": 33,\n \"ENOTTY\": 59,\n \"ETXTBSY\": 74,\n \"EFBIG\": 22,\n \"ENOSPC\": 51,\n \"ESPIPE\": 70,\n \"EROFS\": 69,\n \"EMLINK\": 34,\n \"EPIPE\": 64,\n \"EDOM\": 18,\n \"ERANGE\": 68,\n \"ENOMSG\": 49,\n \"EIDRM\": 24,\n \"ECHRNG\": 106,\n \"EL2NSYNC\": 156,\n \"EL3HLT\": 107,\n \"EL3RST\": 108,\n \"ELNRNG\": 109,\n \"EUNATCH\": 110,\n \"ENOCSI\": 111,\n \"EL2HLT\": 112,\n \"EDEADLK\": 16,\n \"ENOLCK\": 46,\n \"EBADE\": 113,\n \"EBADR\": 114,\n \"EXFULL\": 115,\n \"ENOANO\": 104,\n \"EBADRQC\": 103,\n \"EBADSLT\": 102,\n \"EDEADLOCK\": 16,\n \"EBFONT\": 101,\n \"ENOSTR\": 100,\n \"ENODATA\": 116,\n \"ETIME\": 117,\n \"ENOSR\": 118,\n \"ENONET\": 119,\n \"ENOPKG\": 120,\n \"EREMOTE\": 121,\n \"ENOLINK\": 47,\n \"EADV\": 122,\n \"ESRMNT\": 123,\n \"ECOMM\": 124,\n \"EPROTO\": 65,\n \"EMULTIHOP\": 36,\n \"EDOTDOT\": 125,\n \"EBADMSG\": 9,\n \"ENOTUNIQ\": 126,\n \"EBADFD\": 127,\n \"EREMCHG\": 128,\n \"ELIBACC\": 129,\n \"ELIBBAD\": 130,\n \"ELIBSCN\": 131,\n \"ELIBMAX\": 132,\n \"ELIBEXEC\": 133,\n \"ENOSYS\": 52,\n \"ENOTEMPTY\": 55,\n \"ENAMETOOLONG\": 37,\n \"ELOOP\": 32,\n \"EOPNOTSUPP\": 138,\n \"EPFNOSUPPORT\": 139,\n \"ECONNRESET\": 15,\n \"ENOBUFS\": 42,\n \"EAFNOSUPPORT\": 5,\n \"EPROTOTYPE\": 67,\n \"ENOTSOCK\": 57,\n \"ENOPROTOOPT\": 50,\n \"ESHUTDOWN\": 140,\n \"ECONNREFUSED\": 14,\n \"EADDRINUSE\": 3,\n \"ECONNABORTED\": 13,\n \"ENETUNREACH\": 40,\n \"ENETDOWN\": 38,\n \"ETIMEDOUT\": 73,\n \"EHOSTDOWN\": 142,\n \"EHOSTUNREACH\": 23,\n \"EINPROGRESS\": 26,\n \"EALREADY\": 7,\n \"EDESTADDRREQ\": 17,\n \"EMSGSIZE\": 35,\n \"EPROTONOSUPPORT\": 66,\n \"ESOCKTNOSUPPORT\": 137,\n \"EADDRNOTAVAIL\": 4,\n \"ENETRESET\": 39,\n \"EISCONN\": 30,\n \"ENOTCONN\": 53,\n \"ETOOMANYREFS\": 141,\n \"EUSERS\": 136,\n \"EDQUOT\": 19,\n \"ESTALE\": 72,\n \"ENOTSUP\": 138,\n \"ENOMEDIUM\": 148,\n \"EILSEQ\": 25,\n \"EOVERFLOW\": 61,\n \"ECANCELED\": 11,\n \"ENOTRECOVERABLE\": 56,\n \"EOWNERDEAD\": 62,\n \"ESTRPIPE\": 135\n};\n\nembind_init_charCodes();\n\nBindingError = Module[\"BindingError\"] = extendError(Error, \"BindingError\");\n\nInternalError = Module[\"InternalError\"] = extendError(Error, \"InternalError\");\n\ninit_ClassHandle();\n\ninit_embind();\n\ninit_RegisteredPointer();\n\nUnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n\ninit_emval();\n\nvar proxiedFunctionTable = [ null, _proc_exit, exitOnMainThread, pthreadCreateProxied, _environ_get, _environ_sizes_get, _fd_close, _fd_read, _fd_seek, _fd_write ];\n\nfunction checkIncomingModuleAPI() {\n ignoredModuleProp(\"fetchSettings\");\n}\n\nvar wasmImports = {\n \"__assert_fail\": ___assert_fail,\n \"__call_sighandler\": ___call_sighandler,\n \"__emscripten_init_main_thread_js\": ___emscripten_init_main_thread_js,\n \"__emscripten_thread_cleanup\": ___emscripten_thread_cleanup,\n \"__pthread_create_js\": ___pthread_create_js,\n \"__throw_exception_with_stack_trace\": ___throw_exception_with_stack_trace,\n \"_embind_register_bigint\": __embind_register_bigint,\n \"_embind_register_bool\": __embind_register_bool,\n \"_embind_register_class\": __embind_register_class,\n \"_embind_register_class_constructor\": __embind_register_class_constructor,\n \"_embind_register_class_function\": __embind_register_class_function,\n \"_embind_register_emval\": __embind_register_emval,\n \"_embind_register_enum\": __embind_register_enum,\n \"_embind_register_enum_value\": __embind_register_enum_value,\n \"_embind_register_float\": __embind_register_float,\n \"_embind_register_integer\": __embind_register_integer,\n \"_embind_register_memory_view\": __embind_register_memory_view,\n \"_embind_register_smart_ptr\": __embind_register_smart_ptr,\n \"_embind_register_std_string\": __embind_register_std_string,\n \"_embind_register_std_wstring\": __embind_register_std_wstring,\n \"_embind_register_void\": __embind_register_void,\n \"_emscripten_default_pthread_stack_size\": __emscripten_default_pthread_stack_size,\n \"_emscripten_get_now_is_monotonic\": __emscripten_get_now_is_monotonic,\n \"_emscripten_notify_mailbox_postmessage\": __emscripten_notify_mailbox_postmessage,\n \"_emscripten_set_offscreencanvas_size\": __emscripten_set_offscreencanvas_size,\n \"_emscripten_thread_mailbox_await\": __emscripten_thread_mailbox_await,\n \"_emval_call\": __emval_call,\n \"_emval_decref\": __emval_decref,\n \"_emval_incref\": __emval_incref,\n \"_emval_take_value\": __emval_take_value,\n \"abort\": _abort,\n \"emscripten_check_blocking_allowed\": _emscripten_check_blocking_allowed,\n \"emscripten_date_now\": _emscripten_date_now,\n \"emscripten_exit_with_live_runtime\": _emscripten_exit_with_live_runtime,\n \"emscripten_get_heap_max\": _emscripten_get_heap_max,\n \"emscripten_get_now\": _emscripten_get_now,\n \"emscripten_num_logical_cores\": _emscripten_num_logical_cores,\n \"emscripten_receive_on_main_thread_js\": _emscripten_receive_on_main_thread_js,\n \"emscripten_resize_heap\": _emscripten_resize_heap,\n \"environ_get\": _environ_get,\n \"environ_sizes_get\": _environ_sizes_get,\n \"exit\": _exit,\n \"fd_close\": _fd_close,\n \"fd_read\": _fd_read,\n \"fd_seek\": _fd_seek,\n \"fd_write\": _fd_write,\n \"memory\": wasmMemory || Module[\"wasmMemory\"],\n \"strftime_l\": _strftime_l\n};\n\nvar asm = createWasm();\n\nvar ___wasm_call_ctors = createExportWrapper(\"__wasm_call_ctors\");\n\nvar _malloc = createExportWrapper(\"malloc\");\n\nvar _free = Module[\"_free\"] = createExportWrapper(\"free\");\n\nvar __emscripten_tls_init = Module[\"__emscripten_tls_init\"] = createExportWrapper(\"_emscripten_tls_init\");\n\nvar _pthread_self = Module[\"_pthread_self\"] = function() {\n return (_pthread_self = Module[\"_pthread_self\"] = Module[\"asm\"][\"pthread_self\"]).apply(null, arguments);\n};\n\nvar ___getTypeName = Module[\"___getTypeName\"] = createExportWrapper(\"__getTypeName\");\n\nvar __embind_initialize_bindings = Module[\"__embind_initialize_bindings\"] = createExportWrapper(\"_embind_initialize_bindings\");\n\nvar ___errno_location = createExportWrapper(\"__errno_location\");\n\nvar __emscripten_thread_init = Module[\"__emscripten_thread_init\"] = createExportWrapper(\"_emscripten_thread_init\");\n\nvar __emscripten_thread_crashed = Module[\"__emscripten_thread_crashed\"] = createExportWrapper(\"_emscripten_thread_crashed\");\n\nvar _fflush = Module[\"_fflush\"] = createExportWrapper(\"fflush\");\n\nvar _emscripten_main_thread_process_queued_calls = createExportWrapper(\"emscripten_main_thread_process_queued_calls\");\n\nvar _emscripten_main_runtime_thread_id = createExportWrapper(\"emscripten_main_runtime_thread_id\");\n\nvar __emscripten_run_in_main_runtime_thread_js = createExportWrapper(\"_emscripten_run_in_main_runtime_thread_js\");\n\nvar _emscripten_dispatch_to_thread_ = createExportWrapper(\"emscripten_dispatch_to_thread_\");\n\nvar _emscripten_stack_get_base = function() {\n return (_emscripten_stack_get_base = Module[\"asm\"][\"emscripten_stack_get_base\"]).apply(null, arguments);\n};\n\nvar _emscripten_stack_get_end = function() {\n return (_emscripten_stack_get_end = Module[\"asm\"][\"emscripten_stack_get_end\"]).apply(null, arguments);\n};\n\nvar __emscripten_thread_free_data = createExportWrapper(\"_emscripten_thread_free_data\");\n\nvar __emscripten_thread_exit = Module[\"__emscripten_thread_exit\"] = createExportWrapper(\"_emscripten_thread_exit\");\n\nvar __emscripten_check_mailbox = Module[\"__emscripten_check_mailbox\"] = createExportWrapper(\"_emscripten_check_mailbox\");\n\nvar ___trap = function() {\n return (___trap = Module[\"asm\"][\"__trap\"]).apply(null, arguments);\n};\n\nvar _emscripten_stack_init = function() {\n return (_emscripten_stack_init = Module[\"asm\"][\"emscripten_stack_init\"]).apply(null, arguments);\n};\n\nvar _emscripten_stack_set_limits = function() {\n return (_emscripten_stack_set_limits = Module[\"asm\"][\"emscripten_stack_set_limits\"]).apply(null, arguments);\n};\n\nvar _emscripten_stack_get_free = function() {\n return (_emscripten_stack_get_free = Module[\"asm\"][\"emscripten_stack_get_free\"]).apply(null, arguments);\n};\n\nvar stackSave = createExportWrapper(\"stackSave\");\n\nvar stackRestore = createExportWrapper(\"stackRestore\");\n\nvar stackAlloc = createExportWrapper(\"stackAlloc\");\n\nvar _emscripten_stack_get_current = function() {\n return (_emscripten_stack_get_current = Module[\"asm\"][\"emscripten_stack_get_current\"]).apply(null, arguments);\n};\n\nvar ___cxa_decrement_exception_refcount = Module[\"___cxa_decrement_exception_refcount\"] = createExportWrapper(\"__cxa_decrement_exception_refcount\");\n\nvar ___cxa_increment_exception_refcount = Module[\"___cxa_increment_exception_refcount\"] = createExportWrapper(\"__cxa_increment_exception_refcount\");\n\nvar ___thrown_object_from_unwind_exception = Module[\"___thrown_object_from_unwind_exception\"] = createExportWrapper(\"__thrown_object_from_unwind_exception\");\n\nvar ___get_exception_message = Module[\"___get_exception_message\"] = createExportWrapper(\"__get_exception_message\");\n\nvar dynCall_jiji = Module[\"dynCall_jiji\"] = createExportWrapper(\"dynCall_jiji\");\n\nvar dynCall_viijii = Module[\"dynCall_viijii\"] = createExportWrapper(\"dynCall_viijii\");\n\nvar dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = createExportWrapper(\"dynCall_iiiiij\");\n\nvar dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = createExportWrapper(\"dynCall_iiiiijj\");\n\nvar dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = createExportWrapper(\"dynCall_iiiiiijj\");\n\nModule[\"keepRuntimeAlive\"] = keepRuntimeAlive;\n\nModule[\"wasmMemory\"] = wasmMemory;\n\nModule[\"ExitStatus\"] = ExitStatus;\n\nModule[\"PThread\"] = PThread;\n\nvar missingLibrarySymbols = [ \"ydayFromDate\", \"setErrNo\", \"inetPton4\", \"inetNtop4\", \"inetPton6\", \"inetNtop6\", \"readSockaddr\", \"writeSockaddr\", \"getHostByName\", \"traverseStack\", \"getCallstack\", \"emscriptenLog\", \"convertPCtoSourceLocation\", \"readEmAsmArgs\", \"jstoi_q\", \"jstoi_s\", \"listenOnce\", \"autoResumeAudioContext\", \"runtimeKeepalivePop\", \"safeSetTimeout\", \"asmjsMangle\", \"getNativeTypeSize\", \"STACK_SIZE\", \"STACK_ALIGN\", \"POINTER_SIZE\", \"ASSERTIONS\", \"writeI53ToI64\", \"writeI53ToI64Clamped\", \"writeI53ToI64Signaling\", \"writeI53ToU64Clamped\", \"writeI53ToU64Signaling\", \"readI53FromI64\", \"readI53FromU64\", \"convertI32PairToI53\", \"convertU32PairToI53\", \"getCFunc\", \"ccall\", \"cwrap\", \"uleb128Encode\", \"sigToWasmTypes\", \"generateFuncType\", \"convertJsFunctionToWasm\", \"getEmptyTableSlot\", \"updateTableMap\", \"getFunctionAddress\", \"addFunction\", \"removeFunction\", \"reallyNegative\", \"unSign\", \"strLen\", \"reSign\", \"formatString\", \"intArrayToString\", \"AsciiToString\", \"stringToNewUTF8\", \"stringToUTF8OnStack\", \"getSocketFromFD\", \"getSocketAddress\", \"registerKeyEventCallback\", \"maybeCStringToJsString\", \"findEventTarget\", \"findCanvasEventTarget\", \"getBoundingClientRect\", \"fillMouseEventData\", \"registerMouseEventCallback\", \"registerWheelEventCallback\", \"registerUiEventCallback\", \"registerFocusEventCallback\", \"fillDeviceOrientationEventData\", \"registerDeviceOrientationEventCallback\", \"fillDeviceMotionEventData\", \"registerDeviceMotionEventCallback\", \"screenOrientation\", \"fillOrientationChangeEventData\", \"registerOrientationChangeEventCallback\", \"fillFullscreenChangeEventData\", \"registerFullscreenChangeEventCallback\", \"JSEvents_requestFullscreen\", \"JSEvents_resizeCanvasForFullscreen\", \"registerRestoreOldStyle\", \"hideEverythingExceptGivenElement\", \"restoreHiddenElements\", \"setLetterbox\", \"softFullscreenResizeWebGLRenderTarget\", \"doRequestFullscreen\", \"fillPointerlockChangeEventData\", \"registerPointerlockChangeEventCallback\", \"registerPointerlockErrorEventCallback\", \"requestPointerLock\", \"fillVisibilityChangeEventData\", \"registerVisibilityChangeEventCallback\", \"registerTouchEventCallback\", \"fillGamepadEventData\", \"registerGamepadEventCallback\", \"registerBeforeUnloadEventCallback\", \"fillBatteryEventData\", \"battery\", \"registerBatteryEventCallback\", \"setCanvasElementSizeCallingThread\", \"setCanvasElementSizeMainThread\", \"setCanvasElementSize\", \"getCanvasSizeCallingThread\", \"getCanvasSizeMainThread\", \"getCanvasElementSize\", \"jsStackTrace\", \"stackTrace\", \"checkWasiClock\", \"wasiRightsToMuslOFlags\", \"wasiOFlagsToMuslOFlags\", \"createDyncallWrapper\", \"setImmediateWrapped\", \"clearImmediateWrapped\", \"polyfillSetImmediate\", \"getPromise\", \"makePromise\", \"idsToPromises\", \"makePromiseCallback\", \"setMainLoop\", \"_setNetworkCallback\", \"heapObjectForWebGLType\", \"heapAccessShiftForWebGLHeap\", \"webgl_enable_ANGLE_instanced_arrays\", \"webgl_enable_OES_vertex_array_object\", \"webgl_enable_WEBGL_draw_buffers\", \"webgl_enable_WEBGL_multi_draw\", \"emscriptenWebGLGet\", \"computeUnpackAlignedImageSize\", \"colorChannelsInGlTextureFormat\", \"emscriptenWebGLGetTexPixelData\", \"__glGenObject\", \"emscriptenWebGLGetUniform\", \"webglGetUniformLocation\", \"webglPrepareUniformLocationsBeforeFirstUse\", \"webglGetLeftBracePos\", \"emscriptenWebGLGetVertexAttrib\", \"__glGetActiveAttribOrUniform\", \"writeGLArray\", \"emscripten_webgl_destroy_context_before_on_calling_thread\", \"registerWebGlEventCallback\", \"runAndAbortIfError\", \"SDL_unicode\", \"SDL_ttfContext\", \"SDL_audio\", \"GLFW_Window\", \"ALLOC_NORMAL\", \"ALLOC_STACK\", \"allocate\", \"writeStringToMemory\", \"writeAsciiToMemory\", \"registerInheritedInstance\", \"unregisterInheritedInstance\", \"validateThis\", \"getStringOrSymbol\", \"craftEmvalAllocator\", \"emval_get_global\", \"emval_allocateDestructors\", \"emval_addMethodCaller\" ];\n\nmissingLibrarySymbols.forEach(missingLibrarySymbol);\n\nvar unexportedSymbols = [ \"run\", \"addOnPreRun\", \"addOnInit\", \"addOnPreMain\", \"addOnExit\", \"addOnPostRun\", \"addRunDependency\", \"removeRunDependency\", \"FS_createFolder\", \"FS_createPath\", \"FS_createDataFile\", \"FS_createPreloadedFile\", \"FS_createLazyFile\", \"FS_createLink\", \"FS_createDevice\", \"FS_unlink\", \"out\", \"err\", \"callMain\", \"abort\", \"stackAlloc\", \"stackSave\", \"stackRestore\", \"getTempRet0\", \"setTempRet0\", \"GROWABLE_HEAP_I8\", \"GROWABLE_HEAP_U8\", \"GROWABLE_HEAP_I16\", \"GROWABLE_HEAP_U16\", \"GROWABLE_HEAP_I32\", \"GROWABLE_HEAP_U32\", \"GROWABLE_HEAP_F32\", \"GROWABLE_HEAP_F64\", \"writeStackCookie\", \"checkStackCookie\", \"ptrToString\", \"zeroMemory\", \"exitJS\", \"getHeapMax\", \"emscripten_realloc_buffer\", \"ENV\", \"MONTH_DAYS_REGULAR\", \"MONTH_DAYS_LEAP\", \"MONTH_DAYS_REGULAR_CUMULATIVE\", \"MONTH_DAYS_LEAP_CUMULATIVE\", \"isLeapYear\", \"arraySum\", \"addDays\", \"ERRNO_CODES\", \"ERRNO_MESSAGES\", \"DNS\", \"Protocols\", \"Sockets\", \"initRandomFill\", \"randomFill\", \"timers\", \"warnOnce\", \"UNWIND_CACHE\", \"readEmAsmArgsArray\", \"getExecutableName\", \"dynCallLegacy\", \"getDynCaller\", \"dynCall\", \"handleException\", \"runtimeKeepalivePush\", \"callUserCallback\", \"maybeExit\", \"asyncLoad\", \"alignMemory\", \"mmapAlloc\", \"HandleAllocator\", \"convertI32PairToI53Checked\", \"freeTableIndexes\", \"functionsInTableMap\", \"setValue\", \"getValue\", \"PATH\", \"PATH_FS\", \"UTF8Decoder\", \"UTF8ArrayToString\", \"UTF8ToString\", \"stringToUTF8Array\", \"stringToUTF8\", \"lengthBytesUTF8\", \"intArrayFromString\", \"stringToAscii\", \"UTF16Decoder\", \"UTF16ToString\", \"stringToUTF16\", \"lengthBytesUTF16\", \"UTF32ToString\", \"stringToUTF32\", \"lengthBytesUTF32\", \"writeArrayToMemory\", \"SYSCALLS\", \"JSEvents\", \"specialHTMLTargets\", \"currentFullscreenStrategy\", \"restoreOldWindowedStyle\", \"demangle\", \"demangleAll\", \"getEnvStrings\", \"doReadv\", \"doWritev\", \"dlopenMissingError\", \"promiseMap\", \"getExceptionMessageCommon\", \"getCppExceptionTag\", \"getCppExceptionThrownObjectFromWebAssemblyException\", \"incrementExceptionRefcount\", \"decrementExceptionRefcount\", \"getExceptionMessage\", \"Browser\", \"wget\", \"FS\", \"MEMFS\", \"TTY\", \"PIPEFS\", \"SOCKFS\", \"tempFixedLengthArray\", \"miniTempWebGLFloatBuffers\", \"miniTempWebGLIntBuffers\", \"GL\", \"emscripten_webgl_power_preferences\", \"AL\", \"GLUT\", \"EGL\", \"GLEW\", \"IDBStore\", \"SDL\", \"SDL_gfx\", \"GLFW\", \"allocateUTF8\", \"allocateUTF8OnStack\", \"terminateWorker\", \"killThread\", \"cleanupThread\", \"registerTLSInit\", \"cancelThread\", \"spawnThread\", \"exitOnMainThread\", \"proxyToMainThread\", \"emscripten_receive_on_main_thread_js_callArgs\", \"invokeEntryPoint\", \"checkMailbox\", \"InternalError\", \"BindingError\", \"UnboundTypeError\", \"PureVirtualError\", \"init_embind\", \"throwInternalError\", \"throwBindingError\", \"throwUnboundTypeError\", \"ensureOverloadTable\", \"exposePublicSymbol\", \"replacePublicSymbol\", \"extendError\", \"createNamedFunction\", \"embindRepr\", \"registeredInstances\", \"getBasestPointer\", \"getInheritedInstance\", \"getInheritedInstanceCount\", \"getLiveInheritedInstances\", \"registeredTypes\", \"awaitingDependencies\", \"typeDependencies\", \"registeredPointers\", \"registerType\", \"whenDependentTypesAreResolved\", \"embind_charCodes\", \"embind_init_charCodes\", \"readLatin1String\", \"getTypeName\", \"heap32VectorToArray\", \"requireRegisteredType\", \"getShiftFromSize\", \"integerReadValueFromPointer\", \"enumReadValueFromPointer\", \"floatReadValueFromPointer\", \"simpleReadValueFromPointer\", \"runDestructors\", \"newFunc\", \"craftInvokerFunction\", \"embind__requireFunction\", \"tupleRegistrations\", \"structRegistrations\", \"genericPointerToWireType\", \"constNoSmartPtrRawPointerToWireType\", \"nonConstNoSmartPtrRawPointerToWireType\", \"init_RegisteredPointer\", \"RegisteredPointer\", \"RegisteredPointer_getPointee\", \"RegisteredPointer_destructor\", \"RegisteredPointer_deleteObject\", \"RegisteredPointer_fromWireType\", \"runDestructor\", \"releaseClassHandle\", \"finalizationRegistry\", \"detachFinalizer_deps\", \"detachFinalizer\", \"attachFinalizer\", \"makeClassHandle\", \"init_ClassHandle\", \"ClassHandle\", \"ClassHandle_isAliasOf\", \"throwInstanceAlreadyDeleted\", \"ClassHandle_clone\", \"ClassHandle_delete\", \"deletionQueue\", \"ClassHandle_isDeleted\", \"ClassHandle_deleteLater\", \"flushPendingDeletes\", \"delayFunction\", \"setDelayFunction\", \"RegisteredClass\", \"shallowCopyInternalPointer\", \"downcastPointer\", \"upcastPointer\", \"char_0\", \"char_9\", \"makeLegalFunctionName\", \"emval_handles\", \"emval_symbols\", \"init_emval\", \"count_emval_handles\", \"Emval\", \"emval_newers\", \"emval_lookupTypes\", \"emval_methodCallers\", \"emval_registeredMethods\" ];\n\nunexportedSymbols.forEach(unexportedRuntimeSymbol);\n\nvar calledRun;\n\ndependenciesFulfilled = function runCaller() {\n if (!calledRun) run();\n if (!calledRun) dependenciesFulfilled = runCaller;\n};\n\nfunction stackCheckInit() {\n assert(!ENVIRONMENT_IS_PTHREAD);\n _emscripten_stack_init();\n writeStackCookie();\n}\n\nfunction run() {\n if (runDependencies > 0) {\n  return;\n }\n if (!ENVIRONMENT_IS_PTHREAD) stackCheckInit();\n if (ENVIRONMENT_IS_PTHREAD) {\n  readyPromiseResolve(Module);\n  initRuntime();\n  startWorker(Module);\n  return;\n }\n preRun();\n if (runDependencies > 0) {\n  return;\n }\n function doRun() {\n  if (calledRun) return;\n  calledRun = true;\n  Module[\"calledRun\"] = true;\n  if (ABORT) return;\n  initRuntime();\n  readyPromiseResolve(Module);\n  if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n  assert(!Module[\"_main\"], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n  postRun();\n }\n if (Module[\"setStatus\"]) {\n  Module[\"setStatus\"](\"Running...\");\n  setTimeout(function() {\n   setTimeout(function() {\n    Module[\"setStatus\"](\"\");\n   }, 1);\n   doRun();\n  }, 1);\n } else {\n  doRun();\n }\n checkStackCookie();\n}\n\nfunction checkUnflushedContent() {\n var oldOut = out;\n var oldErr = err;\n var has = false;\n out = err = x => {\n  has = true;\n };\n try {\n  _fflush(0);\n  [ \"stdout\", \"stderr\" ].forEach(function(name) {\n   var info = FS.analyzePath(\"/dev/\" + name);\n   if (!info) return;\n   var stream = info.object;\n   var rdev = stream.rdev;\n   var tty = TTY.ttys[rdev];\n   if (tty && tty.output && tty.output.length) {\n    has = true;\n   }\n  });\n } catch (e) {}\n out = oldOut;\n err = oldErr;\n if (has) {\n  warnOnce(\"stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.\");\n }\n}\n\nif (Module[\"preInit\"]) {\n if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [ Module[\"preInit\"] ];\n while (Module[\"preInit\"].length > 0) {\n  Module[\"preInit\"].pop()();\n }\n}\n\nrun();\n\n\n  return CASModule.ready\n}\n\n);\n})();\nexport default CASModule;","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"32MbT\")).toString();","\"use strict\";\n\nvar mapping = {};\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping[id];\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return resolved;\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","let workerURL = require('./helpers/get-worker-url');\nlet url = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"ewdRd\"));\nmodule.exports = workerURL(url.toString(), url.origin, true);","\"use strict\";\n\nmodule.exports = function (workerUrl, origin, isESM) {\n  if (origin === self.location.origin) {\n    // If the worker bundle's url is on the same origin as the document,\n    // use the worker bundle's own url.\n    return workerUrl;\n  } else {\n    // Otherwise, create a blob URL which loads the worker bundle with `importScripts`.\n    var source = isESM ? 'import ' + JSON.stringify(workerUrl) + ';' : 'importScripts(' + JSON.stringify(workerUrl) + ');';\n    return URL.createObjectURL(new Blob([source], {\n      type: 'application/javascript'\n    }));\n  }\n};"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","value","$1624ce41e04aea51$export$2e2bcd8739ae039","_scriptDir","$ifEks","CASModule","GROWABLE_HEAP_I8","wasmMemory","buffer","HEAP8","updateMemoryViews","GROWABLE_HEAP_U8","HEAPU8","GROWABLE_HEAP_I16","HEAP16","GROWABLE_HEAP_U16","HEAPU16","GROWABLE_HEAP_I32","HEAP32","GROWABLE_HEAP_U32","HEAPU32","GROWABLE_HEAP_F64","HEAPF64","prop","sym","readyPromiseResolve","readyPromiseReject","read_","readAsync","readBinary","wasmBinary","wasmModule","EXITSTATUS","HEAPF32","wasmTable","wasmBinaryFile","tempDouble","tempI64","calledRun","Module","Promise","resolve","reject","forEach","getOwnPropertyDescriptor","abort","moduleOverrides","assign","thisProgram","quit_","status","toThrow","ENVIRONMENT_IS_WEB","ENVIRONMENT_IS_WORKER","importScripts","ENVIRONMENT_IS_NODE","versions","node","ENVIRONMENT_IS_SHELL","ENVIRONMENT_IS_PTHREAD","scriptDirectory","locateFile","path","read","f","data","readbuffer","Uint8Array","assert","onload","onerror","setTimeout","clearTimeout","scriptArgs","arguments","quit","ExitStatus","toLog","stack","print","console","log","warn","error","printErr","location","href","document","currentScript","src","indexOf","substr","replace","lastIndexOf","url","xhr","XMLHttpRequest","open","send","responseText","responseType","response","out","bind","legacyModuleProp","noExitRuntime","WebAssembly","ABORT","condition","text","b","Int8Array","Int16Array","Int32Array","Uint16Array","Uint32Array","Float32Array","Float64Array","undefined","prototype","subarray","INITIAL_MEMORY","Memory","SharedArrayBuffer","writeStackCookie","max","_emscripten_stack_get_end","checkStackCookie","cookie1","cookie2","ptrToString","byteLength","h16","h8","__ATPRERUN__","__ATINIT__","__ATPOSTRUN__","runtimeInitialized","runtimeKeepaliveCounter","keepRuntimeAlive","initRuntime","FS","initialized","ignorePermissions","TTY","callRuntimeCallbacks","Math","imul","fround","clz32","trunc","runDependencies","runDependencyWatcher","dependenciesFulfilled","runDependencyTracking","getUniqueRunDependency","orig","random","addRunDependency","setInterval","clearInterval","shown","dep","removeRunDependency","callback","what","___trap","RuntimeError","isDataURI","filename","startsWith","createExportWrapper","name","fixedasm","asm","apply","getBinary","file","instantiateArrayBuffer","binaryFile","imports","receiver","getBinaryPromise","fetch","credentials","then","catch","binary","instantiate","instance","reason","newName","isExportedByForceFilesystem","unexportedRuntimeSymbol","msg","dbg","message","terminateWorker","worker","terminate","onmessage","workerID","cleanupThread","pthread_ptr","PThread","pthreads","returnWorkerToPool","spawnThread","threadParams","getNewWorker","runningWorkers","push","startRoutine","arg","postMessage","transferList","URL","warnOnce","PATH","isAbs","charAt","splitPath","splitPathRe","exec","slice","normalizeArray","parts","allowAboveRoot","up","i","length","last","splice","unshift","normalize","isAbsolute","trailingSlash","split","filter","p","join","dirname","result","root","dir","basename","lastSlash","paths","Array","join2","l","r","randomFill","view","initRandomFill","crypto","getRandomValues","PATH_FS","resolvedPath","resolvedAbsolute","cwd","TypeError","relative","from","to","trim","arr","start","end","fromParts","toParts","min","samePartsLength","outputParts","concat","lengthBytesUTF8","str","len","c","charCodeAt","stringToUTF8Array","heap","outIdx","maxBytesToWrite","startIdx","endIdx","u","u1","intArrayFromString","stringy","dontAddNull","u8array","numBytesWritten","ttys","shutdown","dev","ops","input","output","registerDevice","stream_ops","stream","tty","rdev","ErrnoError","seekable","close","fsync","offset","pos","get_char","bytesRead","timestamp","Date","now","write","put_char","default_tty_ops","prompt","readline","shift","val","UTF8ArrayToString","default_tty1_ops","mmapAlloc","size","MEMFS","ops_table","mount","createNode","parent","mode","isBlkdev","isFIFO","getattr","node_ops","setattr","lookup","mknod","rename","unlink","rmdir","readdir","symlink","llseek","allocate","mmap","msync","link","readlink","chrdev","chrdev_stream_ops","isDir","contents","isFile","usedBytes","isLink","isChrdev","getFileDataAsTypedArray","expandFileStorage","newCapacity","prevCapacity","oldContents","resizeFileStorage","newSize","attr","ino","nlink","uid","gid","atime","mtime","ctime","blksize","blocks","ceil","genericErrors","old_node","new_dir","new_name","new_node","lookupNode","entries","key","hasOwnProperty","newname","oldpath","position","canOwn","ArrayBuffer","whence","prot","flags","ptr","allocated","byteOffset","mmapFlags","ERRNO_MESSAGES","ERRNO_CODES","mounts","devices","streams","nextInode","nameTable","currentPath","filesystems","syncFSRequests","lookupPath","opts","follow_mount","recurse_count","current","current_path","islast","isMountpoint","mounted","follow","count","getPath","isRoot","mountpoint","hashName","parentid","hash","hashAddNode","name_next","hashRemoveNode","errCode","mayLookup","nodeName","FSNode","destroyNode","isSocket","flagModes","modeStringToFlags","flagsToPermissionString","flag","perms","nodePermissions","includes","mayCreate","mayDelete","isdir","errno","mayOpen","MAX_OPEN_FDS","nextfd","fd_start","fd_end","fd","getStream","createStream","FSStream","shared","defineProperties","object","isRead","isWrite","isAppend","closeStream","device","getDevice","major","minor","makedev","ma","mi","getMounts","check","m","pop","syncfs","populate","completed","doCallback","done","errored","type","pseudo","mountRoot","unmount","keys","next","idx","create","mkdir","mkdirTree","dirs","d","mkdev","newpath","old_path","new_path","old_dir","old_dirname","new_dirname","old_name","stat","dontFollow","lstat","chmod","lchmod","fchmod","chown","lchown","fchown","truncate","ftruncate","utime","created","ungotten","readFiles","isClosed","getdents","seeking","bytesWritten","munmap","ioctl","cmd","readFile","encoding","ret","buf","writeFile","actualNumBytes","isView","chdir","createDefaultDirectories","createDefaultDevices","randomBuffer","randomLeft","randomByte","createDevice","createSpecialDirectories","proc_self","createStandardStreams","stdin","stdout","stderr","ensureErrnoError","setErrno","writable","x","y","constructor","staticInit","_fflush","getMode","canRead","canWrite","findObject","dontResolveLastLink","analyzePath","exists","parentExists","parentPath","parentObject","createPath","reverse","part","createFile","properties","createDataFile","forceLoadFile","obj","isDevice","isFolder","createLazyFile","LazyUint8Array","lengthKnown","chunks","chunkOffset","chunkSize","chunkNum","getter","setDataGetter","cacheLength","header","datalength","Number","getResponseHeader","hasByteServing","usesGzip","doXHR","setRequestHeader","overrideMimeType","lazyArray","_length","_chunkSize","writeChunks","fn","createPreloadedFile","dontCreateFile","preFinish","fullname","processData","byteArray","finish","Browser","handledByPreloadPlugin","arrayBuffer","event","absolutePath","createFolder","createLink","joinPath","standardizePath","UTF8Decoder","TextDecoder","heapOrArray","maxBytesToRead","endPtr","decode","u0","String","fromCharCode","u2","ch","UTF8ToString","SYSCALLS","DEFAULT_POLLMASK","calculateAt","dirfd","allowEmpty","dirstream","getStreamFromFD","doStat","func","abs","floor","getTime","doMsync","addr","varargs","getStr","_proc_exit","proxyToMainThread","terminateAllThreads","_exit","implicit","checkUnflushedContent","oldOut","oldErr","has","info","exitOnMainThread","toString","padStart","handleException","_emscripten_stack_get_current","unusedWorkers","tlsInitFunctions","nextWorkerID","debugInit","origDbg","t","pthreadLogPrefix","_pthread_self","initWorker","initMainThread","pthreadPoolSize","navigator","hardwareConcurrency","allocateUnusedWorker","setExitStatus","terminateAllThreads__deps","__emscripten_thread_free_data","receiveObjectTransfer","threadInitTLS","loadWasmModuleToWorker","onFinishedLoading","currentProxiedOperationCallerThread","targetWorker","targetThread","checkMailbox","loaded","alert","target","lineno","handlers","handler","loadWasmModuleToAllWorkers","onMaybeReady","pthreadPoolReady","all","map","pthreadMainJs","Worker","callbacks","getCppExceptionTag","returnCode","withStackSave","stackSave","stackRestore","getExceptionMessage","ex","___thrown_object_from_unwind_exception","getArg","type_addr_addr","stackAlloc","message_addr_addr","___get_exception_message","type_addr","message_addr","_free","stackTop","stackMax","_emscripten_stack_set_limits","wasmTableMirror","getWasmTableEntry","funcPtr","pthreadCreateProxied","___pthread_create_js","getShiftFromSize","__emscripten_thread_exit","embind_charCodes","readLatin1String","awaitingDependencies","registeredTypes","typeDependencies","makeLegalFunctionName","createNamedFunction","body","extendError","baseErrorType","errorName","errorClass","BindingError","throwBindingError","InternalError","throwInternalError","whenDependentTypesAreResolved","myTypes","dependentTypes","getTypeConverters","onComplete","typeConverters","myTypeConverters","registerType","unregisteredTypes","registered","dt","rawType","registeredInstance","options","ignoreDuplicateRegistrations","cb","throwInstanceAlreadyDeleted","getInstanceTypeName","handle","$$","ptrType","registeredClass","finalizationRegistry","detachFinalizer","releaseClassHandle","smartPtr","smartPtrType","rawDestructor","registeredPointers","deletionQueue","flushPendingDeletes","deleteScheduled","delayFunction","registeredInstances","makeClassHandle","record","attachFinalizer","RegisteredPointer_fromWireType","toType","rawPointer","getPointee","destructor","getBasestPointer","class_","baseClass","upcast","rv","makeDefaultHandle","isSmartPointer","instancePrototype","pointeeType","registeredPointerRecord","getActualType","isConst","constPointerType","pointerType","dp","downcastPointer","ptrClass","desiredClass","downcast","FinalizationRegistry","leakWarning","cls","captureStackTrace","unregister","ClassHandle","ensureOverloadTable","proto","methodName","humanName","overloadTable","prevFunc","argCount","exposePublicSymbol","numArguments","RegisteredClass","pureVirtualFunctions","upcastPointer","constNoSmartPtrRawPointerToWireType","destructors","isReference","embindRepr","handleClass","genericPointerToWireType","rawConstructor","sharingPolicy","clonedHandle","rawShare","Emval","toHandle","nonConstNoSmartPtrRawPointerToWireType","simpleReadValueFromPointer","pointer","RegisteredPointer","rawGetPointee","destructorFunction","embind__requireFunction","signature","rawFunction","fp","makeDynCaller","sig","argCache","dynCall","args","substring","UnboundTypeError","getTypeName","___getTypeName","throwUnboundTypeError","types","unboundTypes","seen","visit","heap32VectorToArray","firstElement","array","runDestructors","del","craftInvokerFunction","argTypes","classType","cppInvokerFunc","cppTargetFunc","isAsync","isClassMethodFunc","needsDestructorStack","returns","argsList","argsListWired","invokerFnBody","dtorStack","args1","args2","paramName","newFunc","argumentList","Function","dummy","emval_handles","freelist","free","__emval_decref","reserved","refcount","toValue","requireRegisteredType","impl","UTF16Decoder","UTF16ToString","maxIdx","codeUnit","stringToUTF16","outPtr","startPtr","numCharsToWrite","lengthBytesUTF16","UTF32ToString","utf32","stringToUTF32","trailSurrogate","lengthBytesUTF32","__emscripten_thread_mailbox_await","Atomics","waitAsync","wait","async","waitingAsync","store","callUserCallback","maybeExit","__emscripten_check_mailbox","getHeapMax","index","sync","numCallArgs","outerArgs","serializedNumCallArgs","__emscripten_run_in_main_runtime_thread_js","emscripten_receive_on_main_thread_js_callArgs","ENV","getEnvStrings","strings","env","languages","_environ_get","__environ","environ_buf","bufSize","string","stringToAscii","_environ_sizes_get","penviron_count","penviron_buf_size","_fd_close","_fd_read","iov","iovcnt","pnum","num","doReadv","curr","_fd_seek","offset_low","offset_high","newOffset","lo","hi","NaN","isNaN","_fd_write","doWritev","isLeapYear","year","MONTH_DAYS_LEAP","MONTH_DAYS_REGULAR","embind_init_charCodes","codes","other","leftClass","left","rightClass","right","preservePointerOnDelete","o","clone","getPrototypeOf","k","proxiedFunctionTable","wasmImports","line","tb","__emscripten_thread_init","thread","Exception","traceStack","primitiveType","minRange","maxRange","trueValue","falseValue","wt","rawPointerType","rawConstPointerType","baseClassRawType","getActualTypeSignature","upcastSignature","downcastSignature","destructorSignature","legalFunctionName","base","basePrototype","constructor_body","referenceConverter","pointerConverter","constPointerConverter","rawClassType","rawArgTypesAddr","invokerSignature","invoker","rawArgTypes","rawInvoker","context","isPureVirtual","unboundTypesHandler","Symbol","method","className","memberFunction","isSigned","ctor","values","enumReadValueFromPointer","signed","rawEnumType","enumValue","enumType","Enum","Value","floatReadValueFromPointer","GROWABLE_HEAP_F32","fromWireType","bitshift","isUnsignedType","checkAssertions","toTypeName","integerReadValueFromPointer","dataTypeIndex","TA","typeMapping","decodeMemoryView","rawPointeeType","getPointeeSignature","constructorSignature","shareSignature","stdStringIsUTF8","payload","decodeStartPtr","currentBytePtr","maxRead","stringSegment","a","valueIsOfTypeString","Uint8ClampedArray","_malloc","charCode","charSize","decodeString","encodeString","getHeap","lengthBytesUTF","HEAP","maxReadBytes","isVoid","targetThreadId","currThreadId","mainThreadId","width","height","argv","emval_lookupTypes","performance","timeOrigin","requestedSize","oldSize","maxHeapSize","alignUp","multiple","cutDown","overGrownHeapSize","emscripten_realloc_buffer","grow","maxsize","format","tm","loc","_strftime","tm_zone","date","tm_sec","tm_min","tm_hour","tm_mday","tm_mon","tm_year","tm_wday","tm_yday","tm_isdst","tm_gmtoff","pattern","EXPANSION_RULES_1","rule","RegExp","WEEKDAYS","MONTHS","leadingSomething","digits","character","leadingNulls","compareByDay","date1","date2","compare","sgn","getFullYear","getMonth","getDate","getFirstWeekStartDate","janFourth","getDay","getWeekBasedYear","thisDate","addDays","days","newDate","leap","currentMonth","daysInCurrentMonth","setDate","setMonth","setFullYear","janFourthThisYear","janFourthNextYear","firstWeekStartThisYear","firstWeekStartNextYear","EXPANSION_RULES_2","twelveHour","arraySum","sum","jan1","dec31","off","ahead","bytes","createWasm","receiveInstance","tlsInitFunc","trueModule","instantiateAsync","instantiateStreaming","_emscripten_stack_init","run","startWorker","preRun","addOnPreRun","doRun","postRun","addOnPostRun","missingLibrarySymbols","librarySymbol","unexportedSymbols","runCaller","ready","$d498e9313a10ad19$var$cachedSetTimeout","$d498e9313a10ad19$var$cachedClearTimeout","$d498e9313a10ad19$var$currentQueue","$d498e9313a10ad19$var$process","$d498e9313a10ad19$var$defaultSetTimout","$d498e9313a10ad19$var$defaultClearTimeout","$d498e9313a10ad19$var$runTimeout","fun","$d498e9313a10ad19$var$queue","$d498e9313a10ad19$var$draining","$d498e9313a10ad19$var$queueIndex","$d498e9313a10ad19$var$cleanUpNextTick","$d498e9313a10ad19$var$drainQueue","timeout","$d498e9313a10ad19$var$runClearTimeout","marker","$d498e9313a10ad19$var$Item","$d498e9313a10ad19$var$noop","nextTick","title","browser","version","on","addListener","once","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","umask","$5671419489ba846d$export$f7ad0328861e2f03","$5671419489ba846d$var$mapping","resolved","$1x9v7","$a731eb7672816d7e$var$url","origin","workerUrl","isESM","source","JSON","stringify","createObjectURL","Blob"],"version":3,"file":"cas.662c88d0.js.map"}