{"mappings":"AOUA,c,A,S,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,I,C,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,E,G,E,C,I,E,E,E,A,C,U,O,S,A,a,O,O,O,O,C,E,A,Y,O,Q,O,G,C,O,W,O,C,G,G,C,I,C,E,C,C,C,C,E,C,M,C,S,C,C,C,C,C,ENVA,EAAQ,mBAA6B,QAAA,CAAS,KAAK,KAAA,CAAM,+I,E,C,kB,O,E,C,Q,C,S,C,C,C,C,C,ECEzD,IAAI,EAAU,CAAC,CAcf,CAAA,EAAO,OAAA,CAAQ,QAAA,CAbf,SAAkB,CAAK,EAErB,IAAK,IADD,EAAO,OAAO,IAAA,CAAK,GACd,EAAI,EAAG,EAAI,EAAK,MAAA,CAAQ,IAC/B,CAAO,CAAC,CAAI,CAAC,EAAE,CAAC,CAAG,CAAK,CAAC,CAAI,CAAC,EAAE,CAAC,AAErC,EASA,EAAO,OAAA,CAAQ,OAAA,CARf,SAAiB,CAAE,EACjB,IAAI,EAAW,CAAO,CAAC,EAAG,CAC1B,GAAI,AAAY,MAAZ,EACF,MAAM,AAAI,MAAM,oCAAsC,GAExD,OAAO,CACT,C,E,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","sources":["<anon>","node_modules/@parcel/runtime-js/lib/runtime-073cbac47db28e29.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-a8b9ef8d5939a40a.js","node_modules/@parcel/runtime-js/lib/helpers/worker/js-loader.js","node_modules/@parcel/runtime-js/lib/helpers/cacheLoader.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-url.js","cas.worker.js"],"sourcesContent":["// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, entry, mainEntry, parcelRequireName, globalName) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        this\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n\n      // <script>\n    } else if (globalName) {\n      this[globalName] = mainExports;\n    }\n  }\n})({\"c1eUl\":[function(require,module,exports) {\nrequire(\"535a075ca2f7da4\").register(JSON.parse('{\"fmjgk\":\"cas.worker.bbc349ae.js\",\"iDbWQ\":\"cas.455f5503.js\",\"46jC9\":\"cas.0fe01122.wasm\"}'));\n\n},{\"535a075ca2f7da4\":\"3XjX9\"}],\"3XjX9\":[function(require,module,exports) {\n\"use strict\";\nvar mapping = {};\nfunction register(pairs) {\n    var keys = Object.keys(pairs);\n    for(var i = 0; i < keys.length; i++)mapping[keys[i]] = pairs[keys[i]];\n}\nfunction resolve(id) {\n    var resolved = mapping[id];\n    if (resolved == null) throw new Error(\"Could not resolve bundle with id \" + id);\n    return resolved;\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;\n\n},{}],\"jONXl\":[function(require,module,exports) {\nmodule.exports = require(\"2a05d033d048b206\")(require(\"13874220cc51d4af\").getBundleURL(\"fmjgk\") + require(\"6b91737a153ca092\").resolve(\"iDbWQ\")).then(()=>module.bundle.root(\"jUHhM\"));\n\n},{\"2a05d033d048b206\":\"1HJmv\",\"13874220cc51d4af\":\"6Efu8\",\"6b91737a153ca092\":\"3XjX9\"}],\"1HJmv\":[function(require,module,exports) {\n\"use strict\";\n/* global __parcel__importScripts__:readonly*/ var cacheLoader = require(\"e18e0f4b8102d3ab\");\nmodule.exports = cacheLoader(function(bundle) {\n    return new Promise(function(resolve, reject) {\n        try {\n            importScripts(bundle);\n            resolve();\n        } catch (e) {\n            reject(e);\n        }\n    });\n});\n\n},{\"e18e0f4b8102d3ab\":\"ewGmr\"}],\"ewGmr\":[function(require,module,exports) {\n\"use strict\";\nvar cachedBundles = {};\nvar cachedPreloads = {};\nvar cachedPrefetches = {};\nfunction getCache(type) {\n    switch(type){\n        case \"preload\":\n            return cachedPreloads;\n        case \"prefetch\":\n            return cachedPrefetches;\n        default:\n            return cachedBundles;\n    }\n}\nmodule.exports = function(loader, type) {\n    return function(bundle) {\n        var cache = getCache(type);\n        if (cache[bundle]) return cache[bundle];\n        return cache[bundle] = loader.apply(null, arguments).catch(function(e) {\n            delete cache[bundle];\n            throw e;\n        });\n    };\n};\n\n},{}],\"6Efu8\":[function(require,module,exports) {\n\"use strict\";\nvar bundleURL = {};\nfunction getBundleURLCached(id) {\n    var value = bundleURL[id];\n    if (!value) {\n        value = getBundleURL();\n        bundleURL[id] = value;\n    }\n    return value;\n}\nfunction getBundleURL() {\n    try {\n        throw new Error();\n    } catch (err) {\n        var matches = (\"\" + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^)\\n]+/g);\n        if (matches) // The first two stack frames will be this function and getBundleURLCached.\n        // Use the 3rd one, which will be a runtime in the original bundle.\n        return getBaseURL(matches[2]);\n    }\n    return \"/\";\n}\nfunction getBaseURL(url) {\n    return (\"\" + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/.+)\\/[^/]+$/, \"$1\") + \"/\";\n}\n// TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\nfunction getOrigin(url) {\n    var matches = (\"\" + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^/]+/);\n    if (!matches) throw new Error(\"Origin not found\");\n    return matches[0];\n}\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;\n\n},{}]},[\"c1eUl\"], null, \"parcelRequire94c2\")\n/**\n * @license\n * Copyright 2015 The Emscripten Authors\n * SPDX-License-Identifier: MIT\n */ // Pthread Web Worker startup routine:\n// This is the entry point file that is loaded first by each Web Worker\n// that executes pthreads on the Emscripten application.\n\"use strict\";\nvar Module = {};\n// Thread-local guard variable for one-time init of the JS state\nvar initializedJS = false;\nfunction assert(condition, text) {\n    if (!condition) abort(\"Assertion failed: \" + text);\n}\nfunction threadPrintErr() {\n    var text = Array.prototype.slice.call(arguments).join(\" \");\n    console.error(text);\n}\nfunction threadAlert() {\n    var text = Array.prototype.slice.call(arguments).join(\" \");\n    postMessage({\n        cmd: \"alert\",\n        text: text,\n        threadId: Module[\"_pthread_self\"]()\n    });\n}\n// We don't need out() for now, but may need to add it if we want to use it\n// here. Or, if this code all moves into the main JS, that problem will go\n// away. (For now, adding it here increases code size for no benefit.)\nvar out = ()=>{\n    throw \"out() is not defined in worker.js.\";\n};\nvar err = threadPrintErr;\nself.alert = threadAlert;\nModule[\"instantiateWasm\"] = (info, receiveInstance)=>{\n    // Instantiate from the module posted from the main thread.\n    // We can just use sync instantiation in the worker.\n    var module = Module[\"wasmModule\"];\n    // We don't need the module anymore; new threads will be spawned from the main thread.\n    Module[\"wasmModule\"] = null;\n    var instance = new WebAssembly.Instance(module, info);\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193,\n    // the above line no longer optimizes out down to the following line.\n    // When the regression is fixed, we can remove this if/else.\n    return receiveInstance(instance);\n};\n// Turn unhandled rejected promises into errors so that the main thread will be\n// notified about them.\nself.onunhandledrejection = (e)=>{\n    throw e.reason ?? e;\n};\nfunction handleMessage(e) {\n    try {\n        if (e.data.cmd === \"load\") {\n            // Until we initialize the runtime, queue up any further incoming messages.\n            let messageQueue = [];\n            self.onmessage = (e)=>messageQueue.push(e);\n            // And add a callback for when the runtime is initialized.\n            self.startWorker = (instance)=>{\n                Module = instance;\n                // Notify the main thread that this thread has loaded.\n                postMessage({\n                    \"cmd\": \"loaded\"\n                });\n                // Process any messages that were queued before the thread was ready.\n                for (let msg of messageQueue)handleMessage(msg);\n                // Restore the real message handler.\n                self.onmessage = handleMessage;\n            };\n            // Module and memory were sent from main thread\n            Module[\"wasmModule\"] = e.data.wasmModule;\n            // Use `const` here to ensure that the variable is scoped only to\n            // that iteration, allowing safe reference from a closure.\n            for (const handler of e.data.handlers)Module[handler] = function() {\n                postMessage({\n                    cmd: \"callHandler\",\n                    handler,\n                    args: [\n                        ...arguments\n                    ]\n                });\n            };\n            Module[\"wasmMemory\"] = e.data.wasmMemory;\n            Module[\"buffer\"] = Module[\"wasmMemory\"].buffer;\n            Module[\"workerID\"] = e.data.workerID;\n            Module[\"ENVIRONMENT_IS_PTHREAD\"] = true;\n            (e.data.urlOrBlob ? __parcel__require__(e.data.urlOrBlob) : parcelRequire94c2(\"jONXl\")).then((exports)=>exports.default(Module));\n        } else if (e.data.cmd === \"run\") {\n            // Pass the thread address to wasm to store it for fast access.\n            Module[\"__emscripten_thread_init\"](e.data.pthread_ptr, /*isMainBrowserThread=*/ 0, /*isMainRuntimeThread=*/ 0, /*canBlock=*/ 1);\n            // Await mailbox notifications with `Atomics.waitAsync` so we can start\n            // using the fast `Atomics.notify` notification path.\n            Module[\"__emscripten_thread_mailbox_await\"](e.data.pthread_ptr);\n            assert(e.data.pthread_ptr);\n            // Also call inside JS module to set up the stack frame for this pthread in JS module scope\n            Module[\"establishStackSpace\"]();\n            Module[\"PThread\"].receiveObjectTransfer(e.data);\n            Module[\"PThread\"].threadInitTLS();\n            if (!initializedJS) {\n                // Embind must initialize itself on all threads, as it generates support JS.\n                // We only do this once per worker since they get reused\n                Module[\"__embind_initialize_bindings\"]();\n                initializedJS = true;\n            }\n            try {\n                Module[\"invokeEntryPoint\"](e.data.start_routine, e.data.arg);\n            } catch (ex) {\n                if (ex != \"unwind\") // The pthread \"crashed\".  Do not call `_emscripten_thread_exit` (which\n                // would make this thread joinable).  Instead, re-throw the exception\n                // and let the top level handler propagate it back to the main thread.\n                throw ex;\n            }\n        } else if (e.data.cmd === \"cancel\") {\n            if (Module[\"_pthread_self\"]()) Module[\"__emscripten_thread_exit\"](-1);\n        } else if (e.data.target === \"setimmediate\") ;\n        else if (e.data.cmd === \"checkMailbox\") {\n            if (initializedJS) Module[\"checkMailbox\"]();\n        } else if (e.data.cmd) {\n            // The received message looks like something that should be handled by this message\n            // handler, (since there is a e.data.cmd field present), but is not one of the\n            // recognized commands:\n            err(\"worker.js received unknown command \" + e.data.cmd);\n            err(e.data);\n        }\n    } catch (ex) {\n        err(\"worker.js onmessage() captured an uncaught exception: \" + ex);\n        if (ex && ex.stack) err(ex.stack);\n        if (Module[\"__emscripten_thread_crashed\"]) Module[\"__emscripten_thread_crashed\"]();\n        throw ex;\n    }\n}\nself.onmessage = handleMessage;\n\n//# sourceMappingURL=cas.worker.bbc349ae.js.map\n","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"fmjgk\\\":\\\"cas.worker.bbc349ae.js\\\",\\\"iDbWQ\\\":\\\"cas.455f5503.js\\\",\\\"46jC9\\\":\\\"cas.0fe01122.wasm\\\"}\"));","\"use strict\";\n\nvar mapping = {};\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping[id];\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return resolved;\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","module.exports = (require(\"./helpers/worker/js-loader\")(require('./helpers/bundle-url').getBundleURL('fmjgk') + require('./helpers/bundle-manifest').resolve(\"iDbWQ\"))).then(() => module.bundle.root('jUHhM'));","\"use strict\";\n\n/* global __parcel__importScripts__:readonly*/\nvar cacheLoader = require('../cacheLoader');\nmodule.exports = cacheLoader(function (bundle) {\n  return new Promise(function (resolve, reject) {\n    try {\n      __parcel__importScripts__(bundle);\n      resolve();\n    } catch (e) {\n      reject(e);\n    }\n  });\n});","\"use strict\";\n\nvar cachedBundles = {};\nvar cachedPreloads = {};\nvar cachedPrefetches = {};\nfunction getCache(type) {\n  switch (type) {\n    case 'preload':\n      return cachedPreloads;\n    case 'prefetch':\n      return cachedPrefetches;\n    default:\n      return cachedBundles;\n  }\n}\nmodule.exports = function (loader, type) {\n  return function (bundle) {\n    var cache = getCache(type);\n    if (cache[bundle]) {\n      return cache[bundle];\n    }\n    return cache[bundle] = loader.apply(null, arguments).catch(function (e) {\n      delete cache[bundle];\n      throw e;\n    });\n  };\n};","\"use strict\";\n\nvar bundleURL = {};\nfunction getBundleURLCached(id) {\n  var value = bundleURL[id];\n  if (!value) {\n    value = getBundleURL();\n    bundleURL[id] = value;\n  }\n  return value;\n}\nfunction getBundleURL() {\n  try {\n    throw new Error();\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^)\\n]+/g);\n    if (matches) {\n      // The first two stack frames will be this function and getBundleURLCached.\n      // Use the 3rd one, which will be a runtime in the original bundle.\n      return getBaseURL(matches[2]);\n    }\n  }\n  return '/';\n}\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n}\n\n// TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\nfunction getOrigin(url) {\n  var matches = ('' + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^/]+/);\n  if (!matches) {\n    throw new Error('Origin not found');\n  }\n  return matches[0];\n}\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;","/**\n * @license\n * Copyright 2015 The Emscripten Authors\n * SPDX-License-Identifier: MIT\n */\n\n// Pthread Web Worker startup routine:\n// This is the entry point file that is loaded first by each Web Worker\n// that executes pthreads on the Emscripten application.\n\n'use strict';\n\nvar Module = {};\n\n// Thread-local guard variable for one-time init of the JS state\nvar initializedJS = false;\n\nfunction assert(condition, text) {\n  if (!condition) abort('Assertion failed: ' + text);\n}\n\nfunction threadPrintErr() {\n  var text = Array.prototype.slice.call(arguments).join(' ');\n  console.error(text);\n}\nfunction threadAlert() {\n  var text = Array.prototype.slice.call(arguments).join(' ');\n  postMessage({cmd: 'alert', text: text, threadId: Module['_pthread_self']()});\n}\n// We don't need out() for now, but may need to add it if we want to use it\n// here. Or, if this code all moves into the main JS, that problem will go\n// away. (For now, adding it here increases code size for no benefit.)\nvar out = () => { throw 'out() is not defined in worker.js.'; }\nvar err = threadPrintErr;\nself.alert = threadAlert;\n\nModule['instantiateWasm'] = (info, receiveInstance) => {\n  // Instantiate from the module posted from the main thread.\n  // We can just use sync instantiation in the worker.\n  var module = Module['wasmModule'];\n  // We don't need the module anymore; new threads will be spawned from the main thread.\n  Module['wasmModule'] = null;\n  var instance = new WebAssembly.Instance(module, info);\n  // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193,\n  // the above line no longer optimizes out down to the following line.\n  // When the regression is fixed, we can remove this if/else.\n  return receiveInstance(instance);\n}\n\n// Turn unhandled rejected promises into errors so that the main thread will be\n// notified about them.\nself.onunhandledrejection = (e) => {\n  throw e.reason ?? e;\n};\n\nfunction handleMessage(e) {\n  try {\n    if (e.data.cmd === 'load') { // Preload command that is called once per worker to parse and load the Emscripten code.\n\n    // Until we initialize the runtime, queue up any further incoming messages.\n    let messageQueue = [];\n    self.onmessage = (e) => messageQueue.push(e);\n\n    // And add a callback for when the runtime is initialized.\n    self.startWorker = (instance) => {\n      Module = instance;\n      // Notify the main thread that this thread has loaded.\n      postMessage({ 'cmd': 'loaded' });\n      // Process any messages that were queued before the thread was ready.\n      for (let msg of messageQueue) {\n        handleMessage(msg);\n      }\n      // Restore the real message handler.\n      self.onmessage = handleMessage;\n    };\n\n      // Module and memory were sent from main thread\n      Module['wasmModule'] = e.data.wasmModule;\n\n      // Use `const` here to ensure that the variable is scoped only to\n      // that iteration, allowing safe reference from a closure.\n      for (const handler of e.data.handlers) {\n        Module[handler] = function() {\n          postMessage({ cmd: 'callHandler', handler, args: [...arguments] });\n        }\n      }\n\n      Module['wasmMemory'] = e.data.wasmMemory;\n\n      Module['buffer'] = Module['wasmMemory'].buffer;\n\n      Module['workerID'] = e.data.workerID;\n\n      Module['ENVIRONMENT_IS_PTHREAD'] = true;\n\n      (e.data.urlOrBlob ? import(e.data.urlOrBlob) : import('./cas.mjs'))\n      .then(exports => exports.default(Module));\n    } else if (e.data.cmd === 'run') {\n      // Pass the thread address to wasm to store it for fast access.\n      Module['__emscripten_thread_init'](e.data.pthread_ptr, /*isMainBrowserThread=*/0, /*isMainRuntimeThread=*/0, /*canBlock=*/1);\n\n      // Await mailbox notifications with `Atomics.waitAsync` so we can start\n      // using the fast `Atomics.notify` notification path.\n      Module['__emscripten_thread_mailbox_await'](e.data.pthread_ptr);\n\n      assert(e.data.pthread_ptr);\n      // Also call inside JS module to set up the stack frame for this pthread in JS module scope\n      Module['establishStackSpace']();\n      Module['PThread'].receiveObjectTransfer(e.data);\n      Module['PThread'].threadInitTLS();\n\n      if (!initializedJS) {\n        // Embind must initialize itself on all threads, as it generates support JS.\n        // We only do this once per worker since they get reused\n        Module['__embind_initialize_bindings']();\n        initializedJS = true;\n      }\n\n      try {\n        Module['invokeEntryPoint'](e.data.start_routine, e.data.arg);\n      } catch(ex) {\n        if (ex != 'unwind') {\n          // The pthread \"crashed\".  Do not call `_emscripten_thread_exit` (which\n          // would make this thread joinable).  Instead, re-throw the exception\n          // and let the top level handler propagate it back to the main thread.\n          throw ex;\n        }\n      }\n    } else if (e.data.cmd === 'cancel') { // Main thread is asking for a pthread_cancel() on this thread.\n      if (Module['_pthread_self']()) {\n        Module['__emscripten_thread_exit'](-1);\n      }\n    } else if (e.data.target === 'setimmediate') {\n      // no-op\n    } else if (e.data.cmd === 'checkMailbox') {\n      if (initializedJS) {\n        Module['checkMailbox']();\n      }\n    } else if (e.data.cmd) {\n      // The received message looks like something that should be handled by this message\n      // handler, (since there is a e.data.cmd field present), but is not one of the\n      // recognized commands:\n      err('worker.js received unknown command ' + e.data.cmd);\n      err(e.data);\n    }\n  } catch(ex) {\n    err('worker.js onmessage() captured an uncaught exception: ' + ex);\n    if (ex && ex.stack) err(ex.stack);\n    if (Module['__emscripten_thread_crashed']) {\n      Module['__emscripten_thread_crashed']();\n    }\n    throw ex;\n  }\n};\n\nself.onmessage = handleMessage;\n\n\n"],"names":["modules","entry","mainEntry","parcelRequireName","globalName","globalObject","globalThis","self","window","global","previousRequire","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","i","length","mainExports","define","amd","JSON","parse","mapping","pairs","keys","resolved","getBundleURL","then","root","cacheLoader","Promise","reject","importScripts","e","cachedBundles","cachedPreloads","cachedPrefetches","loader","type","getCache","apply","arguments","catch","bundleURL","getBaseURL","url","replace","value","matches","stack","match","getOrigin","initializedJS","text","Array","prototype","slice","join","console","error","alert","postMessage","cmd","threadId","info","receiveInstance","WebAssembly","Instance","onunhandledrejection","reason","onmessage","handleMessage","data","messageQueue","handler","push","startWorker","instance","msg","wasmModule","handlers","args","wasmMemory","buffer","workerID","urlOrBlob","__parcel__require__","parcelRequire94c2","default","pthread_ptr","abort","receiveObjectTransfer","threadInitTLS","start_routine","arg","ex","target"],"version":3,"file":"cas.worker.bbc349ae.js.map"}