{"mappings":"AGUA,a,A,C,K,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,E,Q,C,Q,S,C,C,C,EFVA,AAAA,EAAA,SAAA,QAAA,CAA8C,KAAK,KAAA,CAAM,+I,G,E,Q,C,Q,S,C,C,C,E,E,E,O,C,W,I,E,A,G,E,G,E,E,O,C,U,I,E,A,G,E,GCEzD,IAcA,EACA,EAfI,EAAU,CAAC,EAcf,EAbA,SAAkB,CAAK,EAErB,IAAK,IADD,EAAO,OAAO,IAAA,CAAK,GACd,EAAI,EAAG,EAAI,EAAK,MAAA,CAAQ,IAC/B,CAAO,CAAC,CAAI,CAAC,EAAE,CAAC,CAAG,CAAK,CAAC,CAAI,CAAC,EAAE,CAAC,AAErC,EASA,EARA,SAAiB,CAAE,EACjB,IAAI,EAAW,CAAO,CAAC,EAAG,CAC1B,GAAI,AAAY,MAAZ,EACF,MAAM,AAAI,MAAM,oCAAsC,GAExD,OAAO,CACT,C,G,E,Q,C,Q,S,C,C,C,EEfA,EAAA,OAAA,CAAkB,MAAA,CAAmB,KAAO,AAAA,EAAA,SAAA,OAAA,CAA6C,UAAW,IAAA,CAAK,IAAM,EAAc,SDI5H,GAQD,EAAc,QAEd,CAAA,IAFA,IAAI,EAAS,CAAC,EAGV,EAAgB,CAAA,EAkBhB,EAZJ,WACE,IAAI,EAAO,MAAM,SAAA,CAAU,KAAA,CAAM,IAAA,CAAK,WAAW,IAAA,CAAK,KACtD,QAAQ,KAAA,CAAM,EAChB,CAUA,CAAA,KAAK,KAAA,CATL,WACE,IAAI,EAAO,MAAM,SAAA,CAAU,KAAA,CAAM,IAAA,CAAK,WAAW,IAAA,CAAK,KACtD,YAAY,CAAC,IAAK,QAAS,KAAM,EAAM,SAAU,EAAO,aAAgB,EAAE,EAC5E,EAQA,EAAO,eAAkB,CAAG,CAAC,EAAM,KAGjC,IAAI,EAAS,EAAO,UAAa,CAOjC,OALA,EAAO,UAAa,CAAG,KAKhB,EAJQ,IAAI,YAAY,QAAA,CAAS,EAAQ,GAKlD,EAIA,KAAK,oBAAA,CAAuB,AAAC,IAC3B,MAAM,EAAE,MAAA,EAAU,CACpB,EAsGA,KAAK,SAAA,CApGL,SAAS,EAAc,CAAC,EACtB,GAAI,CACF,GAAI,AAAe,SAAf,EAAE,IAAA,CAAK,GAAA,CAAgB,CAG3B,IAAI,EAAe,EAAE,CAqBnB,IAAK,IAAM,KApBb,KAAK,SAAA,CAAY,AAAC,GAAM,EAAa,IAAA,CAAK,GAG1C,KAAK,WAAA,CAAc,AAAC,IAKlB,IAAK,IAAI,KAJT,EAAS,EAET,YAAY,CAAE,IAAO,QAAS,GAEd,GACd,EAAc,EAGhB,CAAA,KAAK,SAAA,CAAY,CACnB,EAGE,EAAO,UAAa,CAAG,EAAE,IAAA,CAAK,UAA9B,CAIsB,EAAE,IAAA,CAAK,QAAA,EAC3B,CAAM,CAAC,EAAQ,CAAG,WAChB,YAAY,CAAE,IAAK,cAAe,QAAA,EAAS,KAAM,IAAI,UAAU,AAAC,EAClE,CAGF,CAAA,EAAO,UAAa,CAAG,EAAE,IAAA,CAAK,UAA9B,CAEA,EAAO,MAAS,CAAG,EAAO,UAAa,CAAC,MAAxC,CAEA,EAAO,QAAW,CAAG,EAAE,IAAA,CAAK,QAA5B,CAEA,EAAO,sBAAyB,CAAG,CAAA,EAElC,AAAA,CAAA,EAAE,IAAA,CAAK,SAAA,CAAY,oBAAO,EAAE,IAAA,CAAK,SAAA,EAAa,kBAAA,QAAO,EACrD,IAAA,CAAK,AAAA,GAAW,EAAQ,OAAA,CAAQ,GACnC,MAAO,GAAI,AAAe,QAAf,EAAE,IAAA,CAAK,GAAA,CAAe,CAE/B,EAAO,wBAA2B,CAAC,EAAE,IAAA,CAAK,WAAA,CAAqC,EAA2B,EAAgB,GAI1H,EAAO,iCAAoC,CAAC,EAAE,IAAA,CAAK,WAAnD,EAEO,EAAE,IAAA,CAAK,WAAd,EAvFY,MAAM,+BAyFlB,EAAO,mBAAsB,GAC7B,EAAO,OAAU,CAAC,qBAAA,CAAsB,EAAE,IAA1C,EACA,EAAO,OAAU,CAAC,aAAlB,GAEK,IAGH,EAAO,4BAA+B,GACtC,EAAgB,CAAA,GAGlB,GAAI,CACF,EAAO,gBAAmB,CAAC,EAAE,IAAA,CAAK,aAAA,CAAe,EAAE,IAAA,CAAK,GAAxD,CACF,CAAE,MAAM,EAAI,CACV,GAAI,AAAM,UAAN,EAIF,MAAM,CAEV,CACF,KAAW,AAAe,WAAf,EAAE,IAAA,CAAK,GAAA,CACZ,EAAO,aAAgB,IACzB,EAAO,wBAA2B,CAAC,IAEV,iBAAlB,EAAE,IAAA,CAAK,MAAA,GAEP,AAAe,iBAAf,EAAE,IAAA,CAAK,GAAA,CACZ,GACF,EAAO,YAAe,GAEf,EAAE,IAAA,CAAK,GAAA,GAIhB,EAAI,sCAAwC,EAAE,IAAA,CAAK,GAAnD,EACA,EAAI,EAAE,IAAN,GAEJ,CAAE,MAAM,EAAI,CAMV,MALA,EAAI,yDAA2D,GAC3D,GAAM,EAAG,KAAA,EAAO,EAAI,EAAG,KAA3B,EACI,EAAO,2BAA8B,EACvC,EAAO,2BAA8B,GAEjC,CACR,CACF","sources":["<anon>","node_modules/@parcel/runtime-js/lib/runtime-6f84cb4a8155feac.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","cas.worker.js","node_modules/@parcel/runtime-js/lib/runtime-31ea8dd659cfbd90.js"],"sourcesContent":["(() => {\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire94c2\"] = parcelRequire;\n}\nparcelRequire.register(\"7kC7q\", function(module, exports) {\n\n(parcelRequire(\"bGWGM\")).register(JSON.parse('{\"ewdRd\":\"cas.worker.702a42fc.js\",\"i6D21\":\"cas.662c88d0.js\",\"32MbT\":\"cas.ff7b2bd0.wasm\"}'));\n\n});\nparcelRequire.register(\"bGWGM\", function(module, exports) {\n\n$parcel$export(module.exports, \"register\", () => $8831245f07480bee$export$6503ec6e8aabbaf, (v) => $8831245f07480bee$export$6503ec6e8aabbaf = v);\n$parcel$export(module.exports, \"resolve\", () => $8831245f07480bee$export$f7ad0328861e2f03, (v) => $8831245f07480bee$export$f7ad0328861e2f03 = v);\nvar $8831245f07480bee$export$6503ec6e8aabbaf;\nvar $8831245f07480bee$export$f7ad0328861e2f03;\n\"use strict\";\nvar $8831245f07480bee$var$mapping = {};\nfunction $8831245f07480bee$var$register(pairs) {\n    var keys = Object.keys(pairs);\n    for(var i = 0; i < keys.length; i++)$8831245f07480bee$var$mapping[keys[i]] = pairs[keys[i]];\n}\nfunction $8831245f07480bee$var$resolve(id) {\n    var resolved = $8831245f07480bee$var$mapping[id];\n    if (resolved == null) throw new Error(\"Could not resolve bundle with id \" + id);\n    return resolved;\n}\n$8831245f07480bee$export$6503ec6e8aabbaf = $8831245f07480bee$var$register;\n$8831245f07480bee$export$f7ad0328861e2f03 = $8831245f07480bee$var$resolve;\n\n});\n\n\nparcelRequire.register(\"jW6zH\", function(module, exports) {\n\nmodule.exports = import(\"./\" + (parcelRequire(\"bGWGM\")).resolve(\"i6D21\")).then(()=>parcelRequire(\"9cUbE\"));\n\n});\n\n\n\nparcelRequire(\"7kC7q\");\n})();\n/**\n * @license\n * Copyright 2015 The Emscripten Authors\n * SPDX-License-Identifier: MIT\n */ // Pthread Web Worker startup routine:\n// This is the entry point file that is loaded first by each Web Worker\n// that executes pthreads on the Emscripten application.\n\"use strict\";\nvar Module = {};\n// Thread-local guard variable for one-time init of the JS state\nvar initializedJS = false;\nfunction assert(condition, text) {\n    if (!condition) abort(\"Assertion failed: \" + text);\n}\nfunction threadPrintErr() {\n    var text = Array.prototype.slice.call(arguments).join(\" \");\n    console.error(text);\n}\nfunction threadAlert() {\n    var text = Array.prototype.slice.call(arguments).join(\" \");\n    postMessage({\n        cmd: \"alert\",\n        text: text,\n        threadId: Module[\"_pthread_self\"]()\n    });\n}\n// We don't need out() for now, but may need to add it if we want to use it\n// here. Or, if this code all moves into the main JS, that problem will go\n// away. (For now, adding it here increases code size for no benefit.)\nvar out = ()=>{\n    throw \"out() is not defined in worker.js.\";\n};\nvar err = threadPrintErr;\nself.alert = threadAlert;\nModule[\"instantiateWasm\"] = (info, receiveInstance)=>{\n    // Instantiate from the module posted from the main thread.\n    // We can just use sync instantiation in the worker.\n    var module = Module[\"wasmModule\"];\n    // We don't need the module anymore; new threads will be spawned from the main thread.\n    Module[\"wasmModule\"] = null;\n    var instance = new WebAssembly.Instance(module, info);\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193,\n    // the above line no longer optimizes out down to the following line.\n    // When the regression is fixed, we can remove this if/else.\n    return receiveInstance(instance);\n};\n// Turn unhandled rejected promises into errors so that the main thread will be\n// notified about them.\nself.onunhandledrejection = (e)=>{\n    throw e.reason ?? e;\n};\nfunction handleMessage(e) {\n    try {\n        if (e.data.cmd === \"load\") {\n            // Until we initialize the runtime, queue up any further incoming messages.\n            let messageQueue = [];\n            self.onmessage = (e)=>messageQueue.push(e);\n            // And add a callback for when the runtime is initialized.\n            self.startWorker = (instance)=>{\n                Module = instance;\n                // Notify the main thread that this thread has loaded.\n                postMessage({\n                    \"cmd\": \"loaded\"\n                });\n                // Process any messages that were queued before the thread was ready.\n                for (let msg of messageQueue)handleMessage(msg);\n                // Restore the real message handler.\n                self.onmessage = handleMessage;\n            };\n            // Module and memory were sent from main thread\n            Module[\"wasmModule\"] = e.data.wasmModule;\n            // Use `const` here to ensure that the variable is scoped only to\n            // that iteration, allowing safe reference from a closure.\n            for (const handler of e.data.handlers)Module[handler] = function() {\n                postMessage({\n                    cmd: \"callHandler\",\n                    handler,\n                    args: [\n                        ...arguments\n                    ]\n                });\n            };\n            Module[\"wasmMemory\"] = e.data.wasmMemory;\n            Module[\"buffer\"] = Module[\"wasmMemory\"].buffer;\n            Module[\"workerID\"] = e.data.workerID;\n            Module[\"ENVIRONMENT_IS_PTHREAD\"] = true;\n            (e.data.urlOrBlob ? __parcel__require__(e.data.urlOrBlob) : parcelRequire94c2(\"jW6zH\")).then((exports)=>exports.default(Module));\n        } else if (e.data.cmd === \"run\") {\n            // Pass the thread address to wasm to store it for fast access.\n            Module[\"__emscripten_thread_init\"](e.data.pthread_ptr, /*isMainBrowserThread=*/ 0, /*isMainRuntimeThread=*/ 0, /*canBlock=*/ 1);\n            // Await mailbox notifications with `Atomics.waitAsync` so we can start\n            // using the fast `Atomics.notify` notification path.\n            Module[\"__emscripten_thread_mailbox_await\"](e.data.pthread_ptr);\n            assert(e.data.pthread_ptr);\n            // Also call inside JS module to set up the stack frame for this pthread in JS module scope\n            Module[\"establishStackSpace\"]();\n            Module[\"PThread\"].receiveObjectTransfer(e.data);\n            Module[\"PThread\"].threadInitTLS();\n            if (!initializedJS) {\n                // Embind must initialize itself on all threads, as it generates support JS.\n                // We only do this once per worker since they get reused\n                Module[\"__embind_initialize_bindings\"]();\n                initializedJS = true;\n            }\n            try {\n                Module[\"invokeEntryPoint\"](e.data.start_routine, e.data.arg);\n            } catch (ex) {\n                if (ex != \"unwind\") // The pthread \"crashed\".  Do not call `_emscripten_thread_exit` (which\n                // would make this thread joinable).  Instead, re-throw the exception\n                // and let the top level handler propagate it back to the main thread.\n                throw ex;\n            }\n        } else if (e.data.cmd === \"cancel\") {\n            if (Module[\"_pthread_self\"]()) Module[\"__emscripten_thread_exit\"](-1);\n        } else if (e.data.target === \"setimmediate\") ;\n        else if (e.data.cmd === \"checkMailbox\") {\n            if (initializedJS) Module[\"checkMailbox\"]();\n        } else if (e.data.cmd) {\n            // The received message looks like something that should be handled by this message\n            // handler, (since there is a e.data.cmd field present), but is not one of the\n            // recognized commands:\n            err(\"worker.js received unknown command \" + e.data.cmd);\n            err(e.data);\n        }\n    } catch (ex) {\n        err(\"worker.js onmessage() captured an uncaught exception: \" + ex);\n        if (ex && ex.stack) err(ex.stack);\n        if (Module[\"__emscripten_thread_crashed\"]) Module[\"__emscripten_thread_crashed\"]();\n        throw ex;\n    }\n}\nself.onmessage = handleMessage;\n\n//# sourceMappingURL=cas.worker.702a42fc.js.map\n","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"ewdRd\\\":\\\"cas.worker.702a42fc.js\\\",\\\"i6D21\\\":\\\"cas.662c88d0.js\\\",\\\"32MbT\\\":\\\"cas.ff7b2bd0.wasm\\\"}\"));","\"use strict\";\n\nvar mapping = {};\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping[id];\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return resolved;\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","/**\n * @license\n * Copyright 2015 The Emscripten Authors\n * SPDX-License-Identifier: MIT\n */\n\n// Pthread Web Worker startup routine:\n// This is the entry point file that is loaded first by each Web Worker\n// that executes pthreads on the Emscripten application.\n\n'use strict';\n\nvar Module = {};\n\n// Thread-local guard variable for one-time init of the JS state\nvar initializedJS = false;\n\nfunction assert(condition, text) {\n  if (!condition) abort('Assertion failed: ' + text);\n}\n\nfunction threadPrintErr() {\n  var text = Array.prototype.slice.call(arguments).join(' ');\n  console.error(text);\n}\nfunction threadAlert() {\n  var text = Array.prototype.slice.call(arguments).join(' ');\n  postMessage({cmd: 'alert', text: text, threadId: Module['_pthread_self']()});\n}\n// We don't need out() for now, but may need to add it if we want to use it\n// here. Or, if this code all moves into the main JS, that problem will go\n// away. (For now, adding it here increases code size for no benefit.)\nvar out = () => { throw 'out() is not defined in worker.js.'; }\nvar err = threadPrintErr;\nself.alert = threadAlert;\n\nModule['instantiateWasm'] = (info, receiveInstance) => {\n  // Instantiate from the module posted from the main thread.\n  // We can just use sync instantiation in the worker.\n  var module = Module['wasmModule'];\n  // We don't need the module anymore; new threads will be spawned from the main thread.\n  Module['wasmModule'] = null;\n  var instance = new WebAssembly.Instance(module, info);\n  // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193,\n  // the above line no longer optimizes out down to the following line.\n  // When the regression is fixed, we can remove this if/else.\n  return receiveInstance(instance);\n}\n\n// Turn unhandled rejected promises into errors so that the main thread will be\n// notified about them.\nself.onunhandledrejection = (e) => {\n  throw e.reason ?? e;\n};\n\nfunction handleMessage(e) {\n  try {\n    if (e.data.cmd === 'load') { // Preload command that is called once per worker to parse and load the Emscripten code.\n\n    // Until we initialize the runtime, queue up any further incoming messages.\n    let messageQueue = [];\n    self.onmessage = (e) => messageQueue.push(e);\n\n    // And add a callback for when the runtime is initialized.\n    self.startWorker = (instance) => {\n      Module = instance;\n      // Notify the main thread that this thread has loaded.\n      postMessage({ 'cmd': 'loaded' });\n      // Process any messages that were queued before the thread was ready.\n      for (let msg of messageQueue) {\n        handleMessage(msg);\n      }\n      // Restore the real message handler.\n      self.onmessage = handleMessage;\n    };\n\n      // Module and memory were sent from main thread\n      Module['wasmModule'] = e.data.wasmModule;\n\n      // Use `const` here to ensure that the variable is scoped only to\n      // that iteration, allowing safe reference from a closure.\n      for (const handler of e.data.handlers) {\n        Module[handler] = function() {\n          postMessage({ cmd: 'callHandler', handler, args: [...arguments] });\n        }\n      }\n\n      Module['wasmMemory'] = e.data.wasmMemory;\n\n      Module['buffer'] = Module['wasmMemory'].buffer;\n\n      Module['workerID'] = e.data.workerID;\n\n      Module['ENVIRONMENT_IS_PTHREAD'] = true;\n\n      (e.data.urlOrBlob ? import(e.data.urlOrBlob) : import('./cas.mjs'))\n      .then(exports => exports.default(Module));\n    } else if (e.data.cmd === 'run') {\n      // Pass the thread address to wasm to store it for fast access.\n      Module['__emscripten_thread_init'](e.data.pthread_ptr, /*isMainBrowserThread=*/0, /*isMainRuntimeThread=*/0, /*canBlock=*/1);\n\n      // Await mailbox notifications with `Atomics.waitAsync` so we can start\n      // using the fast `Atomics.notify` notification path.\n      Module['__emscripten_thread_mailbox_await'](e.data.pthread_ptr);\n\n      assert(e.data.pthread_ptr);\n      // Also call inside JS module to set up the stack frame for this pthread in JS module scope\n      Module['establishStackSpace']();\n      Module['PThread'].receiveObjectTransfer(e.data);\n      Module['PThread'].threadInitTLS();\n\n      if (!initializedJS) {\n        // Embind must initialize itself on all threads, as it generates support JS.\n        // We only do this once per worker since they get reused\n        Module['__embind_initialize_bindings']();\n        initializedJS = true;\n      }\n\n      try {\n        Module['invokeEntryPoint'](e.data.start_routine, e.data.arg);\n      } catch(ex) {\n        if (ex != 'unwind') {\n          // The pthread \"crashed\".  Do not call `_emscripten_thread_exit` (which\n          // would make this thread joinable).  Instead, re-throw the exception\n          // and let the top level handler propagate it back to the main thread.\n          throw ex;\n        }\n      }\n    } else if (e.data.cmd === 'cancel') { // Main thread is asking for a pthread_cancel() on this thread.\n      if (Module['_pthread_self']()) {\n        Module['__emscripten_thread_exit'](-1);\n      }\n    } else if (e.data.target === 'setimmediate') {\n      // no-op\n    } else if (e.data.cmd === 'checkMailbox') {\n      if (initializedJS) {\n        Module['checkMailbox']();\n      }\n    } else if (e.data.cmd) {\n      // The received message looks like something that should be handled by this message\n      // handler, (since there is a e.data.cmd field present), but is not one of the\n      // recognized commands:\n      err('worker.js received unknown command ' + e.data.cmd);\n      err(e.data);\n    }\n  } catch(ex) {\n    err('worker.js onmessage() captured an uncaught exception: ' + ex);\n    if (ex && ex.stack) err(ex.stack);\n    if (Module['__emscripten_thread_crashed']) {\n      Module['__emscripten_thread_crashed']();\n    }\n    throw ex;\n  }\n};\n\nself.onmessage = handleMessage;\n\n\n","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"i6D21\"))).then(() => parcelRequire('9cUbE'));"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","JSON","parse","$8831245f07480bee$export$6503ec6e8aabbaf","$8831245f07480bee$export$f7ad0328861e2f03","$8831245f07480bee$var$mapping","pairs","keys","i","length","resolved","resolve","then","Module","initializedJS","text","Array","prototype","slice","arguments","join","console","error","alert","postMessage","cmd","threadId","info","receiveInstance","WebAssembly","Instance","onunhandledrejection","reason","onmessage","handleMessage","data","messageQueue","handler","push","startWorker","instance","msg","wasmModule","handlers","args","wasmMemory","buffer","workerID","urlOrBlob","__parcel__require__","parcelRequire94c2","default","pthread_ptr","abort","receiveObjectTransfer","threadInitTLS","start_routine","arg","ex","target","stack"],"version":3,"file":"cas.worker.702a42fc.js.map"}